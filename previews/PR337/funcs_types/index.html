<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and functions · ODINN.jl</title><meta name="title" content="Types and functions · ODINN.jl"/><meta property="og:title" content="Types and functions · ODINN.jl"/><meta property="twitter:title" content="Types and functions · ODINN.jl"/><meta name="description" content="Documentation for ODINN.jl."/><meta property="og:description" content="Documentation for ODINN.jl."/><meta property="twitter:description" content="Documentation for ODINN.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../forward_simulation/">Forward simulation</a></li><li><a class="tocitem" href="../functional_inversion/">Functional inversion</a></li></ul></li><li class="is-active"><a class="tocitem" href>Types and functions</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Glaciers"><span>Glaciers</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Results-and-plotting"><span>Results and plotting</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types and functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/funcs_types.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Types-and-functions"><a class="docs-heading-anchor" href="#Types-and-functions">Types and functions</a><a id="Types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-functions" title="Permalink"></a></h1><p>In this page, we will go through the main types (i.e. <code>struct</code>s) used in <code>ODINN.jl</code>&#39;s architecture, and the main functions linked to those types.</p><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>There are different types of parameters, holding specific information for different modelling aspects. All the types of parameters are wrapped into a <code>Parameter</code> type, which is threaded throughout <code>ODINN.jl</code>. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Parameters" href="#Sleipnir.Parameters"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    mutable struct Parameters{PPHY &lt;: AbstractEmptyParams, PSIM &lt;: AbstractEmptyParams, PHY &lt;: AbstractEmptyParams,
                    PSOL &lt;: AbstractEmptyParams, PUDE &lt;: AbstractEmptyParams, PINV &lt;: AbstractEmptyParams}</code></pre><p>A mutable struct that holds various parameter sets for different aspects of a simulation or model.</p><p><strong>Fields</strong></p><ul><li><code>physical::PPHY</code>: Physical parameters.</li><li><code>simulation::PSIM</code>: Simulation parameters.</li><li><code>hyper::PHY</code>: Hyperparameters.</li><li><code>solver::PSOL</code>: Solver parameters.</li><li><code>UDE::PUDE</code>: Universal Differential Equation (UDE) parameters.</li><li><code>inversion::PINV</code>: Inversion parameters.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>PPHY</code>: Type of the physical parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PSIM</code>: Type of the simulation parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PHY</code>: Type of the hyperparameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PSOL</code>: Type of the solver parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PUDE</code>: Type of the UDE parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PINV</code>: Type of the inversion parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/parameters/Parameters.jl#L19-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Parameters" href="#ODINN.Parameters"><code>ODINN.Parameters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructor for the <code>Parameters</code> type. Since some of the subtypes of parameters are defined in different packages of the ODINN ecosystem, this constructor will call the constructors of the different subtypes and return a <code>Parameters</code> object with the corresponding subtypes.  The <code>Parameters</code> mutable struct is defined in <code>Sleipnir.jl</code> using abstract types, which are later on defined in the different packages of the ODINN ecosystem.</p><pre><code class="nohighlight hljs">Parameters(;
        physical::PhysicalParameters = PhysicalParameters(),
        simulation::SimulationParameters = SimulationParameters(),
        solver::SolverParameters = SolverParameters(),
        hyper::Hyperparameters = Hyperparameters(),
        UDE::UDEparameters = UDEparameters()
        inversion::InversionParameters = InversionParameters()
        )</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: Physical parameters for the simulation.</li><li><code>simulation::SimulationParameters</code>: Parameters related to the simulation setup.</li><li><code>solver::SolverParameters</code>: Parameters for the solver configuration.</li><li><code>hyper::Hyperparameters</code>: Hyperparameters for the model.</li><li><code>UDE::UDEparameters</code>: Parameters specific to the UDE (Universal Differential Equation).</li><li><code>inversion::InversionParameters</code>: Parameters for inversion processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/parameters/UDEparameters.jl#L87-L112">source</a></section></article><p>The main types of parameters are the following ones:</p><h3 id="Simulation-parameters"><a class="docs-heading-anchor" href="#Simulation-parameters">Simulation parameters</a><a id="Simulation-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-parameters" title="Permalink"></a></h3><p>Simulation parameters are used to specify anything related to ODINN simulations, ranging from types, working directories to multiprocessing.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.SimulationParameters" href="#Sleipnir.SimulationParameters"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure to hold simulation parameters for a simulation in ODINN.</p><pre><code class="nohighlight hljs">struct SimulationParameters{I &lt;: Integer, F &lt;: AbstractFloat, VM &lt;: VelocityMapping} &lt;: AbstractParameters</code></pre><p><strong>Fields</strong></p><ul><li><code>use_MB::Bool</code>: Flag to indicate whether mass balance should be used.</li><li><code>use_iceflow::Bool</code>: Flag to indicate whether ice flow should be used.</li><li><code>plots::Bool</code>: Flag to indicate whether plots should be generated.</li><li><code>velocities::Bool</code>: Flag to indicate whether velocities should be calculated.</li><li><code>overwrite_climate::Bool</code>: Flag to indicate whether to overwrite climate data.</li><li><code>use_glathida_data::Bool</code>: Flag to indicate whether to use GLATHIDA data.</li><li><code>tspan::Tuple{F, F}</code>: Time span for the simulation.</li><li><code>step::F</code>: Time step for the simulation.</li><li><code>multiprocessing::Bool</code>: Flag to indicate whether multiprocessing should be used.</li><li><code>workers::I</code>: Number of workers for multiprocessing.</li><li><code>working_dir::String</code>: Directory for working files.</li><li><code>test_mode::Bool</code>: Flag to indicate whether to run in test mode.</li><li><code>rgi_paths::Dict{String, String}</code>: Dictionary of RGI paths.</li><li><code>ice_thickness_source::String</code>: Source of ice thickness data.</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.</li><li><code>gridScalingFactor::I</code>: Grid downscaling factor, used to speed-up the tests.   Default value is 1 which means no downscaling is applied.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/parameters/SimulationParameters.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.SimulationParameters-Tuple{}" href="#Sleipnir.SimulationParameters-Tuple{}"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructor for <code>SimulationParameters</code> type, including default values.</p><pre><code class="nohighlight hljs">SimulationParameters(;
    use_MB::Bool = true,
    use_iceflow::Bool = true,
    plots::Bool = true,
    velocities::Bool = true,
    overwrite_climate::Bool = false,
    use_glathida_data::Bool = false,
    tspan::Tuple{F, F} = (2010.0,2015.0),
    step::F = 1/12,
    multiprocessing::Bool = true,
    workers::I = 4,
    working_dir::String = &quot;&quot;,
    test_mode::Bool = false,
    rgi_paths::Dict{String, String} = Dict{String, String}(),
    ice_thickness_source::String = &quot;Farinotti19&quot;,
    mapping::VM = MeanDateVelocityMapping(),
    gridScalingFactor::I = 1,
) where {I &lt;: Integer, F &lt;: AbstractFloat, VM &lt;: VelocityMapping}</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>use_MB::Bool</code>: Whether to use mass balance (default: <code>true</code>).</li><li><code>use_iceflow::Bool</code>: Whether to use ice flow (default: <code>true</code>).</li><li><code>plots::Bool</code>: Whether to generate plots (default: <code>true</code>).</li><li><code>velocities::Bool</code>: Whether to calculate velocities (default: <code>true</code>).</li><li><code>overwrite_climate::Bool</code>: Whether to overwrite climate data (default: <code>false</code>).</li><li><code>use_glathida_data::Bool</code>: Whether to use GLATHIDA data (default: <code>false</code>).</li><li><code>float_type::DataType</code>: Data type for floating point numbers (default: <code>Float64</code>).</li><li><code>int_type::DataType</code>: Data type for integers (default: <code>Int64</code>).</li><li><code>tspan::Tuple{F, F}</code>: Time span for the simulation (default: <code>(2010.0, 2015.0)</code>).</li><li><code>step::F</code>: Time step for the simulation (default: <code>1/12</code>).</li><li><code>multiprocessing::Bool</code>: Whether to use multiprocessing (default: <code>true</code>).</li><li><code>workers::I</code>: Number of workers for multiprocessing (default: <code>4</code>).</li><li><code>working_dir::String</code>: Working directory for the simulation (default: <code>&quot;&quot;</code>).</li><li><code>test_mode::Bool</code>: Whether to run in test mode (default: <code>false</code>).</li><li><code>rgi_paths::Dict{String, String}</code>: Dictionary of RGI paths (default: <code>Dict{String, String}()</code>).</li><li><code>ice_thickness_source::String</code>: Source of ice thickness data, either <code>&quot;Millan22&quot;</code> or <code>&quot;Farinotti19&quot;</code> (default: <code>&quot;Farinotti19&quot;</code>).</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.</li><li><code>gridScalingFactor::I</code>: Grid downscaling factor, used to speed-up the tests.   Default value is 1 which means no downscaling is applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>simulation_parameters</code>: A new <code>SimulationParameters</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If <code>ice_thickness_source</code> is not <code>&quot;Millan22&quot;</code> or <code>&quot;Farinotti19&quot;</code>.</li></ul><p><strong>Notes</strong></p><ul><li>If the global variable ODINN<em>OVERWRITE</em>MULTI is set to true, multiprocessing is   disabled in any case. This is to fix the documentation generation as for the   moment Literate.jl freezes when multiprocessing is enabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/parameters/SimulationParameters.jl#L50-L105">source</a></section></article><h3 id="Physical-parameters"><a class="docs-heading-anchor" href="#Physical-parameters">Physical parameters</a><a id="Physical-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-parameters" title="Permalink"></a></h3><p>Physical parameters are used to store physical constants used in the physical and machine learning models. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.PhysicalParameters" href="#Sleipnir.PhysicalParameters"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure representing physical parameters used in simulations.</p><pre><code class="nohighlight hljs">PhysicalParameters{F &lt;: AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>ρ::F</code>: Density of ice.</li><li><code>g::F</code>: Gravitational acceleration.</li><li><code>ϵ::F</code>: A small parameter, often used for perturbations.</li><li><code>η₀::F</code>: Initial viscosity.</li><li><code>maxA::F</code>: Maximum A.</li><li><code>minA::F</code>: Minimum A.</li><li><code>maxTlaw::F</code>: Maximum temperature according to some law.</li><li><code>minTlaw::F</code>: Minimum temperature according to some law.</li><li><code>noise_A_magnitude::F</code>: Magnitude of noise in A.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/parameters/PhysicalParameters.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.PhysicalParameters-Tuple{}" href="#Sleipnir.PhysicalParameters-Tuple{}"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Initialize the physical parameters of a model.</p><pre><code class="nohighlight hljs">PhysicalParameters(;
    ρ::Float64 = 900.0,
    g::Float64 = 9.81,
    ϵ::Float64 = 1e-3,
    η₀::F = 1.0, 
    maxA::Float64 = 8e-17,
    minA::Float64 = 8.5e-20,
    maxTlaw::Float64 = 1.0,
    minTlaw::Float64 = -25.0,
    noise_A_magnitude::Float64 = 5e-18
    )</code></pre><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `ρ`: Ice density
- `g`: Gravitational constant
- `ϵ`: Small number
- `η₀`:  
- `maxA`: Maximum value for `A` (Glen&#39;s coefficient)
- `minA`: Minimum value for `A` (Glen&#39;s coefficient)
- `maxTlaw`: Maximum value of Temperature used in simulations on fake law
- `minTlaw`: Minimum value of Temperature used in simulations on fake law
- `noise_A_magnitude`: Magnitude of noise added to A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/parameters/PhysicalParameters.jl#L30-L56">source</a></section></article><h3 id="Solver-parameters"><a class="docs-heading-anchor" href="#Solver-parameters">Solver parameters</a><a id="Solver-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-parameters" title="Permalink"></a></h3><p>Solver parameters determine all aspects related to the numerical scheme used to solve the differential equations of glacier ice flow.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SolverParameters" href="#Huginn.SolverParameters"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct that holds parameters for the solver.</p><pre><code class="nohighlight hljs">SolverParameters{F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Fields</strong></p><ul><li><code>solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm</code>: The algorithm used for solving differential equations.</li><li><code>reltol::F</code>: The relative tolerance for the solver.</li><li><code>step::F</code>: The step size for the solver.</li><li><code>tstops::Union{Nothing, Vector{F}}</code>: Optional vector of time points where the solver should stop for the callbacks.</li><li><code>save_everystep::Bool</code>: Flag indicating whether to save the solution at every step.</li><li><code>progress::Bool</code>: Flag indicating whether to show progress during the solving process.</li><li><code>progress_steps::I</code>: The number of steps between progress updates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/parameters/SolverParameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SolverParameters-Tuple{}" href="#Huginn.SolverParameters-Tuple{}"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructs a <code>SolverParameters</code> object with the specified parameters or using default values.</p><pre><code class="nohighlight hljs">SolverParameters(; solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),
                  reltol::F = 1e-12,
                  step::F = 1.0/12.0,
                  tstops::Union{Nothing,Vector{F}} = nothing,
                  save_everystep = false,
                  progress::Bool = true,
                  progress_steps::I = 10) where {F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm</code>: The ODE solver algorithm to use. Defaults to <code>RDPK3Sp35()</code>.</li><li><code>reltol::F</code>: The relative tolerance for the solver. Defaults to <code>1e-12</code>.</li><li><code>step::F</code>: The step size for the callbacks. These are mainly used to run the surface mass balance model. Defaults to <code>1.0/12.0</code> (i.e. a month).</li><li><code>tstops::Union{Nothing, Vector{F}}</code>: Optional vector of time points where the solver should stop. Defaults to <code>nothing</code>.</li><li><code>save_everystep::Bool</code>: Whether to save the solution at every step. Defaults to <code>false</code>.</li><li><code>progress::Bool</code>: Whether to show progress during the solving process. Defaults to <code>true</code>.</li><li><code>progress_steps::I</code>: The number of steps between progress updates. Defaults to <code>10</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>solver_parameters</code>: A <code>SolverParameters</code> object constructed with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/parameters/SolverParameters.jl#L27-L49">source</a></section></article><h3 id="Hyperparameters"><a class="docs-heading-anchor" href="#Hyperparameters">Hyperparameters</a><a id="Hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#Hyperparameters" title="Permalink"></a></h3><p>Hyperparameters determine different aspects of a given machine learning model. For now, these are focused on neural networks, but we plan to extend them in the future for other types of regressors. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Hyperparameters" href="#ODINN.Hyperparameters"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Hyperparameters{F &lt;: AbstractFloat, I &lt;: Int} &lt;: AbstractParameters</code></pre><p>A mutable struct that holds hyperparameters for training a machine learning model.</p><p><strong>Keyword arguments</strong></p><ul><li><code>current_epoch::I</code>: The current epoch number.</li><li><code>current_minibatch::I</code>: The current minibatch number.</li><li><code>loss_history::Vector{F}</code>: A vector storing the history of loss values.</li><li><code>optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}</code>: The optimizer used for training.</li><li><code>loss_epoch::F</code>: The loss value for the current epoch.</li><li><code>epochs::I</code>: The total number of epochs for training.</li><li><code>batch_size::I</code>: The size of each minibatch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/parameters/Hyperparameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Hyperparameters-Tuple{}" href="#ODINN.Hyperparameters-Tuple{}"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hyperparameters(; current_epoch::Int64 = 1, current_minibatch::Int64 = 1, loss_history::Vector{Float64} = Vector{Float64}(), optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule} = BFGS(initial_stepnorm=0.001), loss_epoch::Float64 = 0.0, epochs::Int64 = 50, batch_size::Int64 = 15)</code></pre><p>Constructs a <code>Hyperparameters</code> object with the specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>current_epoch::Int64</code>: The current epoch number. Defaults to 1.</li><li><code>current_minibatch::Int64</code>: The current minibatch number. Defaults to 1.</li><li><code>loss_history::Vector{Float64}</code>: A vector to store the history of loss values. Defaults to an empty vector.</li><li><code>optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}</code>: The optimizer to be used. Defaults to <code>BFGS(initial_stepnorm=0.001)</code>.</li><li><code>loss_epoch::Float64</code>: The loss value for the current epoch. Defaults to 0.0.</li><li><code>epochs::Int64</code>: The total number of epochs. Defaults to 50.</li><li><code>batch_size::Int64</code>: The size of each minibatch. Defaults to 15.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hyperparameters</code> object initialized with the provided values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/parameters/Hyperparameters.jl#L28-L44">source</a></section></article><h3 id="UDE-parameters"><a class="docs-heading-anchor" href="#UDE-parameters">UDE parameters</a><a id="UDE-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#UDE-parameters" title="Permalink"></a></h3><p>Universal Differential Equation (UDE) parameters are used to determine different modelling choices regarding the use of UDEs, such as wich sensitivity algorithm to use, which target (e.g. SIA parameter to target), or which optimization method to use.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.UDEparameters" href="#ODINN.UDEparameters"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct that holds parameters for a UDE (Universal Differential Equation).</p><pre><code class="nohighlight hljs">UDEparameters{ADJ &lt;: AbstractAdjointMethod} &lt;: AbstractParameters</code></pre><p><strong>Fields</strong></p><ul><li><code>sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm</code>: The sensitivity algorithm used for adjoint sensitivity analysis.</li><li><code>optimization_method::String</code>: The optimization method to be used.</li><li><code>loss_type::String</code>: The type of loss function to be used.</li><li><code>scale_loss::Bool</code>: A boolean indicating whether to scale the loss.</li><li><code>target::Symbol</code>: The target variable for the optimization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/parameters/UDEparameters.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.UDEparameters-Tuple{}" href="#ODINN.UDEparameters-Tuple{}"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UDEparameters(; sensealg, optim_autoAD, grad, optimization_method, loss_type, empirical_loss_function, scale_loss, target) where {ADJ &lt;: AbstractAdjointMethod}</code></pre><p>Create a <code>UDEparameters</code> object for configuring the sensitivity analysis and optimization of a Universal Differential Equation (UDE).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm</code>: The sensitivity algorithm to use for adjoint calculations. Defaults to <code>GaussAdjoint(autojacvec=SciMLSensitivity.EnzymeVJP())</code>.</li><li><code>optim_autoAD::AbstractADType</code>: The automatic differentiation type for optimization. Defaults to <code>Optimization.AutoEnzyme()</code>.</li><li><code>grad::ADJ</code>: The adjoint gradient computation method. Defaults to <code>SciMLSensitivityAdjoint()</code>.</li><li><code>optimization_method::String</code>: The optimization method to use. Must be either <code>&quot;AD+AD&quot;</code> or <code>&quot;AD+Diff&quot;</code>. Defaults to <code>&quot;AD+AD&quot;</code>.</li><li><code>loss_type::String</code>: The type of loss function to use. Must be either <code>&quot;V&quot;</code> (velocity) or <code>&quot;H&quot;</code> (thickness). Defaults to <code>&quot;V&quot;</code>.</li><li><code>empirical_loss_function::AbstractLoss</code>: The loss function to use for optimization. Defaults to <code>L2Sum()</code>.</li><li><code>scale_loss::Bool</code>: Whether to scale the loss function. Defaults to <code>true</code>.</li><li><code>target::Union{Symbol, Nothing}</code>: The target variable for optimization. Defaults to <code>:A</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UDEparameters</code> object configured with the specified sensitivity, optimization, and loss settings.</li></ul><p><strong>Description</strong></p><p>This function creates a <code>UDEparameters</code> object that encapsulates the configuration for sensitivity analysis, optimization, and loss computation in a Universal Differential Equation (UDE) framework. It verifies that the provided <code>optimization_method</code> and <code>loss_type</code> are valid and constructs the solver parameters accordingly.</p><p><strong>Notes</strong></p><ul><li>The <code>optimization_method</code> must be either <code>&quot;AD+AD&quot;</code> (automatic differentiation for both forward and backward passes) or <code>&quot;AD+Diff&quot;</code> (automatic differentiation combined with finite differences).</li><li>The <code>loss_type</code> must be either <code>&quot;V&quot;</code> (velocity-based loss) or <code>&quot;H&quot;</code> (thickness-based loss).</li><li>The <code>empirical_loss_function</code> determines how the loss is computed during optimization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/parameters/UDEparameters.jl#L33-L58">source</a></section></article><h2 id="Glaciers"><a class="docs-heading-anchor" href="#Glaciers">Glaciers</a><a id="Glaciers-1"></a><a class="docs-heading-anchor-permalink" href="#Glaciers" title="Permalink"></a></h2><p>Glaciers in <code>ODINN.jl</code> are represented by a <code>Glacier</code> type. Each glacier has its related <code>Climate</code> type. Since <code>ODINN.jl</code> supports different types of simulations, we offer the possibility to work on 1D (i.e. flowline), 2D (e.g. SIA) or even 3D (not yet implemented, e.g. Full Stokes).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Glacier2D" href="#Sleipnir.Glacier2D"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct representing a 2D glacier. Notice that all fields can be empty by providing <code>nothing</code> as the default value.</p><p>/!\ WARNING /!\ <code>Glacier</code> objects should not be constructed manually, but rather through the <code>initialize_glaciers</code> function.</p><p><code>Glacier2D{F &lt;: AbstractFloat, I &lt;: Integer}</code></p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) identifier for the glacier.</li><li><code>name::String</code>: The name of the glacier if available.</li><li><code>climate::Union{Climate2D, Nothing}</code>: The climate data associated with the glacier.</li><li><code>H₀::Union{Matrix{F}, Nothing}</code>: Initial ice thickness matrix.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness matrix from the GLATHIDA dataset.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix.</li><li><code>B::Matrix{F}</code>: Bedrock elevation matrix.</li><li><code>V::Union{Matrix{F}, Nothing}</code>: Ice velocity magnitude matrix.</li><li><code>Vx::Union{Matrix{F}, Nothing}</code>: Ice velocity in the x-direction matrix.</li><li><code>Vy::Union{Matrix{F}, Nothing}</code>: Ice velocity in the y-direction matrix.</li><li><code>A::Union{F, Nothing}</code>: Flow law parameter.</li><li><code>C::Union{F, Nothing}</code>: Sliding law parameter.</li><li><code>n::Union{F, Nothing}</code>: Flow law exponent.</li><li><code>slope::Union{Matrix{F}, Nothing}</code>: Surface slope matrix.</li><li><code>dist_border::Union{Matrix{F}, Nothing}</code>: Distance to the glacier border matrix.</li><li><code>Coords::Union{Dict{String, Vector{Float64}}, Nothing}</code>: Coordinates dictionary with keys as coordinate names and values as vectors of coordinates.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>cenlon::Union{F, Nothing}</code>: Longitude of the glacier center.</li><li><code>cenlat::Union{F, Nothing}</code>: Latitude of the glacier center.</li><li><code>params_projection::Dict{String, Float64}</code>: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.</li><li><code>thicknessData::Union{ThicknessData, Nothing}</code>: Thickness data structure that is used to store the reference values.</li><li><code>velocityData::Union{SurfaceVelocityData, Nothing}</code>: Surface velocity data structure that is used to store the reference values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/glaciers/glacier/Glacier2D.jl#L13-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Glacier2D-Tuple{}" href="#Sleipnir.Glacier2D-Tuple{}"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructs a <code>Glacier2D</code> object with the given parameters, including default ones.</p><pre><code class="nohighlight hljs">Glacier2D(;
    rgi_id::Union{String, Nothing} = nothing,
    name::String = &quot;&quot;,
    climate::Union{Climate2D, Nothing} = nothing,
    H₀::Union{Matrix{F}, Nothing} = nothing,
    H_glathida::Union{Matrix{F}, Nothing} = nothing,
    S::Union{Matrix{F}, Nothing} = nothing,
    B::Union{Matrix{F}, Nothing} = nothing,
    V::Union{Matrix{F}, Nothing} = nothing,
    Vx::Union{Matrix{F}, Nothing} = nothing,
    Vy::Union{Matrix{F}, Nothing} = nothing,
    A::Union{F, Nothing} = nothing,
    C::Union{F, Nothing} = nothing,
    n::Union{F, Nothing} = nothing,
    slope::Union{Matrix{F}, Nothing} = nothing,
    dist_border::Union{Matrix{F}, Nothing} = nothing,
    Coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,
    Δx::Union{F, Nothing} = nothing,
    Δy::Union{F, Nothing} = nothing,
    nx::Union{I, Nothing} = nothing,
    ny::Union{I, Nothing} = nothing,
    cenlon::Union{F, Nothing} = nothing,
    cenlat::Union{F, Nothing} = nothing,
    params_projection::Dict{String, Float64} = Dict{String, Float64}(),
    thicknessData::Union{ThicknessData, Nothing} = nothing,
    velocityData::Union{SurfaceVelocityData, Nothing} = nothing,
) where {F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI identifier for the glacier.</li><li><code>name::String</code>: The name of the glacier if available.</li><li><code>climate::Union{Climate2D, Nothing}</code>: The climate data associated with the glacier.</li><li><code>H₀::Union{Matrix{F}, Nothing}</code>: Initial ice thickness matrix.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness matrix from GLATHIDA.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix.</li><li><code>B::Matrix{F}</code>: Bed elevation matrix.</li><li><code>V::Union{Matrix{F}, Nothing}</code>: Ice velocity magnitude matrix.</li><li><code>Vx::Union{Matrix{F}, Nothing}</code>: Ice velocity in the x-direction matrix.</li><li><code>Vy::Union{Matrix{F}, Nothing}</code>: Ice velocity in the y-direction matrix.</li><li><code>A::Union{F, Nothing}</code>: Flow law parameter.</li><li><code>C::Union{F, Nothing}</code>: Sliding law parameter.</li><li><code>n::Union{F, Nothing}</code>: Flow law exponent.</li><li><code>slope::Union{Matrix{F}, Nothing}</code>: Slope matrix.</li><li><code>dist_border::Union{Matrix{F}, Nothing}</code>: Distance to border matrix.</li><li><code>Coords::Union{Dict{String, Vector{Float64}}, Nothing}</code>: Coordinates dictionary with keys &quot;lon&quot; and &quot;lat&quot;.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>cenlon::Union{F, Nothing}</code>: Central longitude of the glacier.</li><li><code>cenlat::Union{F, Nothing}</code>: Central latitude of the glacier.</li><li><code>params_projection::Dict{String, Float64}</code>: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.</li><li><code>thicknessData::Union{ThicknessData, Nothing}</code>: Thickness data structure that is used to store the reference values.</li><li><code>velocityData::Union{SurfaceVelocityData, Nothing}</code>: Surface velocity data structure that is used to store the reference values.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Glacier2D</code> object with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/glaciers/glacier/Glacier2D.jl#L77-L137">source</a></section></article><p>Every glacier has its associated climate, following the same spatial representation (e.g. 2D):</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Climate2D" href="#Sleipnir.Climate2D"><code>Sleipnir.Climate2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct representing a 2D climate for a glacier with various buffers and datasets.</p><pre><code class="nohighlight hljs">Climate2D{F &lt;: AbstractFloat}</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>raw_climate::RasterStack</code>: Raw climate dataset for the whole simulation.</li><li><code>climate_raw_step::RasterStack</code>: Raw climate trimmed for the current step to avoid memory allocations.</li><li><code>climate_step::Dict</code>: Climate data for the current step.</li><li><code>climate_2D_step::Climate2Dstep</code>: 2D climate data for the current step to feed to the mass balance (MB) model.</li><li><code>longterm_temps::Vector{F}</code>: Long-term temperatures for the ice rheology.</li><li><code>avg_temps::F</code>: Intermediate buffer for computing average temperatures.</li><li><code>avg_gradients::F</code>: Intermediate buffer for computing average gradients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/glaciers/climate/Climate2D.jl#L37-L50">source</a></section></article><p>In order to create <code>Glacier</code> types with information of a given glacier for a simulation, one can initialize a list of glaciers based on RGI (Randolph Glacier Inventory) IDs. Before running this, make sure to have used <code>Gungnir</code> to download all the necessary data for those glaciers, or double check that these glaciers are already available on the ODINN server. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.initialize_glaciers" href="#Sleipnir.initialize_glaciers"><code>Sleipnir.initialize_glaciers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_glaciers(
    rgi_ids::Vector{String},
    params::Parameters;
    velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}=Dict(),
)</code></pre><p>Initialize glaciers based on provided RGI IDs and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_ids::Vector{String}</code>: A vector of RGI IDs representing the glaciers to be initialized.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li><li><code>test::Bool</code>: An optional boolean flag indicating whether to run in test mode. Default is <code>false</code>.</li><li><code>velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}</code>: A dictionary that provides for each RGI ID either the path to the datacube or the <code>RasterStack</code> with velocity data.</li></ul><p><strong>Returns</strong></p><ul><li><code>glaciers::Vector{Glacier2D}</code>: A vector of initialized <code>Glacier2D</code> objects.</li></ul><p><strong>Description</strong></p><p>This function performs the following steps:</p><ol><li>Generates a file for missing glaciers if it does not already exist.</li><li>Filters out missing glaciers from the provided RGI IDs.</li><li>Generates raw climate data for the glaciers if necessary.</li><li>Initializes the glaciers using the provided RGI IDs and parameters.</li><li>If <code>use_glathida_data</code> is enabled in the simulation parameters, assigns GlaThiDa data to the glaciers.</li></ol><p><strong>Errors</strong></p><ul><li>Throws an error if none of the provided RGI IDs have GlaThiDa data.</li></ul><p><strong>Warnings</strong></p><ul><li>Issues a warning if not all glaciers have GlaThiDa data available.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># We declare a list of glaciers to be initialized with their RGI IDs
rgi_ids = [&quot;RGI60-11.03638&quot;, &quot;RGI60-11.01450&quot;, &quot;RGI60-11.02346&quot;, &quot;RGI60-08.00203&quot;]
# We initialize those glaciers based on the RGI IDs and the parameters we previously specified
glaciers = initialize_glaciers(rgi_ids, params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/glaciers/glacier/glacier2D_utils.jl#L8-L47">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><p>There are 3 main types of models in <code>ODINN.jl</code>, iceflow models, mass balance models and machine learning models. These three families are determined by abstract types, with specific types being declared as subtypes of these abstract types to ensure compatibility through the ODINN ecosystem. </p><p>The three main types of models are gathered in a type <code>Model</code> in the following way:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Model" href="#ODINN.Model"><code>ODINN.Model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Model(; iceflow::Union{IFM, Vector{IFM}, Nothing}, mass_balance::Union{MBM, Vector{MBM}, Nothing}, machine_learning::Union{MLM, Nothing}) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel, MLM &lt;: MLmodel}</code></pre><p>Creates a new model instance using the provided iceflow, mass balance, and machine learning components.</p><p><strong>Arguments</strong></p><ul><li><code>iceflow::Union{IFM, Vector{IFM}, Nothing}</code>: The iceflow model(s) to be used. Can be a single model, a vector of models, or <code>nothing</code>.</li><li><code>mass_balance::Union{MBM, Vector{MBM}, Nothing}</code>: The mass balance model(s) to be used. Can be a single model, a vector of models, or <code>nothing</code>.</li><li><code>machine_learning::Union{MLM, Nothing}</code>: The machine learning model to be used. Can be a single model or <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>model</code>: A new instance of <code>Sleipnir.Model</code> initialized with the provided components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/models/machine_learning/MLmodel.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Model-Tuple{}" href="#ODINN.Model-Tuple{}"><code>ODINN.Model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Model(; iceflow::Union{IFM, Vector{IFM}, Nothing}, mass_balance::Union{MBM, Vector{MBM}, Nothing}, machine_learning::Union{MLM, Nothing}) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel, MLM &lt;: MLmodel}</code></pre><p>Creates a new model instance using the provided iceflow, mass balance, and machine learning components.</p><p><strong>Arguments</strong></p><ul><li><code>iceflow::Union{IFM, Vector{IFM}, Nothing}</code>: The iceflow model(s) to be used. Can be a single model, a vector of models, or <code>nothing</code>.</li><li><code>mass_balance::Union{MBM, Vector{MBM}, Nothing}</code>: The mass balance model(s) to be used. Can be a single model, a vector of models, or <code>nothing</code>.</li><li><code>machine_learning::Union{MLM, Nothing}</code>: The machine learning model to be used. Can be a single model or <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>model</code>: A new instance of <code>Sleipnir.Model</code> initialized with the provided components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/models/machine_learning/MLmodel.jl#L7-L18">source</a></section></article><h3 id="Ice-flow-models"><a class="docs-heading-anchor" href="#Ice-flow-models">Ice flow models</a><a id="Ice-flow-models-1"></a><a class="docs-heading-anchor-permalink" href="#Ice-flow-models" title="Permalink"></a></h3><p>Ice flow models are used to solve the PDEs describing the gravitational flow of glaciers. All ice flow models must be a subtype of abstract type <code>IceflowModel</code>. Ice flow models are managed by <code>Huginn.jl</code>. </p><p>The main type of ice flow model used in <code>ODINN.jl</code> right now is a 2D Shallow Ice Approximation (SIA) model <em>(Hutter, 1983)</em>. This is declared in the following way:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2Dmodel" href="#Huginn.SIA2Dmodel"><code>Huginn.SIA2Dmodel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct SIA2Dmodel{R &lt;: Real, I &lt;: Integer} &lt;: SIAmodel</code></pre><p>A mutable struct representing a 2D Shallow Ice Approximation (SIA) model.</p><p><strong>Fields</strong></p><ul><li><code>A::Union{Ref{R}, Nothing}</code>: Flow rate factor.</li><li><code>n::Union{Ref{R}, Nothing}</code>: Flow law exponent.</li><li><code>C::Union{Ref{R}, Matrix{R}, Nothing}</code>: Sliding coefficient.</li><li><code>H₀::Matrix{R}</code>: Initial ice thickness.</li><li><code>H::Union{Matrix{R}, Nothing}</code>: Ice thickness.</li><li><code>H̄::Union{Matrix{R}, Nothing}</code>: Averaged ice thickness.</li><li><code>S::Matrix{R}</code>: Surface elevation.</li><li><code>dSdx::Union{Matrix{R}, Nothing}</code>: Surface slope in the x-direction.</li><li><code>dSdy::Union{Matrix{R}, Nothing}</code>: Surface slope in the y-direction.</li><li><code>D::Union{Matrix{R}, Nothing}</code>: Diffusivity.</li><li><code>D_is_provided::Union{Bool, Nothing}</code>: Specifies if D is provided by user or computed.</li><li><code>Dx::Union{Matrix{R}, Nothing}</code>: Diffusivity in the x-direction.</li><li><code>Dy::Union{Matrix{R}, Nothing}</code>: Diffusivity in the y-direction.</li><li><code>dSdx_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in the x-direction.</li><li><code>dSdy_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in the y-direction.</li><li><code>∇S::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation.</li><li><code>∇Sy::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation in the y-direction.</li><li><code>∇Sx::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation in the x-direction.</li><li><code>Fx::Union{Matrix{R}, Nothing}</code>: Flux in the x-direction.</li><li><code>Fy::Union{Matrix{R}, Nothing}</code>: Flux in the y-direction.</li><li><code>Fxx::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in the x-direction.</li><li><code>Fyy::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in the y-direction.</li><li><code>V::Union{Matrix{R}, Nothing}</code>: Velocity.</li><li><code>Vx::Union{Matrix{R}, Nothing}</code>: Velocity in the x-direction.</li><li><code>Vy::Union{Matrix{R}, Nothing}</code>: Velocity in the y-direction.</li><li><code>Γ::Union{Ref{R}, Nothing}</code>: Basal shear stress.</li><li><code>MB::Union{Matrix{R}, Nothing}</code>: Mass balance.</li><li><code>MB_mask::Union{AbstractArray{Bool}, Nothing}</code>: Mask for mass balance.</li><li><code>MB_total::Union{Matrix{R}, Nothing}</code>: Total mass balance.</li><li><code>glacier_idx::Union{Ref{I}, Nothing}</code>: Index of the glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/models/iceflow/SIA2D/SIA2D.jl#L10-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2Dmodel-Tuple{Sleipnir.Parameters}" href="#Huginn.SIA2Dmodel-Tuple{Sleipnir.Parameters}"><code>Huginn.SIA2Dmodel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIA2Dmodel(
    params::Sleipnir.Parameters;
    A::Union{R, Nothing} = nothing,
    n::Union{R, Nothing} = nothing,
    C::Union{R, Matrix{R}, Nothing} = nothing,
    H₀::Matrix{R} = Matrix{Sleipnir.Float}([;;]),
    H::Union{Matrix{R}, Nothing} = nothing,
    H̄::Union{Matrix{R}, Nothing} = nothing,
    S::Matrix{R} = Matrix{Sleipnir.Float}([;;]),
    dSdx::Union{Matrix{R}, Nothing} = nothing,
    dSdy::Union{Matrix{R}, Nothing} = nothing,
    D::Union{Matrix{R}, Nothing} = nothing,
    D_is_provided::Union{Bool, Nothing} = nothing,
    Dx::Union{Matrix{R}, Nothing} = nothing,
    Dy::Union{Matrix{R}, Nothing} = nothing,
    dSdx_edges::Union{Matrix{R}, Nothing} = nothing,
    dSdy_edges::Union{Matrix{R}, Nothing} = nothing,
    ∇S::Union{Matrix{R}, Nothing} = nothing,
    ∇Sy::Union{Matrix{R}, Nothing} = nothing,
    ∇Sx::Union{Matrix{R}, Nothing} = nothing,
    Fx::Union{Matrix{R}, Nothing} = nothing,
    Fy::Union{Matrix{R}, Nothing} = nothing,
    Fxx::Union{Matrix{R}, Nothing} = nothing,
    Fyy::Union{Matrix{R}, Nothing} = nothing,
    V::Union{Matrix{R}, Nothing} = nothing,
    Vx::Union{Matrix{R}, Nothing} = nothing,
    Vy::Union{Matrix{R}, Nothing} = nothing,
    Γ::Union{R, Nothing} = nothing,
    MB::Union{Matrix{R}, Nothing} = nothing,
    MB_mask::Union{BitMatrix, Nothing} = nothing,
    MB_total::Union{Matrix{R}, Nothing} = nothing,
    glacier_idx::Union{I, Nothing} = nothing
) where {I &lt;: Integer, R &lt;: Real}</code></pre><p>Constructs a new <code>SIA2Dmodel</code> object with the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: Simulation parameters.</li><li><code>A::Union{R, Nothing}</code>: Flow law parameter (default: <code>nothing</code>).</li><li><code>n::Union{R, Nothing}</code>: Flow law exponent (default: <code>nothing</code>).</li><li><code>C::Union{R, Matrix{R}, Nothing}</code>: Basal sliding parameter (default: <code>nothing</code>).</li><li><code>H₀::Matrix{R}</code>: Initial ice thickness (default: empty matrix).</li><li><code>H::Union{Matrix{R}, Nothing}</code>: Ice thickness (default: <code>nothing</code>).</li><li><code>H̄::Union{Matrix{R}, Nothing}</code>: Averaged ice thickness (default: <code>nothing</code>).</li><li><code>S::Matrix{R}</code>: Surface elevation (default: empty matrix).</li><li><code>dSdx::Union{Matrix{R}, Nothing}</code>: Surface slope in x-direction (default: <code>nothing</code>).</li><li><code>dSdy::Union{Matrix{R}, Nothing}</code>: Surface slope in y-direction (default: <code>nothing</code>).</li><li><code>D::Union{Matrix{R}, Nothing}</code>: Diffusivity (default: <code>nothing</code>).</li><li><code>D_is_provided::Union{Bool, Nothing}</code>: Specifies if D is provided by user or computed (default: <code>false</code>).</li><li><code>Dx::Union{Matrix{R}, Nothing}</code>: Diffusivity in x-direction (default: <code>nothing</code>).</li><li><code>Dy::Union{Matrix{R}, Nothing}</code>: Diffusivity in y-direction (default: <code>nothing</code>).</li><li><code>dSdx_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in x-direction (default: <code>nothing</code>).</li><li><code>dSdy_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in y-direction (default: <code>nothing</code>).</li><li><code>∇S::Union{Matrix{R}, Nothing}</code>: Gradient of surface elevation (default: <code>nothing</code>).</li><li><code>∇Sy::Union{Matrix{R}, Nothing}</code>: Gradient of surface elevation in y-direction (default: <code>nothing</code>).</li><li><code>∇Sx::Union{Matrix{R}, Nothing}</code>: Gradient of surface elevation in x-direction (default: <code>nothing</code>).</li><li><code>Fx::Union{Matrix{R}, Nothing}</code>: Flux in x-direction (default: <code>nothing</code>).</li><li><code>Fy::Union{Matrix{R}, Nothing}</code>: Flux in y-direction (default: <code>nothing</code>).</li><li><code>Fxx::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in x-direction (default: <code>nothing</code>).</li><li><code>Fyy::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in y-direction (default: <code>nothing</code>).</li><li><code>V::Union{Matrix{R}, Nothing}</code>: Velocity (default: <code>nothing</code>).</li><li><code>Vx::Union{Matrix{R}, Nothing}</code>: Velocity in x-direction (default: <code>nothing</code>).</li><li><code>Vy::Union{Matrix{R}, Nothing}</code>: Velocity in y-direction (default: <code>nothing</code>).</li><li><code>Γ::Union{R, Nothing}</code>: Auxiliary matrix (default: <code>nothing</code>).</li><li><code>MB::Union{Matrix{R}, Nothing}</code>: Mass balance (default: <code>nothing</code>).</li><li><code>MB_mask::Union{BitMatrix, Nothing}</code>: Mask for mass balance (default: <code>nothing</code>).</li><li><code>MB_total::Union{Matrix{R}, Nothing}</code>: Total mass balance (default: <code>nothing</code>).</li><li><code>glacier_idx::Union{I, Nothing}</code>: Index of the glacier (default: <code>nothing</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>SIA2Dmodel</code>: A new <code>SIA2Dmodel</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/models/iceflow/SIA2D/SIA2D.jl#L80-L152">source</a></section></article><p>When a simulation will be run in <code>ODINN.jl</code> using an ice flow model, its related equation will be solved using <code>OrdinaryDiffEq.jl</code>. The related equation to a <code>SIA2Dmodel</code> is declared in its related util functions. Generally, these equations need to exist both in-place (to reduce memory allocations and ensure maximum performance, see example below) or out-of-place (to be more AD-friendly).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2D!" href="#Huginn.SIA2D!"><code>Huginn.SIA2D!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIA2D!(dH::Matrix{R}, H::Matrix{R}, simulation::SIM, t::R) where {R &lt;:Real, SIM &lt;: Simulation}</code></pre><p>Simulates the evolution of ice thickness in a 2D shallow ice approximation (SIA) model. Works in-place.</p><p><strong>Arguments</strong></p><ul><li><code>dH::Matrix{R}</code>: Matrix to store the rate of change of ice thickness.</li><li><code>H::Matrix{R}</code>: Matrix representing the ice thickness.</li><li><code>simulation::SIM</code>: Simulation object containing model parameters and state.</li><li><code>t::R</code>: Current simulation time.</li></ul><p><strong>Details</strong></p><p>This function updates the ice thickness <code>H</code> and computes the rate of change <code>dH</code> using the shallow ice approximation in 2D. It retrieves necessary parameters from the <code>simulation</code> object, enforces positive ice thickness values, updates glacier surface altimetry, computes surface gradients, flux components, and flux divergence.</p><p><strong>Notes</strong></p><ul><li>The function operates on a staggered grid for computing gradients and fluxes.</li><li>Surface elevation differences are capped using upstream ice thickness to impose boundary conditions.</li><li>The function modifies the input matrices <code>dH</code> and <code>H</code> in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/models/iceflow/SIA2D/SIA2D_utils.jl#L2-L20">source</a></section></article><h3 id="Mass-balance-models"><a class="docs-heading-anchor" href="#Mass-balance-models">Mass balance models</a><a id="Mass-balance-models-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-balance-models" title="Permalink"></a></h3><p>Mass balance models are used to simulate the simplified thermodynamics of the forcing of the atmosphere on glaciers. As per ice flow models, all specific mass balance models needs to be a subtype of the abstract type <code>MBmodel</code>. Mass balance models are managed by <code>Muninn.jl</code>. For now, we have simple temperature-index models, with either one or two degree-day factors (DDFs) <em>(Hock, 2003)</em>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel1" href="#Muninn.TImodel1"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel1{F &lt;: AbstractFloat}</code></pre><p>A structure representing a temperature index model with degree-day factor and accumulation factor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>DDF::F</code>: Degree-day factor, which is a coefficient used to convert temperature into melt.</li><li><code>acc_factor::F</code>: Accumulation factor, which is a coefficient used to adjust the accumulation of mass.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: A subtype of <code>AbstractFloat</code> representing the type of the factors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel1-Tuple{Sleipnir.Parameters}" href="#Muninn.TImodel1-Tuple{Sleipnir.Parameters}"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel1(params::Sleipnir.Parameters; DDF::F = 7.0/1000.0, acc_factor::F = 1.0/1000.0) where {F &lt;: AbstractFloat}</code></pre><p>Create a temperature index model with one degree-day factor (DDF) with the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: The simulation parameters.</li><li><code>DDF::F</code>: Degree-day factor (default is 7.0/1000.0).</li><li><code>acc_factor::F</code>: Accumulation factor (default is 1.0/1000.0).</li></ul><p><strong>Returns</strong></p><ul><li><code>TI1_model</code>: An instance of TImodel1 with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L44-L56">source</a></section></article><p>Surface mass balance models are run in <code>DiscreteCallback</code>s from <code>OrdinaryDiffEq.jl</code>, which enable the safe execution during the solving of a PDE in specificly prescribed time steps determined in the <code>steps</code>field in <a href="#Sleipnir.SimulationParameters"><code>Sleipnir.SimulationParameters</code></a>.</p><p>We soon plan to add compatibility with neural networks coming from the <a href="https://github.com/ODINN-SciML/MassBalanceMachine">MassBalanceMachine</a>, which should become the <em>de facto</em> surface mass balance model in the <code>ODINN.jl</code> ecosystem. </p><h3 id="Machine-Learning-models"><a class="docs-heading-anchor" href="#Machine-Learning-models">Machine Learning models</a><a id="Machine-Learning-models-1"></a><a class="docs-heading-anchor-permalink" href="#Machine-Learning-models" title="Permalink"></a></h3><p>Machine learning models are used in the context of Universal Differential Equations (UDEs, <em>Rackauckas et al., 2020</em>) to parametrize or learn specific parts of differential equations. Machine Learning models are manage by <code>ODINN.jl</code>. As per the other types of models, all machine learning models need to be a subtype of the abstract type <code>MLmodel</code>. The default solution here is to use a neural network:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.NeuralNetwork" href="#ODINN.NeuralNetwork"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NeuralNetwork{
    ChainType &lt;: Lux.Chain,
    ComponentVectorType &lt;: ComponentVector,
    NamedTupleType &lt;: NamedTuple
} &lt;: MLmodel</code></pre><p>Feed-forward neural network.</p><p><strong>Fields</strong></p><ul><li><code>architecture::ChainType</code>: <code>Flux.Chain</code> neural network architecture</li><li><code>θ::ComponentVectorType</code>: Neural network parameters</li><li><code>st::NamedTupleType</code>: Neural network status</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/models/machine_learning/MLmodel.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.NeuralNetwork-Tuple{Sleipnir.Parameters}" href="#ODINN.NeuralNetwork-Tuple{Sleipnir.Parameters}"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NN(params::Parameters;
    architecture::Union{Flux.Chain, Nothing} = nothing,
    θ::Union{Vector{AbstractFloat}, Nothing} = nothing)</code></pre><p>Creates a new feed-forward neural network.</p><p><strong>Keyword arguments</strong></p><ul><li><code>architecture</code>: <code>Flux.Chain</code> neural network architecture (optional)</li><li><code>θ</code>: Neural network parameters (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/models/machine_learning/MLmodel.jl#L58-L68">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><p>One can run different types of simulations in <code>ODINN.jl</code>. Any specific type of simulation must be a subtype of <code>Simulation</code>. All simulations share the same common interface designed around multiple dispatch. Basically, once a simulation type has been created, one can easily run by calling <code>run!(simulation)</code>.</p><p>The main types of simulations are the following ones:</p><h3 id="Prediction"><a class="docs-heading-anchor" href="#Prediction">Prediction</a><a id="Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction" title="Permalink"></a></h3><p>A prediction, also known as a forward simulation, is just a forward simulation given a model configuration, based on parameters, glaciers and models. These are managed in <code>Huginn.jl</code>, since they do not involve any inverse methods nor parameter optimization.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.Prediction" href="#Huginn.Prediction"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prediction &lt;: Simulation</code></pre><p>A mutable struct that represents a prediction simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the prediction.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the prediction.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the prediction.</li><li><code>results::Vector{Results}</code>: A vector of results obtained from the prediction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/simulations/predictions/Prediction.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Create a <code>Prediction</code> object using the given model, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for prediction.</li><li><code>glaciers::Vector{G}</code>: A vector of glacier objects, where each glacier is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the prediction.</li></ul><p><strong>Returns</strong></p><ul><li><code>Prediction</code>: A <code>Prediction</code> object based on the input values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.6/src/simulations/predictions/Prediction.jl#L23-L35">source</a></section></article><h3 id="Inversion"><a class="docs-heading-anchor" href="#Inversion">Inversion</a><a id="Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion" title="Permalink"></a></h3><p>An inversion optimises a given set of model parameters, based on a given target and an optimizer. These are handled by <code>ODINN.jl</code>. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Inversion" href="#ODINN.Inversion"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Inversion &lt;: Simulation</code></pre><p>A mutable struct that represents an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the inversion.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the inversion.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the inversion.</li><li><code>inversion::Vector{InversionResults}</code>: A vector of results from the inversion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/simulations/inversions/Inversion.jl#L62-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Inversion(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Create an <code>Inversion</code> object using the provided model, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model to be used for the inversion.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers, where each glacier is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters to be used for the inversion.</li></ul><p><strong>Returns</strong></p><ul><li><code>inversion</code>: An <code>Inversion</code> object initialized with the provided model, glaciers, and parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/simulations/inversions/Inversion.jl#L81-L93">source</a></section></article><h3 id="Functional-inversion"><a class="docs-heading-anchor" href="#Functional-inversion">Functional inversion</a><a id="Functional-inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-inversion" title="Permalink"></a></h3><p>A functional inversion is the inversion of the parameters of a regressor (e.g. a neural network), which parametrize a function that modulates a parameter or set of parameters in a given mechanistic model (e.g. the SIA).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.FunctionalInversion" href="#ODINN.FunctionalInversion"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct FunctionalInversion &lt;: Simulation</code></pre><p>An object representing a functional inversion simulation (i.e. the inversion of a function using some data-driven regressor).</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li><li><code>results::Vector{Results}</code>: A vector to store the results of the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/simulations/functional_inversions/FunctionalInversion.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.FunctionalInversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#ODINN.FunctionalInversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function FunctionalInversion(
    model::Sleipnir.Model,
    glaciers::Vector{G},
    parameters::Sleipnir.Parameters
) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Constructor for FunctionalInversion struct with glacier model information, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>FunctionalInversion</code>: A new instance of the FunctionalInversion struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/875403033e9186d521abf7f229ffa04b049fa510/src/simulations/functional_inversions/FunctionalInversion.jl#L23-L39">source</a></section></article><h2 id="Results-and-plotting"><a class="docs-heading-anchor" href="#Results-and-plotting">Results and plotting</a><a id="Results-and-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Results-and-plotting" title="Permalink"></a></h2><p>Every <code>Simulation</code> type has an associated <code>Results</code> object(s), one for each one of the glaciers in the simulation. This object, as its name indicates, stores all the results of the simulation, which can be used for data anlysis and plotting. These types are handled by <code>Sleipnir.jl</code>. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Results" href="#Sleipnir.Results"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Results{F &lt;: AbstractFloat, I &lt;: Int}</code></pre><p>A mutable struct to store the results of simulations.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: Identifier for the RGI (Randolph Glacier Inventory).</li><li><code>H::Vector{Matrix{F}}</code>: Vector of matrices representing glacier ice thickness <code>H</code> over time.</li><li><code>H_glathida::Matrix{F}</code>: Optional matrix for Glathida ice thicknesses.</li><li><code>H_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference data for ice thickness.</li><li><code>S::Matrix{F}</code>: Glacier surface altimetry.</li><li><code>B::Matrix{F}</code>: Glacier bedrock.</li><li><code>V::Matrix{F}</code>: Glacier ice surface velocities.</li><li><code>Vx::Matrix{F}</code>: x-component of the glacier ice surface velocity <code>V</code>.</li><li><code>Vy::Matrix{F}</code>: y-component of the glacier ice surface velocity <code>V</code>.</li><li><code>V_ref::Union{Nothing, Matrix{F}}</code>: Reference data for glacier ice surface velocities <code>V</code>.</li><li><code>Vx_ref::Union{Nothing, Matrix{F}}</code>: Reference data for the x-component of the glacier ice surface velocity <code>Vx</code>.</li><li><code>Vy_ref::Union{Nothing, Matrix{F}}</code>: Reference data for the y-component of the glacier ice surface velocity <code>Vy</code>.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::Union{Nothing, F}</code>: Optional longitude value.</li><li><code>lat::Union{Nothing, F}</code>: Optional latitude value.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>tspan::Vector{F}</code>: Time span of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Machine learning model parameters.</li><li><code>loss::Union{Nothing, Vector{F}}</code> Vector with evolution of loss function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/simulations/results/Results.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Int64}" href="#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Int64}"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Results(glacier::G, ifm::IF;
    rgi_id::String = glacier.rgi_id,
    H::Union{Nothing, Vector{Matrix{F}}} = nothing,
    H_glathida::Matrix{F} = glacier.H_glathida,
    H_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    S::Union{Nothing, Matrix{F}} = nothing,
    B::Union{Nothing, Matrix{F}} = nothing,
    V::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vx::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vy::Union{Nothing, Vector{Matrix{F}}} = nothing,
    V_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vx_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vy_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Δx::F = glacier.Δx,
    Δy::F = glacier.Δy,
    lon::Union{Nothing, F} = glacier.cenlon,
    lat::Union{Nothing, F} = glacier.cenlat,
    nx::I = glacier.nx,
    ny::I = glacier.ny,
    t::Union{Vector{F}, Nothing} = nothing,
    tspan::Union{Tuple{F, F}, Nothing} = nothing,
    θ::Union{Nothing,ComponentArray{F}} = nothing,
    loss::Union{Nothing,Vector{F}} = nothing
) where {G &lt;: AbstractGlacier, F &lt;: AbstractFloat, IF &lt;: AbstractModel, I &lt;: Int}</code></pre><p>Construct a <code>Results</code> object for a glacier simulation.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::G</code>: The glacier object, subtype of <code>AbstractGlacier</code>.</li><li><code>ifm::IF</code>: The model object, subtype of <code>AbstractModel</code>.</li><li><code>rgi_id::String</code>: The RGI identifier for the glacier. Defaults to <code>glacier.rgi_id</code>.</li><li><code>H::Union{Nothing, Vector{Matrix{F}}}</code>: Ice thickness matrices. Defaults to nothing.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness from GlaThiDa. Defaults to <code>glacier.H_glathida</code>.</li><li><code>H_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference ice thickness. Defaults to nothing.</li><li><code>S::Union{Nothing, Matrix{F}}</code>: Surface elevation matrix. Defaults to a zero matrix of the same size as <code>ifm.S</code>.</li><li><code>B::Union{Nothing, Matrix{F}}</code>: Bed elevation matrix. Defaults to a zero matrix of the same size as <code>glacier.B</code>.</li><li><code>V::Union{Nothing, Vector{Matrix{F}}}</code>: Velocity magnitude matrix. Defaults to nothing.</li><li><code>Vx::Union{Nothing, Vector{Matrix{F}}}</code>: Velocity in the x-direction matrix. Defaults to nothing.</li><li><code>Vy::Union{Nothing, Vector{Matrix{F}}}</code>: Velocity in the y-direction matrix. Defaults to nothing.</li><li><code>V_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference velocity magnitude matrix. Defaults to nothing.</li><li><code>Vx_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference velocity in the x-direction matrix. Defaults to nothing.</li><li><code>Vy_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference velocity in the y-direction matrix. Defaults to nothing.</li><li><code>Δx::F</code>: Grid spacing in the x-direction. Defaults to <code>glacier.Δx</code>.</li><li><code>Δy::F</code>: Grid spacing in the y-direction. Defaults to <code>glacier.Δy</code>.</li><li><code>lon::Union{Nothing, F}</code>: Longitude of the glacier center. Defaults to <code>glacier.cenlon</code>.</li><li><code>lat::Union{Nothing, F}</code>: Latitude of the glacier center. Defaults to <code>glacier.cenlat</code>.</li><li><code>nx::I</code>: Number of grid points in the x-direction. Defaults to <code>glacier.nx</code>.</li><li><code>ny::I</code>: Number of grid points in the y-direction. Defaults to <code>glacier.ny</code>.</li><li><code>tspan::Tuple(F, F)</code>: Timespan of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Model parameters. Defaults to <code>nothing</code>.</li><li><code>loss::Union{Nothing, Vector{F}}</code>: Loss values. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Results</code>: A <code>Results</code> object containing the simulation results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/simulations/results/Results.jl#L64-L119">source</a></section></article><p>One of the main things one can do with a <code>Results</code> object, is plotting them. The main function to do so is the following one:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier" href="#Sleipnir.plot_glacier"><code>Sleipnir.plot_glacier</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -&gt; Figure</code></pre><p>Generate various types of plots for glacier data.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>plot_type::String</code>: Type of plot to generate. Options are:<ul><li>&quot;heatmaps&quot;: Heatmaps for glacier variables like <code>:H</code>, <code>:H₀</code>, <code>:S</code>, <code>:B</code>, <code>:V</code>, <code>:Vx</code>, <code>:Vy</code>, <code>:V_ref</code>.</li><li>&quot;evolution difference&quot;: Temporal difference metrics (between start and end) for a variable, with optional metrics like &quot;hist&quot; (histogram) and &quot;difference&quot;.</li><li>&quot;evolution statistics&quot;: Temporal statistical metrics for a variable, with optional metrics like &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;.</li><li>&quot;integrated volume&quot;: Temporal evolution of the integrated ice volume for a variable.</li><li>&quot;bias&quot;: Scatter plot to visualize the bias between two variables.</li></ul></li><li><code>variables::Vector{Symbol}</code>: Variables to be plotted, e.g., <code>:H</code>.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics</code>: Metrics to visualize, e.g., <code>[&quot;average&quot;]</code> for statistics, <code>[&quot;difference&quot;]</code> for difference.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size for heatmaps.</li><li><code>threshold::Vector{F}</code>: Threshold values for filtering data in bias plots.</li><li><code>figsize::Tuple{Int64, Int64}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Figure</code> object containing the desired visualization.</li></ul><p><strong>Notes</strong></p><ul><li>Ensure the <code>variables</code> and <code>kwargs</code> match the requirements of the specified <code>plot_type</code>.</li><li>The function routes requests to specific plotting functions based on <code>plot_type</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/simulations/results/results_plotting_utils.jl#L524-L552">source</a></section></article><p>Another option is to generate a video of the evolution of the glacier&#39;s ice thickness during the simulation:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier_vid" href="#Sleipnir.plot_glacier_vid"><code>Sleipnir.plot_glacier_vid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier_vid(
    plot_type::String,
    H::Vector{Matrix{Float64}},
    glacier::Glacier2D,
    simuparams::SimulationParameters,
    pathVideo::String;
    framerate::Int=24,
    baseTitle::String=&quot;&quot;
)</code></pre><p>Generate various types of videos for glacier data. For now only the evolution of the glacier ice thickness is supported. More types of visualizations will be added in the future. </p><p><strong>Arguments</strong></p><ul><li><code>plot_type</code>: Type of plot to generate. Options are:<ul><li>&quot;thickness&quot;: Heatmap of the glacier thickness.</li></ul></li><li><code>H</code>: A vector of matrices containing the ice thickness over time. This should be   replaced by a Results instance in the future once Results no longer depends on   an iceflow model.</li><li><code>glacier</code>: A glacier instance.</li><li><code>simuparams</code>: The simulation parameters.</li><li><code>pathVideo</code>: Path of the mp4 file to generate.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>framerate</code>: The framerate to use for the video generation.</li><li><code>baseTitle</code>: The prefix to use in the title of the frames. In each frame it is   concatenated with the value of the year in the form &quot; (t=XXXX)&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.5/src/simulations/results/results_plotting_video_utils.jl#L40-L67">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functional_inversion/">« Functional inversion</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 27 May 2025 09:30">Tuesday 27 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
