<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index of functions and types · ODINN.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ODINN-SciML.github.io/ODINN.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../funcs_types/">Index of functions and types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index of functions and types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index of functions and types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index-of-functions-and-types"><a class="docs-heading-anchor" href="#Index-of-functions-and-types">Index of functions and types</a><a id="Index-of-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Index-of-functions-and-types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ODINN.AbstractAdjointMethod" href="#ODINN.AbstractAdjointMethod"><code>ODINN.AbstractAdjointMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAdjointMethod</code></pre><p>Abstract type representing the flavor of AD and adjoint to be used to compute the gradient of the cost function. There are two parts where one can play with how the gradient is propagated: the iceflow model VJP and the adjoint of the ODE solver. The VJP of the iceflow model can be computed using either AD (Zygote or Enzyme), the discrete, or the continuous adjoint of the iceflow model. As for the computation of the adjoint of the ODE solution, it can be handled by SciMLSensitivity, or computed using the adjoint implemented in ODINN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.ContinuousAdjoint" href="#ODINN.ContinuousAdjoint"><code>ODINN.ContinuousAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Continuous adjoint of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><code>ContinuousAdjoint{F &lt;: AbstractFloat}</code></p><p><strong>Fields</strong></p><ul><li><code>reltol::F</code>: Relative tolerance to be used in the ODE solver of the adjoint.</li><li><code>abstol::F</code>: Absolute tolerance to be used in the ODE solver of the adjoint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.DiscreteAdjoint" href="#ODINN.DiscreteAdjoint"><code>ODINN.DiscreteAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete adjoint of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><code>DiscreteAdjoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.DummyAdjoint" href="#ODINN.DummyAdjoint"><code>ODINN.DummyAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to provide a dummy gradient. It does not have to be the true gradient. Mainly used to test that the optimization pileline works independenly of the gradient calculation.</p><p><code>DummyAdjoint</code></p><p><strong>Fields:</strong></p><ul><li><code>grad::Function</code>: In-place function <code>f(du, u; kwargs)</code> that fills the first   argument <code>du</code> with the gradient values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.EnzymeAdjoint" href="#ODINN.EnzymeAdjoint"><code>ODINN.EnzymeAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Enzyme AD of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><code>EnzymeAdjoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.FunctionalInversion" href="#ODINN.FunctionalInversion"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FunctionalInversion &lt;: Simulation</code></pre><p>An object representing a functional inversion simulation (i.e. the inversion of a function using some data-driven regressor).</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li><li><code>results::Vector{Results}</code>: A vector to store the results of the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/FunctionalInversion.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.FunctionalInversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G&lt;:AbstractGlacier, M&lt;:Sleipnir.Model, P&lt;:Sleipnir.Parameters}" href="#ODINN.FunctionalInversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G&lt;:AbstractGlacier, M&lt;:Sleipnir.Model, P&lt;:Sleipnir.Parameters}"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function FunctionalInversion(
    model::Sleipnir.Model,
    glaciers::Vector{G},
    parameters::Sleipnir.Parameters
) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Constructor for FunctionalInversion struct with glacier model information, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>FunctionalInversion</code>: A new instance of the FunctionalInversion struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/FunctionalInversion.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Hyperparameters-Tuple{}" href="#ODINN.Hyperparameters-Tuple{}"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hyperparameters(;
    current_epoch::Int64 = nothing,
    current_minibatch::Int64 = nothing,
    loss_history::Vector{Float64} = Vector{Float64}(),
    optimizer::Optim.FirstOrderOptimizer = BFGS(initial_stepnorm=0.001),
    epochs::Int64 = 50,
    batch_size::Int64 = 15
    )</code></pre><p>Initialize the hyperparameters of a machine learning model (<code>Machine</code>). Keyword arguments =================     - <code>current_epoch</code>: Current epoch in training     - <code>current_minibatch</code>: Current minibatch in training     - <code>loss_history</code>: <code>Vector</code> storing the loss for each epoch during training     - <code>optimizer</code>: Optimizer to be used for training. Currently supports both <code>Optim.jl</code> and <code>Flux.jl</code> optimisers.     - <code>epochs</code>: Number of epochs for the training     - <code>batch_size</code>: Batch size for the training</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/parameters/Hyperparameters.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Inversion" href="#ODINN.Inversion"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Inversion &lt;: Simulation</code></pre><p>A mutable struct that represents an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the inversion.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the inversion.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the inversion.</li><li><code>inversion::Vector{InversionResults}</code>: A vector of results from the inversion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/inversions/Inversion.jl#L62-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Inversion(
    model::Sleipnir.Model,
    glaciers::Vector{Sleipnir.AbstractGlacier},
    parameters::Sleipnir.Parameters
    )</code></pre><p>Construnctor for Inversion struct with glacier model infomation, glaciers and parameters. Keyword arguments =================</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/inversions/Inversion.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.InversionParameters" href="#ODINN.InversionParameters"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}</code></pre><p>A mutable struct that holds parameters for inversion processes. This struct is a subtype of <code>AbstractParameters</code>.</p><p><strong>Fields</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: A vector of initial conditions.</li><li><code>lower_bound::Vector{F}</code>: A vector specifying the lower bounds for the parameters.</li><li><code>upper_bound::Vector{F}</code>: A vector specifying the upper bounds for the parameters.</li><li><code>regions_split::Vector{Int}</code>: A vector indicating how the regions are split.</li><li><code>x_tol::F</code>: The tolerance for the solution&#39;s x-values.</li><li><code>f_tol::F</code>: The tolerance for the function values.</li><li><code>solver::Any</code>: The solver to be used for the inversion process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/parameters/InversionParameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat" href="#ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}(;
    initial_conditions::Vector{F} = [1.0],
    lower_bound::Vector{F} = [0.0],
    upper_bound::Vector{F} = [Inf],
    regions_split::Vector{Int} = [1, 1],
    x_tol::F = 1.0e-3,
    f_tol::F = 1.0e-3,
    solver = BFGS()
)</code></pre><p>Initialize the parameters for the inversion process.</p><p><strong>Arguments</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: Starting point for optimization.</li><li><code>lower_bound::Vector{F}</code>: Lower bounds for optimization variables.</li><li><code>upper_bound::Vector{F}</code>: Upper bounds for optimization variables.</li><li><code>regions_split::Vector{Int}</code>: Defines the amount of region split based on altitude and distance to border for the inversion process.</li><li><code>x_tol::F</code>: Tolerance for variables convergence.</li><li><code>f_tol::F</code>: Tolerance for function value convergence.</li><li><code>solver</code>: Optimization solver to be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/parameters/InversionParameters.jl#L27-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.InversionResults" href="#ODINN.InversionResults"><code>ODINN.InversionResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct InversionResults{F &lt;: Real}</code></pre><p>A structure to store the results of an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::Union{String, Nothing}</code>: The RGI identifier, which can be a string or nothing.</li><li><code>A::F</code>: Area parameter.</li><li><code>n::F</code>: Exponent parameter.</li><li><code>C::Matrix{F}</code>: Coefficient matrix.</li><li><code>H_pred::Matrix{F}</code>: Predicted height matrix.</li><li><code>H_obs::Matrix{F}</code>: Observed height matrix.</li><li><code>H_diff::Matrix{F}</code>: Difference between predicted and observed height matrices.</li><li><code>V_pred::Matrix{F}</code>: Predicted volume matrix.</li><li><code>V_obs::Matrix{F}</code>: Observed volume matrix.</li><li><code>V_diff::Matrix{F}</code>: Difference between predicted and observed volume matrices.</li><li><code>MSE::F</code>: Mean squared error.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::F</code>: Longitude.</li><li><code>lat::F</code>: Latitude.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/inversions/Inversion.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.NeuralNetwork" href="#ODINN.NeuralNetwork"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NeuralNetwork{
    ChainType &lt;: Lux.Chain,
    ComponentVectorType &lt;: ComponentVector,
    NamedTupleType &lt;: NamedTuple
} &lt;: MLmodel</code></pre><p>Feed-forward neural network.</p><p><strong>Fields</strong></p><ul><li><code>architecture::ChainType</code>: <code>Flux.Chain</code> neural network architecture</li><li><code>θ::ComponentVectorType</code>: Neural network parameters</li><li><code>st::NamedTupleType</code>: Neural network status</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/MLmodel.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.NeuralNetwork-Union{Tuple{ComponentArrayType}, Tuple{ChainType}, Tuple{P}} where {P&lt;:Sleipnir.Parameters, ChainType&lt;:Lux.Chain, ComponentArrayType&lt;:ComponentArrays.ComponentArray}" href="#ODINN.NeuralNetwork-Union{Tuple{ComponentArrayType}, Tuple{ChainType}, Tuple{P}} where {P&lt;:Sleipnir.Parameters, ChainType&lt;:Lux.Chain, ComponentArrayType&lt;:ComponentArrays.ComponentArray}"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NN(params::Parameters;
    architecture::Union{Flux.Chain, Nothing} = nothing,
    θ::Union{Vector{AbstractFloat}, Nothing} = nothing)</code></pre><p>Creates a new feed-forward neural network.</p><p><strong>Keyword arguments</strong></p><ul><li><code>architecture</code>: <code>Flux.Chain</code> neural network architecture (optional)</li><li><code>θ</code>: Neural network parameters (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/MLmodel.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.SciMLSensitivityAdjoint" href="#ODINN.SciMLSensitivityAdjoint"><code>ODINN.SciMLSensitivityAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct that defines the SciMLSensitivity adjoint flavor. This is the default behavior in ODINN.</p><p><code>SciMLSensitivityAdjoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.TrainingStats" href="#ODINN.TrainingStats"><code>ODINN.TrainingStats</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TrainingStats</code></pre><p>An object with the information of the training. </p><p><strong>Fields</strong></p><ul><li><code>retcode</code>: Report code of the optimization.</li><li><code>losses</code>: Vector storing the value of the loss function at each iteration. </li><li><code>niter</code>: Total number of iterations/epochs.</li><li><code>θ</code>: Parameters of neural network after training</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/training_stats/TrainingStats.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Int64}" href="#ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Int64}"><code>ODINN.TrainingStats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function TrainingStats(;
    retcode::Union{String, Nothing} = nothing,
    losses::Vector{F} = Float64[],
    niter::I = 0
) where {F &lt;: AbstractFloat, I &lt;: Int}</code></pre><p>Constructor for TrainingStats object used to store important information during training. </p><p><strong>Arguments</strong></p><ul><li><code>retcode</code>: Report code of the optimization.</li><li><code>losses</code>: Vector storing the value of the loss function at each iteration. </li><li><code>niter</code>: Total number of iterations/epochs.</li><li><code>θ</code>: Parameters of neural network after training</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/training_stats/TrainingStats.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ&lt;:AbstractAdjointMethod" href="#ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ&lt;:AbstractAdjointMethod"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UDEparameters(;
    sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm = GaussAdjoint(autojacvec=EnzymeVJP()),
    optimization_method::String = &quot;AD+AD&quot;,
    loss_type::String = &quot;V&quot;,
    scale_loss::Bool = true
    target::Union{String, Nothing} = &quot;D&quot;
    )</code></pre><p>Initialize the parameters for the training of the UDE. Keyword arguments =================     - <code>sensealg</code>: Sensitivity algorithm from SciMLSensitivity.jl to be used.     - <code>optimization_method</code>: Optimization method for the UDE.     - <code>loss_type</code>: Type of loss function to be used. Can be either <code>V</code> (ice velocities), or <code>H</code> (ice thickness).     - <code>scale_loss</code>: Determines if the loss function should be scaled or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/parameters/UDEparameters.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.ZygoteAdjoint" href="#ODINN.ZygoteAdjoint"><code>ODINN.ZygoteAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Zygote AD of SIA2D with manual implementation of the backward in the ODE scheme. This flavor is not supported yet.</p><p><code>ZygoteAdjoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/AdjointTypes.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.A_law_PatersonCuffey-Tuple{}" href="#ODINN.A_law_PatersonCuffey-Tuple{}"><code>ODINN.A_law_PatersonCuffey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A_law_PatersonCuffey()</code></pre><p>Returns a law of the coefficient A as a polynomial of the temperature. The values used to fit the polynomial come from Peterson &amp; Cuffey.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.CallbackOptimizationSet-Tuple{Any, Any}" href="#ODINN.CallbackOptimizationSet-Tuple{Any, Any}"><code>ODINN.CallbackOptimizationSet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CallbackOptimizationSet(θ, l; callbacks)</code></pre><p>Helper to combine callbacks for Optimization function. This executes the action of each callback.   (equivalent to CallbackSet for DifferentialEquations.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/callback_utils.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, MLM&lt;:ODINN.MLmodel}" href="#ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, MLM&lt;:ODINN.MLmodel}"><code>ODINN.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Model(;     iceflow::Union{IFM, Nothing},     mass<em>balance::Union{MBM, Nothing}     machine</em>learning::Union{MLM, Nothing},     ) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel, MLM &lt;: MLmodel}</p><p>Initialize Model at ODINN level (iceflow + mass balance + machine learning).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/MLmodel.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Parameters-Tuple{}" href="#ODINN.Parameters-Tuple{}"><code>ODINN.Parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters(),         solver::SolverParameters = SolverParameters(),         hyper::Hyperparameters = Hyperparameters(),         UDE::UDEparameters = UDEparameters()         inversion::InversionParameters = InversionParameters()         ) Initialize ODINN parameters</p><p><strong>Keyword arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: Physical parameters for the simulation.</li><li><code>simulation::SimulationParameters</code>: Parameters related to the simulation setup.</li><li><code>solver::SolverParameters</code>: Parameters for the solver configuration.</li><li><code>hyper::Hyperparameters</code>: Hyperparameters for the model.</li><li><code>UDE::UDEparameters</code>: Parameters specific to the UDE (Universal Differential Equation).</li><li><code>inversion::InversionParameters</code>: Parameters for inversion processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/parameters/UDEparameters.jl#L59-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.SIA2D_adjoint!-Union{Tuple{I}, Tuple{R}, Tuple{Any, Matrix{R}, Matrix{R}, FunctionalInversion, Any, R, I}} where {R&lt;:Real, I&lt;:Integer}" href="#ODINN.SIA2D_adjoint!-Union{Tuple{I}, Tuple{R}, Tuple{Any, Matrix{R}, Matrix{R}, FunctionalInversion, Any, R, I}} where {R&lt;:Real, I&lt;:Integer}"><code>ODINN.SIA2D_adjoint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Define SIA2D forward map for the adjoint mode</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/gradient.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.SIA2D_grad!-Tuple{Any, Any, FunctionalInversion}" href="#ODINN.SIA2D_grad!-Tuple{Any, Any, FunctionalInversion}"><code>ODINN.SIA2D_grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inverse with batch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/gradient.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.SIA2D_grad_batch!-Tuple{Any, FunctionalInversion}" href="#ODINN.SIA2D_grad_batch!-Tuple{Any, FunctionalInversion}"><code>ODINN.SIA2D_grad_batch!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inverse by glacier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/gradient.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}" href="#ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}"><code>ODINN.VJP_λ_∂SIA∂H_continuous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂H_continuous(
    λ::Matrix{R},
    H::Matrix{R},
    simulation::SIM,
    t::R;
    batch_id::Union{Nothing, I} = nothing
)</code></pre><p>Implementation of the continuous adjoint of the SIA2D equation with respect to H. Given λ and H, it returns the VJP of λ^T * ∂(SIA2D)/∂H (H).</p><p>Arguments:</p><ul><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li><li><code>batch_id::Union{Nothing, I}</code>: Batch index.</li></ul><p>Returns:</p><ul><li><code>dλ::Matrix{R}</code>: Jacobian vector product, also called input gradient in reverse-mode AD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/SIA2D_adjoint.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Any, Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}" href="#ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Any, Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}"><code>ODINN.VJP_λ_∂SIA∂θ_continuous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂θ_continuous(
    θ,
    λ::Matrix{R},
    H::Matrix{R},
    simulation::SIM,
    t::R;
    batch_id::Union{Nothing, I} = nothing
)</code></pre><p>Implementation of the continuous adjoint of the SIA2D equation with respect to θ. Given λ, H and θ, it returns the VJP of λ^T * ∂(SIA2D)/∂θ (θ).</p><p>Arguments:</p><ul><li><code>θ</code>: Vector of parameters</li><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li><li><code>batch_id::Union{Nothing, I}</code>: Batch index.</li></ul><p>Returns:</p><ul><li><code>dλ::Matrix{R}</code>: Jacobian vector product, also called input gradient in reverse-mode AD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/inverse/SIA2D_adjoint.jl#L94-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.callback_diagnosis-Tuple{Any, Any, Any}" href="#ODINN.callback_diagnosis-Tuple{Any, Any, Any}"><code>ODINN.callback_diagnosis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">callback_diagnosis(θ, l, simulation)</code></pre><p>Callback function to track and diagose training. It includes print and updates in simulation::Simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/callback_utils.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.callback_plots_A-Tuple{Any, Any, Any}" href="#ODINN.callback_plots_A-Tuple{Any, Any, Any}"><code>ODINN.callback_plots_A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">callback_plots_A(θ, l, simulation)</code></pre><p>Callback function to generate plots during training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/callback_utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{G, Function, Any, Any, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}" href="#ODINN.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{G, Function, Any, Any, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}"><code>ODINN.generate_ground_truth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_ground_truth(glacier::G, fakeA::Function, params, model, tstops::Vector{F})</code></pre><p>Generates ground truth data and populate glacier with the ground truth observation given a fake law of A.</p><p>Arguments:</p><ul><li><code>glacier::G</code>: Glacier instance.</li><li><code>fakeA::Function</code>: Function that maps a temperature to A.</li><li><code>params::</code>: The simulation parameters.</li><li><code>model</code>:: The model that includes iceflow and a machine learning model.</li><li><code>tstops</code>:: Vector of time points where the solver should stop.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L171-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.generate_simulation_batches-Tuple{FunctionalInversion}" href="#ODINN.generate_simulation_batches-Tuple{FunctionalInversion}"><code>ODINN.generate_simulation_batches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_batches(simulation::S; shuffle=true)</code></pre><p>Generates batches for the UE inversion problem based on input data and feed them to the loss function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.get_NN-Tuple{Any, Any}" href="#ODINN.get_NN-Tuple{Any, Any}"><code>ODINN.get_NN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_NN(θ_trained, ft)</code></pre><p>Generates a neural network.</p><p><strong>Arguments</strong></p><ul><li><code>ft</code>: Float type.</li><li><code>θ_trained</code>: Pre-trained neural network parameters (optional).</li><li><code>ft</code>: Float type used. </li></ul><p><strong>Returns</strong></p><ul><li><code>UA</code>: <code>Lux.Chain</code> neural network architecture.</li><li><code>θ</code>: Neural network parameters.</li><li><code>st</code>: Lux state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.predict_A̅-Tuple{Any, Any}" href="#ODINN.predict_A̅-Tuple{Any, Any}"><code>ODINN.predict_A̅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_A̅(U, temp)</code></pre><p>Predicts the value of A with a neural network based on the long-term air temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.run!-Tuple{FunctionalInversion}" href="#ODINN.run!-Tuple{FunctionalInversion}"><code>ODINN.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>run!(simulation::FunctionalInversion)</p><p>In-place run of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/functional_inversion_utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.sigmoid_A-Tuple{Any}" href="#ODINN.sigmoid_A-Tuple{Any}"><code>ODINN.sigmoid_A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigmoid_A(x)</code></pre><p>Sigmoid activation function for the neural network output.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input value.</li></ul><p><strong>Returns</strong></p><ul><li>Sigmoid-transformed output value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.sigmoid_A_inv-Tuple{Any}" href="#ODINN.sigmoid_A_inv-Tuple{Any}"><code>ODINN.sigmoid_A_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigmoid_A_inv(x)</code></pre><p>Inverse sigmoid activation function for the neural network output.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input value.</li></ul><p><strong>Returns</strong></p><ul><li>Inverse sigmoid-transformed output value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L89-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, SciMLBase.DiscreteCallback, I}} where {I&lt;:Integer, SIM&lt;:Simulation}" href="#ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, SciMLBase.DiscreteCallback, I}} where {I&lt;:Integer, SIM&lt;:Simulation}"><code>ODINN.simulate_iceflow_UDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function simulate<em>iceflow</em>UDE!(     θ,     simulation::SIM,     cb::DiscreteCallback,     batch_id::I;     du = Huginn.SIA2D) where {I &lt;: Integer, SIM &lt;: Simulation}</p><p>Make forward simulation of the iceflow UDE determined in <code>du</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/functional_inversion_utils.jl#L314-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.train_UDE!-Tuple{FunctionalInversion, Optim.FirstOrderOptimizer}" href="#ODINN.train_UDE!-Tuple{FunctionalInversion, Optim.FirstOrderOptimizer}"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>BFGS Training</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/functional_inversion_utils.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.train_UDE!-Tuple{FunctionalInversion}" href="#ODINN.train_UDE!-Tuple{FunctionalInversion}"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>train_UDE!(simulation::FunctionalInversion)</p><p>Trains UDE based on the current FunctionalInversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/functional_inversion_utils.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.train_UDE!-Union{Tuple{AR}, Tuple{FunctionalInversion, AR}} where AR&lt;:Optimisers.AbstractRule" href="#ODINN.train_UDE!-Union{Tuple{AR}, Tuple{FunctionalInversion, AR}} where AR&lt;:Optimisers.AbstractRule"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ADAM Training</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/simulations/functional_inversions/functional_inversion_utils.jl#L96-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation" href="#ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation"><code>ODINN.update_training_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_training_state!(simulation::S, l) where {S &lt;: Simulation}</code></pre><p>Update the training state to determine if the training has completed an epoch. If an epoch is completed, reset the minibatches, update the history loss, and increment the epoch count.</p><p><strong>Arguments</strong></p><ul><li><code>simulation</code>: The current state of the simulation or training process.</li><li><code>l</code>: The current loss value or other relevant metric.</li></ul><p><strong>Returns</strong></p><ul><li>None. This function updates the state in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/cbc35aa3894f917105f54ee3482664052ce0345d/src/models/machine_learning/ML_utils.jl#L250-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.IceflowModel" href="#Huginn.IceflowModel"><code>Huginn.IceflowModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IceflowModel</code></pre><p>An abstract type representing the base model for ice flow simulations. All specific ice flow models should subtype this abstract type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Prediction(
    model::Sleipnir.Model,
    glaciers::Vector{Sleipnir.AbstractGlacier},
    parameters::Sleipnir.Parameters
    )</code></pre><p>Construnctor for Prediction struct with glacier model infomation, glaciers and parameters. Keyword arguments =================</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SIA2Dmodel" href="#Huginn.SIA2Dmodel"><code>Huginn.SIA2Dmodel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SIA2Dmodel{R &lt;: Real, I &lt;: Integer} &lt;: SIAmodel</code></pre><p>A mutable struct representing a 2D Shallow Ice Approximation (SIA) model.</p><p><strong>Fields</strong></p><ul><li><code>A::Union{Ref{R}, Nothing}</code>: Flow rate factor.</li><li><code>n::Union{Ref{R}, Nothing}</code>: Flow law exponent.</li><li><code>C::Union{Ref{R}, Matrix{R}, Nothing}</code>: Sliding coefficient.</li><li><code>H₀::Union{Matrix{R}, Nothing}</code>: Initial ice thickness.</li><li><code>H::Union{Matrix{R}, Nothing}</code>: Ice thickness.</li><li><code>H̄::Union{Matrix{R}, Nothing}</code>: Averaged ice thickness.</li><li><code>S::Union{Matrix{R}, Nothing}</code>: Surface elevation.</li><li><code>dSdx::Union{Matrix{R}, Nothing}</code>: Surface slope in the x-direction.</li><li><code>dSdy::Union{Matrix{R}, Nothing}</code>: Surface slope in the y-direction.</li><li><code>D::Union{Matrix{R}, Nothing}</code>: Diffusivity.</li><li><code>Dx::Union{Matrix{R}, Nothing}</code>: Diffusivity in the x-direction.</li><li><code>Dy::Union{Matrix{R}, Nothing}</code>: Diffusivity in the y-direction.</li><li><code>dSdx_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in the x-direction.</li><li><code>dSdy_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in the y-direction.</li><li><code>∇S::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation.</li><li><code>∇Sy::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation in the y-direction.</li><li><code>∇Sx::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation in the x-direction.</li><li><code>Fx::Union{Matrix{R}, Nothing}</code>: Flux in the x-direction.</li><li><code>Fy::Union{Matrix{R}, Nothing}</code>: Flux in the y-direction.</li><li><code>Fxx::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in the x-direction.</li><li><code>Fyy::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in the y-direction.</li><li><code>V::Union{Matrix{R}, Nothing}</code>: Velocity.</li><li><code>Vx::Union{Matrix{R}, Nothing}</code>: Velocity in the x-direction.</li><li><code>Vy::Union{Matrix{R}, Nothing}</code>: Velocity in the y-direction.</li><li><code>Γ::Union{Ref{R}, Nothing}</code>: Basal shear stress.</li><li><code>MB::Union{Matrix{R}, Nothing}</code>: Mass balance.</li><li><code>MB_mask::Union{AbstractArray{Bool}, Nothing}</code>: Mask for mass balance.</li><li><code>MB_total::Union{Matrix{R}, Nothing}</code>: Total mass balance.</li><li><code>glacier_idx::Union{Ref{I}, Nothing}</code>: Index of the glacier.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SIAmodel" href="#Huginn.SIAmodel"><code>Huginn.SIAmodel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SIAmodel</code></pre><p>An abstract type representing the Shallow Ice Approximation (SIA) models. This type is a subtype of <code>IceflowModel</code> and serves as a base for all SIA-specific models.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SolverParameters" href="#Huginn.SolverParameters"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverParameters{F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>A mutable struct that holds parameters for the solver.</p><p><strong>Fields</strong></p><ul><li><code>solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm</code>: The algorithm used for solving differential equations.</li><li><code>reltol::F</code>: The relative tolerance for the solver.</li><li><code>step::F</code>: The step size for the solver.</li><li><code>tstops::Union{Nothing, Vector{F}}</code>: Optional vector of time points where the solver should stop for the callbacks.</li><li><code>save_everystep::Bool</code>: Flag indicating whether to save the solution at every step.</li><li><code>progress::Bool</code>: Flag indicating whether to show progress during the solving process.</li><li><code>progress_steps::I</code>: The number of steps between progress updates.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}" href="#Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolverParameters(;
    solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),
    reltol::Float64 = 1e-7
    )</code></pre><p>Initialize the parameters for the numerical solver. Keyword arguments =================     - <code>solver</code>: solver to use from DifferentialEquations.jl     - <code>reltol</code>: Relative tolerance for the solver</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.Model-Union{Tuple{}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel}" href="#Huginn.Model-Union{Tuple{}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel}"><code>Huginn.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Model(;     iceflow::Union{IFM, Nothing},     mass_balance::Union{MBM, Nothing}     ) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel}</p><p>Initialize Model at Huginn level (no machine learning model).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}" href="#Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}"><code>Huginn.SIA2D!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>SIA2D!(dH, H, SIA2Dmodel)</p><p>Compute an in-place step of the Shallow Ice Approximation PDE in a forward model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}" href="#Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}"><code>Huginn.SIA2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SIA(H, SIA2Dmodel)</code></pre><p>Compute a step of the Shallow Ice Approximation UDE in a forward model. Allocates memory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg-Tuple{Any}" href="#Huginn.avg-Tuple{Any}"><code>Huginn.avg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg(A)</code></pre><p>4-point average of a matrix</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_surface_V!-Tuple{SIM} where SIM&lt;:Simulation" href="#Huginn.avg_surface_V!-Tuple{SIM} where SIM&lt;:Simulation"><code>Huginn.avg_surface_V!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_surface_V!(simulation::SIM) where {SIM &lt;: Simulation}</code></pre><p>Computes the average ice surface velocity for a given glacier evolution period based on the initial and final ice thickness states.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I&lt;:Integer, SIM&lt;:Simulation}" href="#Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I&lt;:Integer, SIM&lt;:Simulation}"><code>Huginn.avg_surface_V</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_surface_V(simulation::SIM; batch_id::Union{Nothing, I} = nothing) where {I &lt;: Integer, SIM &lt;: Simulation}</code></pre><p>Computes the average ice surface velocity for a given glacier evolution period based on the initial and final ice thickness states.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_x-Tuple{Any}" href="#Huginn.avg_x-Tuple{Any}"><code>Huginn.avg_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_x(A)</code></pre><p>2-point average of a matrix&#39;s X axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_y-Tuple{Any}" href="#Huginn.avg_y-Tuple{Any}"><code>Huginn.avg_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_y(A)</code></pre><p>2-point average of a matrix&#39;s Y axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer" href="#Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer"><code>Huginn.batch_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE!(glacier_idx::I, simulation::Prediction)</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE for a given temperature series batch in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer" href="#Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer"><code>Huginn.batch_iceflow_PDE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE(glacier_idx::I, simulation::Prediction)</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE for a given temperature series batch out-of-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F&lt;:AbstractFloat" href="#Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F&lt;:AbstractFloat"><code>Huginn.define_callback_steps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">define_callback_steps(tspan::Tuple{F, F}, step::F) where {F &lt;: AbstractFloat}</code></pre><p>Defines the times to stop for the DiscreteCallback given a step</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.diff_x-Tuple{Any}" href="#Huginn.diff_x-Tuple{Any}"><code>Huginn.diff_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_x(A)</code></pre><p>2-point differential of a matrix&#39;s X axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.diff_y-Tuple{Any}" href="#Huginn.diff_y-Tuple{Any}"><code>Huginn.diff_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_y(A)</code></pre><p>2-point differential of a matrix&#39;s Y axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer, G&lt;:AbstractGlacier}" href="#Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer, G&lt;:AbstractGlacier}"><code>Huginn.initialize_iceflow_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function initialize<em>iceflow</em>model!(iceflow<em>model::IF,       glacier</em>idx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters     ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable in-place mutation.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `iceflow_model`: Iceflow model used for simulation. 
- `glacier_idx`: Index of glacier.
- `glacier`: `Glacier` to provide basic initial state of the ice flow model.
- `parameters`: `Parameters` to configure some physical variables.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer}" href="#Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer}"><code>Huginn.initialize_iceflow_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function initialize<em>iceflow</em>model(iceflow<em>model::IF,       glacier</em>idx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters     ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable out-of-place mutation.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `iceflow_model`: Iceflow model used for simulation. 
- `glacier_idx`: Index of glacier.
- `glacier`: `Glacier` to provide basic initial state of the ice flow model.
- `parameters`: `Parameters` to configure some physical variables.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.inn-Tuple{Any}" href="#Huginn.inn-Tuple{Any}"><code>Huginn.inn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inn(A)</code></pre><p>Access the inner part of the matrix (-2,-2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.inn1-Tuple{Any}" href="#Huginn.inn1-Tuple{Any}"><code>Huginn.inn1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inn1(A)</code></pre><p>Access the inner part of the matrix (-1,-1)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.run!-Tuple{Prediction}" href="#Huginn.run!-Tuple{Prediction}"><code>Huginn.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(simulation::Prediction)</code></pre><p>In-place run of the model. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.run₀-Tuple{Prediction}" href="#Huginn.run₀-Tuple{Prediction}"><code>Huginn.run₀</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(simulation::Prediction)</code></pre><p>Out-of-place run of the model. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation" href="#Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation"><code>Huginn.simulate_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate_iceflow_PDE!(
    simulation::SIM,
    cb::DiscreteCallback;
    du = SIA2D!) where {SIM &lt;: Simulation}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation" href="#Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation"><code>Huginn.simulate_iceflow_PDE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate_iceflow_PDE(
    simulation::SIM,
    cb::DiscreteCallback;
    du = SIA2D) where {SIM &lt;: Simulation}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation" href="#Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation"><code>Huginn.surface_V!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surface_V!(H, B, Δx, Δy, temp, sim, A_noise, θ=[], UA_f=[])</code></pre><p>Computes the ice surface velocity for a given glacier state</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I&lt;:Integer, R&lt;:Real, SIM&lt;:Simulation}" href="#Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I&lt;:Integer, R&lt;:Real, SIM&lt;:Simulation}"><code>Huginn.surface_V</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surface_V(H, B, Δx, Δy, temp, sim, A_noise, θ=[], UA_f=[])</code></pre><p>Computes the ice surface velocity for a given glacier state</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat" href="#Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TImodel1(params::Sleipnir.Parameters;
    DDF::Float64 = 7.0/1000.0,
    acc_factor::Float64 = 1.0/1000.0
    )</code></pre><p>Temperature-index model with a single degree-day factor.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `DDF`: Single degree-day factor, for both snow and ice.
- `acc_factor`: Accumulation factor</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat" href="#Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat"><code>Muninn.TImodel2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TImodel2(params::Parameters;
    DDF_snow::Float64 = 3.0/1000.0,
    DDF_ice::Float64 = 6.0/1000.0,
    acc_factor::Float64 = 1.0/1000.0
    )</code></pre><p>Temperature-index model with two melt factors, for snow and ice.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `DDF_snow`: Degree-day factor for snow.
- `DDF_ice`: Degree-day factor for ice.
- `acc_factor`: Accumulation factor</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I&lt;:Integer, F&lt;:AbstractFloat, G&lt;:AbstractGlacier}" href="#Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I&lt;:Integer, F&lt;:AbstractFloat, G&lt;:AbstractGlacier}"><code>Muninn.MB_timestep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MB_timestep!(model::Model, glacier::G, step::F, t; batch_id::Union{Nothing, I} = nothing) where {I &lt;: Integer, F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Retrieve the climate data, apply downscaling and compute the mass balance of a glacier for a specific time step and possibly for a batch of iceflow models.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}" href="#Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}"><code>Muninn.MB_timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MB_timestep(model::Model, glacier::G, step::F, t::F) where {F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Retrieve the climate data, apply downscaling and compute the mass balance of a glacier for a specific time step.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}" href="#Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}"><code>Muninn.compute_MB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_MB(mb_model::TImodel1, climate_2D_period::Climate2Dstep)</code></pre><p>Compute the the mass balance given a mass balance model and a climate step.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `mb_model`: Mass balance model.
- `climate_2D_period`: Climate step.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}" href="#Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}"><code>Sleipnir.Glacier1D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Glacier1D(;     rgi<em>id::Union{String, Nothing} = nothing,     climate::Union{Climate1D, Nothing} = nothing,     H₀::Union{Vector{F}, Nothing} = nothing,     S::Union{Vector{F}, Nothing} = nothing,     B::Union{Vector{F}, Nothing} = nothing,     V::Union{Vector{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     w₀::Union{Vector{F}, Nothing} = nothing,     λ::Union{Vector{F}, Nothing} = nothing,     slope::Union{Vector{F}, Nothing} = nothing,     dist</em>border::Union{Vector{F}, Nothing} = nothing,     Coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing     ) where {F &lt;: AbstractFloat, I &lt;: Integer}</p><p>Constructor for empty 2D Glacier object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}" href="#Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Glacier2D(;     rgi<em>id::Union{String, Nothing} = nothing,     climate::Union{Climate2D, Nothing} = nothing,     H₀::Union{Matrix{F}, Nothing} = nothing,     H</em>glathida::Union{Matrix{F}, Nothing} = nothing,     S::Union{Matrix{F}, Nothing} = nothing,     B::Union{Matrix{F}, Nothing} = nothing,     V::Union{Matrix{F}, Nothing}= nothing,     Vx::Union{Matrix{F}, Nothing}= nothing,     Vy::Union{Matrix{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     slope::Union{Matrix{F}, Nothing} = nothing,     dist_border::Union{Matrix{F}, Nothing} = nothing,     Coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing,     cenlon::Union{F, Nothing} = nothing,     cenlat::Union{F, Nothing} = nothing     ) where {F &lt;: AbstractFloat, I &lt;: Integer}</p><p>Constructor for empty 2D Glacier object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Parameters-Tuple{}" href="#Sleipnir.Parameters-Tuple{}"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters()         ) Initialize ODINN parameters</p><p><strong>Keyword arguments</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat" href="#Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PhysicalParameters(;
        ρ::F = 900.0,
        g::F = 9.81,
        ϵ::F = 1e-3,
        η₀::F = 1.0, 
        maxA::F = 8e-17,
        minA::F = 8.5e-20,
        maxTlaw::F = 1.0,
        minTlaw::F = -25.0,
        noise_A_magnitude::F = 5e-18
        )</code></pre><p>Initialize the physical parameters of a model. Keyword arguments =================     - <code>ρ</code>: Ice density     - <code>g</code>: Gravitational constant     - <code>ϵ</code>: Small number     - <code>η₀</code>:       - <code>maxA</code>: Maximum value for <code>A</code> (Glen&#39;s coefficient)     - <code>minA</code>: Minimum value for <code>A</code> (Glen&#39;s coefficient)     - <code>maxTlaw</code>: Maximum value of Temperature used in simulations on fake law     - <code>minTlaw</code>: Minimum value of Temperature used in simulations on fake law     - <code>noise_A_magnitude</code>: Magnitude of noise added to A</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Results" href="#Sleipnir.Results"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Results{F &lt;: AbstractFloat, I &lt;: Int}</code></pre><p>A mutable struct to store the results of simulations.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: Identifier for the RGI (Randolph Glacier Inventory).</li><li><code>H::Vector{Matrix{F}}</code>: Vector of matrices representing glacier ice thickness <code>H</code> over time.</li><li><code>H_glathida::Union{Nothing, Vector{Matrix{F}}}</code>: Optional vector of matrices for Glathida ice thicknesses.</li><li><code>S::Matrix{F}</code>: Glacier surface altimetry.</li><li><code>B::Matrix{F}</code>: Glacier bedrock.</li><li><code>V::Matrix{F}</code>: Glacier ice surface velocities.</li><li><code>Vx::Matrix{F}</code>: x-component of the glacier ice surface velocity <code>V</code>.</li><li><code>Vy::Matrix{F}</code>: y-component of the glacier ice surface velocity <code>V</code>.</li><li><code>V_ref::Union{Nothing, Matrix{F}}</code>: Reference data for glacier ice surface velocities <code>V</code>.</li><li><code>Vx_ref::Union{Nothing, Matrix{F}}</code>: Reference data for the x-component of the glacier ice surface velocity <code>Vx</code>.</li><li><code>Vy_ref::Union{Nothing, Matrix{F}}</code>: Reference data for the y-component of the glacier ice surface velocity <code>Vy</code>.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::Union{Nothing, F}</code>: Optional longitude value.</li><li><code>lat::Union{Nothing, F}</code>: Optional latitude value.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>tspan::Vector{F}</code>: Time span of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Machine learning model parameters.</li><li><code>loss::Union{Nothing, Vector{F}}</code> Vector with evolution of loss function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Int64}" href="#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Int64}"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Results(glacier::G, ifm::IF; rgi_id::String = glacier.rgi_id, H::Vector{Matrix{F}} = Vector{Matrix{F}}([]), 
        H_glathida::Union{Nothing, Vector{Matrix{F}}} = glacier.H_glathida, S::Matrix{F} = zeros(F, size(ifm.S)), 
        B::Matrix{F} = zeros(F, size(ifm.B)), V::Matrix{F} = zeros(F, size(ifm.V)), 
        Vx::Matrix{F} = zeros(F, size(ifm.Vx)), Vy::Matrix{F} = zeros(F, size(ifm.Vy)), 
        V_ref::Union{Nothing, Matrix{F}} = glacier.V, Vx_ref::Union{Nothing, Matrix{F}} = glacier.Vx, 
        Vy_ref::Union{Nothing, Matrix{F}} = glacier.Vy, Δx::F = glacier.Δx, Δy::F = glacier.Δy, 
        lon::Union{Nothing, F} = glacier.cenlon, lat::Union{Nothing, F} = glacier.cenlat, 
        nx::I = glacier.nx, ny::I = glacier.ny, θ::Union{Nothing, ComponentArray{F}} = nothing,
        loss::Union{Nothing, Vector{F}} = Nothing) where {G &lt;: AbstractGlacier, F &lt;: AbstractFloat, IF &lt;: AbstractModel}</code></pre><p>Construct a <code>Results</code> object for a glacier simulation.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::G</code>: The glacier object, subtype of <code>AbstractGlacier</code>.</li><li><code>ifm::IF</code>: The model object, subtype of <code>AbstractModel</code>.</li><li><code>rgi_id::String</code>: The RGI identifier for the glacier. Defaults to <code>glacier.rgi_id</code>.</li><li><code>H::Vector{Matrix{F}}</code>: Ice thickness matrices. Defaults to an empty vector.</li><li><code>H_glathida::Union{Nothing, Vector{Matrix{F}}}</code>: Ice thickness from GlaThiDa. Defaults to <code>glacier.H_glathida</code>.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix. Defaults to a zero matrix of the same size as <code>ifm.S</code>.</li><li><code>B::Matrix{F}</code>: Bed elevation matrix. Defaults to a zero matrix of the same size as <code>ifm.B</code>.</li><li><code>V::Matrix{F}</code>: Velocity magnitude matrix. Defaults to a zero matrix of the same size as <code>ifm.V</code>.</li><li><code>Vx::Matrix{F}</code>: Velocity in the x-direction matrix. Defaults to a zero matrix of the same size as <code>ifm.Vx</code>.</li><li><code>Vy::Matrix{F}</code>: Velocity in the y-direction matrix. Defaults to a zero matrix of the same size as <code>ifm.Vy</code>.</li><li><code>V_ref::Union{Nothing, Matrix{F}}</code>: Reference velocity magnitude matrix. Defaults to <code>glacier.V</code>.</li><li><code>Vx_ref::Union{Nothing, Matrix{F}}</code>: Reference velocity in the x-direction matrix. Defaults to <code>glacier.Vx</code>.</li><li><code>Vy_ref::Union{Nothing, Matrix{F}}</code>: Reference velocity in the y-direction matrix. Defaults to <code>glacier.Vy</code>.</li><li><code>Δx::F</code>: Grid spacing in the x-direction. Defaults to <code>glacier.Δx</code>.</li><li><code>Δy::F</code>: Grid spacing in the y-direction. Defaults to <code>glacier.Δy</code>.</li><li><code>lon::Union{Nothing, F}</code>: Longitude of the glacier center. Defaults to <code>glacier.cenlon</code>.</li><li><code>lat::Union{Nothing, F}</code>: Latitude of the glacier center. Defaults to <code>glacier.cenlat</code>.</li><li><code>nx::I</code>: Number of grid points in the x-direction. Defaults to <code>glacier.nx</code>.</li><li><code>ny::I</code>: Number of grid points in the y-direction. Defaults to <code>glacier.ny</code>.</li><li><code>tspan::Tuple(F, F)</code>: Timespan of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Model parameters. Defaults to <code>nothing</code>.</li><li><code>loss::Union{Nothing, Vector{F}}</code>: Loss values. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Results</code>: A <code>Results</code> object containing the simulation results.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat}" href="#Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat}"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimulationParameters(;
                    use_MB::Bool = true,
                    use_iceflow::Bool = true,
                    plots::Bool = true,
                    velocities::Bool = true,
                    overwrite_climate::Bool = false,
                    use_glathida_data::Bool = false,
                    tspan::Tuple{F, F} = (2010.0,2015.0),
                    step::F = 1/12,
                    multiprocessing::Bool = true,
                    workers::I = 4,
                    working_dir::String = &quot;&quot;,
                    test_mode::Bool = false,
                    rgi_paths::Dict{String, String} = Dict{String, String}(),
                    ice_thickness_source::String = &quot;Farinotti19&quot;,
    )</code></pre><p>Initialize the parameters for a simulation. Keyword arguments =================     - <code>use_MB</code>: Determines if surface mass balance should be used.     - <code>plots</code>: Determines if plots should be made.     - <code>overwrite_climate</code>: Determines if climate data should be overwritten     - &#39;use<em>glathida</em>data&#39;: Determines if data from the Glathida data set should be used</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat" href="#Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat"><code>Sleipnir.SurfaceVelocityData</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function SurfaceVelocityData(;     x::Union{Vector{F}, Nothing} = nothing,     y::Union{Vector{F}, Nothing} = nothing,      lat::Union{Vector{F}, Nothing} = nothing,     lon::Union{Vector{F}, Nothing} = nothing,      vx::Union{Array{F, 3}, Nothing} = nothing,     vy::Union{Array{F, 3}, Nothing} = nothing,     vabs::Union{Array{F, 3}, Nothing} = nothing,     vx<em>error::Union{Array{F, 1}, Nothing} = nothing,     vy</em>error::Union{Array{F, 1}, Nothing} = nothing,     vabs<em>error::Union{Array{F, 1}, Nothing} = nothing,     date::Union{Vector{DateTime}, Nothing} = nothing,     date1::Union{Vector{DateTime}, Nothing} = nothing,     date2::Union{Vector{DateTime}, Nothing} = nothing,     date</em>error::Union{Vector{Day}, Vector{Millisecond}, Nothing} = nothing,     ) where {F &lt;: AbstractFloat}</p><p>Constructor for ice surface velocity data based on Rabatel et. al (2023). </p><p>Important remarks:</p><ul><li>Projections in longitude and latitude assume we are working in the north hemisphere.  If working with south hemisphere glaciers, this needs to be changed.</li><li>The error in velocity is unique per timestamp, rather than being pixel distributed. </li><li>The error in the absolute velocities <code>vabs_error</code> is overestimated.</li></ul><p>References:     - Rabatel, A., Ducasse, E., Millan, R. &amp; Mouginot, J.      Satellite-Derived Annual Glacier Surface Flow Velocity Products for the European Alps, 2015–2021.      Data 8, 66 (2023).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat" href="#Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat"><code>Sleipnir.UTMercator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0)</code></pre><p>Transverse Mercator Projection.  This function reprojects northing/easting coordinates into latitude/longitude. </p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `k`: scale factor of the projection
- `cenlon`: Central longitude used in the projection
- `cenlat`: Central latitude used in the projection
- `x0`: Shift in easting
- `y0`: Shift in northing
- `zone` : Zone of the projection
- `hemisphere`: Either :north or :south</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}" href="#Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}"><code>Sleipnir.apply_t_grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_t_grad!(climate::RasterStack, dem::Raster)</code></pre><p>Applies temperature gradients to the glacier 2D climate data based on a DEM.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM&lt;:Simulation, I&lt;:Integer}" href="#Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM&lt;:Simulation, I&lt;:Integer}"><code>Sleipnir.create_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">store_results!(simulation::SIM, glacier_idx::I, solution) where {SIM &lt;: Simulation, I &lt;: Int}</code></pre><p>Store the results of a simulation of a single glacier into a <code>Results</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}" href="#Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}"><code>Sleipnir.downscale_2D_climate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">downscale_2D_climate(glacier::Glacier2D)</code></pre><p>Projects climate data to the glacier matrix by simply copying the closest gridpoint to all matrix gridpoints. Generates a new RasterStack which is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.fillNaN!" href="#Sleipnir.fillNaN!"><code>Sleipnir.fillNaN!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fillNaN!(x, fill)</p><p>Convert empty matrix grid cells into fill value</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.get_cumulative_climate!" href="#Sleipnir.get_cumulative_climate!"><code>Sleipnir.get_cumulative_climate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cumulative_climate(climate, gradient_bounds=[-0.009, -0.003], default_grad=-0.0065)</code></pre><p>Computes Positive Degree Days (PDDs) and cumulative rainfall and snowfall from climate data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.get_raw_climate_data-Tuple{String}" href="#Sleipnir.get_raw_climate_data-Tuple{String}"><code>Sleipnir.get_raw_climate_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_raw_climate_data(rgi_path::String)</code></pre><p>Load the netCDF file containing the climate data for that glacier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}" href="#Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}"><code>Sleipnir.initialize_glacier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_glacier(rgi_id::String, parameters::Parameters; smoothing=false, velocities=true)</code></pre><p>Initialize a single <code>Glacier</code>s, including its <code>Climate</code>, based on a <code>rgi_id</code> and timestepping arguments.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `rgi_id`: Glacier RGI ID
- `parameters`: Parameters including the physical and simulation ones
- `smoothing` Flag determining if smoothing needs to be applied to the surface elevation and ice thickness.
- `velocities` Flag determining if the ice surface velocities need to be retrieved.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}" href="#Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}"><code>Sleipnir.initialize_glacier_climate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function initialize_glacier_climate!(glacier::AbstractGlacier, params::Parameters)</code></pre><p>Initializes the <code>Climate</code> data structure for a given <code>Glacier</code>`</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}" href="#Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}"><code>Sleipnir.initialize_glacier_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_glacier(rgi_id::String, params::Parameters; smoothing=false, velocities=true)</code></pre><p>Retrieves the initial glacier geometry (bedrock + ice thickness) for a glacier with other necessary data (e.g. grid size and ice surface velocities).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}" href="#Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}"><code>Sleipnir.initialize_glaciers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_glaciers(rgi_ids::Vector{String}, params::Parameters; test=false)</code></pre><p>Initialize multiple <code>Glacier</code>s based on a list of RGI IDs and on parameters.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `rgi_ids`: List of RGI IDs of glaciers
- `params`: `Parameters` object to be passed</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_surfacevelocitydata-Tuple{String}" href="#Sleipnir.initialize_surfacevelocitydata-Tuple{String}"><code>Sleipnir.initialize_surfacevelocitydata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_surfacevelocitydata(file::String; interp=false)</code></pre><p>Initialize SurfaceVelocityData from Rabatel et. al (2023). </p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `file`: name of netcdf file with data
- `interp`: boolean variable indicating if we use the inporpolated data or not</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.max_or_empty-Tuple{Array}" href="#Sleipnir.max_or_empty-Tuple{Array}"><code>Sleipnir.max_or_empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_or_empyt(A::Array)</code></pre><p>Return maximum value for non-empty arrays.  This is just required to compute the error in the absolute velocity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.parse_proj-Tuple{String}" href="#Sleipnir.parse_proj-Tuple{String}"><code>Sleipnir.parse_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_proj(proj::String)</code></pre><p>Parses the string containing the information of the projection to filter for important information &quot;+proj=tmerc +lat<em>0=0 +lon</em>0=6.985 +k=0.9996 +x<em>0=0 +y</em>0=0 +datum=WGS84 +units=m +no_defs&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_bias-Tuple{Any, Any}" href="#Sleipnir.plot_bias-Tuple{Any, Any}"><code>Sleipnir.plot_bias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_bias(data::Results, variables::Vector{Symbol}; treshold::Vector{Float64}=[0, 0])</code></pre><p>Plot the bias of the glacier integrated volume over the specified time span.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variables to be plotted.</li><li><code>title_mapping::Dict{Symbol, String}</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan::Tuple{Float64, Float64}</code>: A tuple representing the start and end time for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier integrated volume bias.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier-Tuple{Results, String, Vector{Symbol}}" href="#Sleipnir.plot_glacier-Tuple{Results, String, Vector{Symbol}}"><code>Sleipnir.plot_glacier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -&gt; Figure</code></pre><p>Generate various types of plots for glacier data.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>plot_type::String</code>: Type of plot to generate. Options are:<ul><li>&quot;heatmaps&quot;: Heatmaps for glacier variables like <code>:H</code>, <code>:S</code>, <code>:B</code>, <code>:V</code>, <code>:Vx</code>, and <code>:Vy</code>.</li><li>&quot;evolution difference&quot;: Temporal difference metrics (between start and end) for a variable, with optional metrics like &quot;hist&quot; (histogram) and &quot;difference&quot;.</li><li>&quot;evolution statistics&quot;: Temporal statistical metrics for a variable, with optional metrics like &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;.</li><li>&quot;integrated volume&quot;: Temporal evolution of the integrated ice volume for a variable.</li><li>&quot;bias&quot;: Scatter plot to visualize the bias between two variables.</li></ul></li><li><code>variables::Vector{Symbol}</code>: Variables to be plotted, e.g., <code>:H</code>.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics</code>: Metrics to visualize, e.g., <code>[&quot;average&quot;]</code> for statistics, <code>[&quot;difference&quot;]</code> for difference.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size for heatmaps.</li><li><code>threshold::Vector{F}</code>: Threshold values for filtering data in bias plots.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Figure</code> object containing the desired visualization.</li></ul><p><strong>Notes</strong></p><ul><li>Ensure the <code>variables</code> and <code>kwargs</code> match the requirements of the specified <code>plot_type</code>.</li><li>The function routes requests to specific plotting functions based on <code>plot_type</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Results, Vector{Symbol}, Any}} where F&lt;:AbstractFloat" href="#Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Results, Vector{Symbol}, Any}} where F&lt;:AbstractFloat"><code>Sleipnir.plot_glacier_difference_evolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier_difference_evolution(results::Results, variables::Vector{Symbol}, title_mapping; tspan::Tuple{F,F}=results.tspan, metrics::Vector{String}=&quot;difference&quot;) where {F&lt;:AbstractFloat}</code></pre><p>Plot the evolution of the difference in a glacier variable over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The simulation results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variable to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan::Tuple{F,F}</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics::Vector{String}</code>: Metrics to visualize, e.g., <code>[&quot;difference&quot;]</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier difference evolution.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier_heatmaps-Tuple{Results, Vector{Symbol}, Dict}" href="#Sleipnir.plot_glacier_heatmaps-Tuple{Results, Vector{Symbol}, Dict}"><code>Sleipnir.plot_glacier_heatmaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier_heatmaps(results::Results, variables::Vector{Symbol}, title_mapping::Dict; scale_text_size::Union{Nothing,Float64}=nothing) -&gt; Figure</code></pre><p>Plot heatmaps for glacier variables.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping::Dict</code>: A dictionary mapping variable names to their titles and colormaps.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier heatmaps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}" href="#Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}"><code>Sleipnir.plot_glacier_integrated_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier_integrated_volume(results::Results, variables::Vector{Symbol}, title_mapping; tspan)</code></pre><p>Plot the integrated volume of a glacier variable over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variable to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier integrated volume.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier_statistics_evolution-Tuple{Results, Vector{Symbol}, Any}" href="#Sleipnir.plot_glacier_statistics_evolution-Tuple{Results, Vector{Symbol}, Any}"><code>Sleipnir.plot_glacier_statistics_evolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier_statistics_evolution(results::Results, variables::Vector{Symbol}, title_mapping; metrics=&quot;median&quot;, tspan, threshold=0.5)</code></pre><p>Plot the evolution of statistics for multiple glacier variables over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The simulation results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>metrics</code>: Metrics to visualize, e.g., &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;. Default is &quot;median&quot;.</li><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>threshold</code>: A threshold value to filter the data. Default is 0.5.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier statistics evolution.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier_vid-Tuple{String, Vector{Matrix{Float64}}, Glacier2D, SimulationParameters, String}" href="#Sleipnir.plot_glacier_vid-Tuple{String, Vector{Matrix{Float64}}, Glacier2D, SimulationParameters, String}"><code>Sleipnir.plot_glacier_vid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier_vid(
    plot_type::String,
    H::Vector{Matrix{Float64}},
    glacier::Glacier2D,
    simuparams::SimulationParameters,
    pathVideo::String;
    framerate::Int=24,
    baseTitle::String=&quot;&quot;
)</code></pre><p>Generate various types of videos for glacier data.</p><p><strong>Arguments</strong></p><ul><li><code>plot_type</code>: Type of plot to generate. Options are:<ul><li>&quot;thickness&quot;: Heatmap of the glacier thickness.</li></ul></li><li><code>H</code>: A vector of matrices containing the ice thickness over time. This should be   replaced by a Results instance in the future once Results no longer depends on   an iceflow model.</li><li><code>glacier</code>: A glacier instance.</li><li><code>simuparams</code>: The simulation parameters.</li><li><code>pathVideo</code>: Path of the mp4 file to generate.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>framerate</code>: The framerate to use for the video generation.</li><li><code>baseTitle</code>: The prefix to use in the title of the frames. In each frame it is   concatenated with the value of the year in the form &quot; (t=XXXX)&quot;.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Results{F, I}, 1}, SIM}} where {F&lt;:AbstractFloat, I&lt;:Int64, SIM&lt;:Simulation}" href="#Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Results{F, I}, 1}, SIM}} where {F&lt;:AbstractFloat, I&lt;:Int64, SIM&lt;:Simulation}"><code>Sleipnir.save_results_file!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_results_file!(results_list::Vector{Results{F}}, simulation::SIM; path::Union{String,Nothing}=nothing) where {F &lt;: AbstractFloat, SIM &lt;: Simulation}</code></pre><p>Save simulation results which are provided as a list of <code>Results</code> into a <code>.jld2</code> file. This function also overrides the <code>results</code><code>attribute of</code>simulation`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.smooth!-Tuple{Any}" href="#Sleipnir.smooth!-Tuple{Any}"><code>Sleipnir.smooth!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth!(A)</code></pre><p>Smooth data contained in a matrix with one time step (CFL) of diffusion.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.stop_condition_tstops-NTuple{4, Any}" href="#Sleipnir.stop_condition_tstops-NTuple{4, Any}"><code>Sleipnir.stop_condition_tstops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stop_condition_tstops(u,t,integrator, tstops)</code></pre><p>Function that iterates through the tstops, with a closure including <code>tstops</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.trim_period-Tuple{Any, Any}" href="#Sleipnir.trim_period-Tuple{Any, Any}"><code>Sleipnir.trim_period</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trim_period(period, climate)</code></pre><p>Trims a time period based on the time range of a climate series. </p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 March 2025 13:37">Thursday 27 March 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
