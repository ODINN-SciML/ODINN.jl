<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ODINN.jl</title><meta name="title" content="API · ODINN.jl"/><meta property="og:title" content="API · ODINN.jl"/><meta property="twitter:title" content="API · ODINN.jl"/><meta name="description" content="Documentation for ODINN.jl."/><meta property="og:description" content="Documentation for ODINN.jl."/><meta property="twitter:description" content="Documentation for ODINN.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../forward_simulation/">Forward simulation</a></li><li><a class="tocitem" href="../classical_inversion/">Classical inversion</a></li><li><a class="tocitem" href="../functional_inversion/">Functional inversion</a></li><li><a class="tocitem" href="../laws/">Laws</a></li><li><a class="tocitem" href="../input_laws/">Laws inputs</a></li><li><a class="tocitem" href="../vjp_laws/">Laws VJP customization</a></li></ul></li><li><span class="tocitem">How to use ODINN</span><ul><li><a class="tocitem" href="../parameters/">Parameters</a></li><li><a class="tocitem" href="../glaciers/">Glaciers</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../results_plotting/">Results and plotting</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul></li><li><span class="tocitem">Inversions</span><ul><li><a class="tocitem" href="../inversions/">Inversion types</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity analysis</a></li></ul></li><li><span class="tocitem">Community</span><ul><li><a class="tocitem" href="../contribute/">How to contribute</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of conduct</a></li></ul></li><li><a class="tocitem" href="../changes_plans/">Ongoing changes and future plans</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to use ODINN</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This is an exhaustive list of all the types and functions in <code>ODINN.jl</code>, <code>Huginn.jl</code>, <code>Muninn.jl</code> and <code>Sleipnir.jl</code>.</p><article><details class="docstring" open="true"><summary id="ODINN.AbstractAdjointMethod-api"><a class="docstring-binding" href="#ODINN.AbstractAdjointMethod-api"><code>ODINN.AbstractAdjointMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAdjointMethod</code></pre><p>Abstract type representing the flavor of AD and adjoint to be used to compute the gradient of the cost function. There are two parts where one can play with how the gradient is propagated: the iceflow model VJP and the adjoint of the ODE solver. The VJP of the iceflow model can be computed using either AD (Zygote or Enzyme), the discrete, or the continuous adjoint of the iceflow model. As for the computation of the adjoint of the ODE solution, it can be handled by SciMLSensitivity, or computed using the adjoint implemented in ODINN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/AdjointTypes.jl#L5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.AbstractVJPMethod-api"><a class="docstring-binding" href="#ODINN.AbstractVJPMethod-api"><code>ODINN.AbstractVJPMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractVJPMethod</code></pre><p>Abstract type representing the flavor of AD to be used to compute the VJP inside the gradient of the cost function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/VJPTypes.jl#L4-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.ContinuousAdjoint-api"><a class="docstring-binding" href="#ODINN.ContinuousAdjoint-api"><code>ODINN.ContinuousAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ContinuousAdjoint{
    F &lt;: AbstractFloat,
    I &lt;: Integer,
    VJP &lt;: AbstractVJPMethod,
    MBVJP &lt;: AbstractVJPMethod,
} &lt;: AbstractAdjointMethod</code></pre><p>Continuous adjoint of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><strong>Fields</strong></p><ul><li><code>VJP_method::VJP</code>: Type of AbstractVJPMethod used to compute VJPs inside adjoint   calculation.</li><li><code>solver::Any</code>: The solver to be used for adjoint.</li><li><code>reltol::F</code>: Relative tolerance to be used in the ODE solver of the adjoint.</li><li><code>abstol::F</code>: Absolute tolerance to be used in the ODE solver of the adjoint.</li><li><code>dtmax::F</code>: Maximum time step to be used in the ODE solver of the adjoint.</li><li><code>interpolation</code>: Interpolation method to be used to interpolate the variables in   the computation of the adjoint. Currently only <code>:Linear</code> is supported.</li><li><code>n_quadrature::I</code>: Number of nodes used in the Gauss quadrature for the numerical   integration of the loss function.</li><li><code>MB_VJP::MBVJP</code>: Type of AbstractVJPMethod used to compute the MB VJP inside adjoint   calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/AdjointTypes.jl#L27-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.ContinuousVJP-api"><a class="docstring-binding" href="#ODINN.ContinuousVJP-api"><code>ODINN.ContinuousVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ContinuousVJP{ADTYPE &lt;: DI.AbstractADType} &lt;: AbstractVJPMethod</code></pre><p>Continuous manual implementation of the VJP required inside the adjoint calculation. It relies in the continuous expresion for the adjoint operation based on the functional formula of the forward PDE.</p><p><strong>Fields</strong></p><ul><li><code>regressorADBackend::ADTYPE</code>: Specifies the AD backend used for the laws when   their associated VJPs functions are not provided. The type parameter <code>ADTYPE</code>   must be a subtype of <code>DI.AbstractADType</code>.</li></ul><p><strong>Constructor</strong></p><ul><li>The default constructor allows specifying the backend via the <code>regressorADBackend</code>   keyword argument, defaulting to <code>DI.AutoMooncake()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/VJPTypes.jl#L37-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.DiffusivityRegularization-api"><a class="docstring-binding" href="#ODINN.DiffusivityRegularization-api"><code>ODINN.DiffusivityRegularization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiffusivityRegularization(; reg = TikhonovRegularization())</code></pre><p>Regularization for diffusivity fields using a specified spatial operator.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>reg::AbstractSimpleRegularization = TikhonovRegularization()</code>: Spatial regularization operator applied to diffusivity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L88-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.DiscreteAdjoint-api"><a class="docstring-binding" href="#ODINN.DiscreteAdjoint-api"><code>ODINN.DiscreteAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiscreteAdjoint{
    VJP &lt;: AbstractVJPMethod,
    MBVJP &lt;: AbstractVJPMethod,
} &lt;: AbstractAdjointMethod</code></pre><p>Discrete adjoint of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><strong>Fields</strong></p><ul><li><code>VJP_method</code>: Type of AbstractVJPMethod used to compute VJPs inside adjoint   calculation.</li><li><code>MB_VJP::MBVJP</code>: Type of AbstractVJPMethod used to compute the MB VJP inside adjoint   calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/AdjointTypes.jl#L68-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.DiscreteVJP-api"><a class="docstring-binding" href="#ODINN.DiscreteVJP-api"><code>ODINN.DiscreteVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiscreteVJP{ADTYPE &lt;: DI.AbstractADType} &lt;: AbstractVJPMethod</code></pre><p>Discrete manual implementation of the VJP required inside the adjoint calculation. This implements the pullback function for the function to differentiate.</p><p><strong>Fields</strong></p><ul><li><code>regressorADBackend::ADTYPE</code>: Specifies the AD backend used for the laws when   their associated VJPs functions are not provided. The type parameter <code>ADTYPE</code>   must be a subtype of <code>DI.AbstractADType</code>.</li></ul><p><strong>Constructor</strong></p><ul><li>The default constructor allows specifying the backend via the <code>regressorADBackend</code>   keyword argument, defaulting to <code>DI.AutoMooncake()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/VJPTypes.jl#L12-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.DummyAdjoint-api"><a class="docstring-binding" href="#ODINN.DummyAdjoint-api"><code>ODINN.DummyAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to provide a dummy gradient. It does not have to be the true gradient. Mainly used to test that the optimization pileline works independenly of the gradient calculation.</p><p><code>DummyAdjoint</code></p><p><strong>Fields:</strong></p><ul><li><code>grad::Function</code>: In-place function <code>f(du, u; kwargs)</code> that fills the first   argument <code>du</code> with the gradient values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/AdjointTypes.jl#L91-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.EnzymeVJP-api"><a class="docstring-binding" href="#ODINN.EnzymeVJP-api"><code>ODINN.EnzymeVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Enzyme implementation of VJP used inside the adjoint calculation.</p><p><code>EnzymeVJP</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/VJPTypes.jl#L63-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.FunctionalModel-api"><a class="docstring-binding" href="#ODINN.FunctionalModel-api"><code>ODINN.FunctionalModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FunctionalModel &lt;: TrainableModel</code></pre><p>Abstract type representing functional learnable components of the model. This is a subtype of <code>TrainableModel</code>. Typically used for functional inversions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/Model.jl#L27-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.GlacierWideInv-api"><a class="docstring-binding" href="#ODINN.GlacierWideInv-api"><code>ODINN.GlacierWideInv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlacierWideInv{
    ComponentVectorType &lt;: ComponentVector
} &lt;: PerGlacierModel</code></pre><p>Per glacier invertible parameter container. <code>GlacierWideInv</code> wraps a ComponentVector (θ) that stores one scalar parameter per glacier and implements the <code>PerGlacierModel</code> interface used by the inversion machinery.</p><p><strong>Fields</strong></p><ul><li><code>θ::ComponentVectorType</code>: The per glacier parameter vector (one scalar value per glacier).</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GlacierWideInv(
    params::Sleipnir.Parameters,
    glaciers::Vector{&lt;: AbstractGlacier},
    var::Symbol,
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: Parameters struct.</li><li><code>glaciers::Vector{&lt;: AbstractGlacier}</code>: Vector of AbstractGlacier. The i-th entry in θ corresponds to glaciers[i].</li><li><code>var::Symbol</code>: Symbol naming the field on each glacier to use as the initial value.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">GlacierWideInv(params, glaciers, :A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/GlacierWideInv.jl#L3-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.GriddedInv-api"><a class="docstring-binding" href="#ODINN.GriddedInv-api"><code>ODINN.GriddedInv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GriddedInv{
    ComponentVectorType &lt;: ComponentVector
} &lt;: PerGlacierModel</code></pre><p>Per glacier invertible parameter container. <code>GriddedInv</code> wraps a ComponentVector (θ) that stores one matrix parameter per glacier and implements the <code>PerGlacierModel</code> interface used by the inversion machinery.</p><p><strong>Fields</strong></p><ul><li><code>θ::ComponentVectorType</code>: The per glacier parameter vector (one matrix per glacier).</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GriddedInv(
    params::Sleipnir.Parameters,
    glaciers::Vector{&lt;: AbstractGlacier},
    var::Symbol,
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: Parameters struct.</li><li><code>glaciers::Vector{&lt;: AbstractGlacier}</code>: Vector of AbstractGlacier. The i-th entry in θ corresponds to glaciers[i].</li><li><code>var::Symbol</code>: Symbol naming the field on each glacier to use as the initial value.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">GriddedInv(params, glaciers, :A)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/GriddedInv.jl#L3-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Hyperparameters-Tuple{}-api"><a class="docstring-binding" href="#ODINN.Hyperparameters-Tuple{}-api"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Hyperparameters(; current_epoch::Int64 = 1, current_minibatch::Int64 = 1, loss_history::Vector{Float64} = Vector{Float64}(), optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule} = BFGS(initial_stepnorm=0.001), loss_epoch::Float64 = 0.0, epochs::Int64 = 50, batch_size::Int64 = 15)</code></pre><p>Constructs a <code>Hyperparameters</code> object with the specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>current_epoch::Int64</code>: The current epoch number. Defaults to 1.</li><li><code>current_minibatch::Int64</code>: The current minibatch number. Defaults to 1.</li><li><code>loss_history::Vector{Float64}</code>: A vector to store the history of loss values. Defaults to an empty vector.</li><li><code>optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}</code>: The optimizer to be used. Defaults to <code>BFGS(initial_stepnorm=0.001)</code>.</li><li><code>loss_epoch::Float64</code>: The loss value for the current epoch. Defaults to 0.0.</li><li><code>epochs::Int64</code>: The total number of epochs. Defaults to 50.</li><li><code>batch_size::Int64</code>: The size of each minibatch. Defaults to 15.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hyperparameters</code> object initialized with the provided values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/Hyperparameters.jl#L28-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Hyperparameters-api"><a class="docstring-binding" href="#ODINN.Hyperparameters-api"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Hyperparameters{F &lt;: AbstractFloat, I &lt;: Integer} &lt;: AbstractParameters</code></pre><p>A mutable struct that holds hyperparameters for training a machine learning model.</p><p><strong>Keyword arguments</strong></p><ul><li><code>current_epoch::I</code>: The current epoch number.</li><li><code>current_minibatch::I</code>: The current minibatch number.</li><li><code>loss_history::Vector{F}</code>: A vector storing the history of loss values.</li><li><code>optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}</code>: The optimizer used for training.</li><li><code>loss_epoch::F</code>: The loss value for the current epoch.</li><li><code>epochs::I</code>: The total number of epochs for training.</li><li><code>batch_size::I</code>: The size of each minibatch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/Hyperparameters.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.InitialCondition-api"><a class="docstring-binding" href="#ODINN.InitialCondition-api"><code>ODINN.InitialCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitialCondition{
    ComponentVectorType &lt;: ComponentVector
} &lt;: PerGlacierModel</code></pre><p>Per glacier initial condition container. <code>InitialCondition</code> wraps a ComponentVector (θ) that stores one matrix per glacier and implements the <code>InitialCondition</code> interface used by the inversion machinery.</p><p><strong>Fields</strong></p><ul><li><code>θ::ComponentVectorType</code>: The per glacier matrix of initial condition.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InitialCondition(
    params::Sleipnir.Parameters,
    glaciers::Vector{&lt;: AbstractGlacier},
    initialization::Symbol = :Farinotti2019,
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: Parameters struct.</li><li><code>glaciers::Vector{&lt;: AbstractGlacier}</code>: Vector of AbstractGlacier. The i-th entry in θ corresponds to glaciers[i].</li><li><code>initialization::Symbol</code>: Symbol providing the way the initial condition should be initialized.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">InitialCondition(params, glaciers, :Farinotti2019)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/InitialCondition.jl#L6-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.InitialThicknessRegularization-api"><a class="docstring-binding" href="#ODINN.InitialThicknessRegularization-api"><code>ODINN.InitialThicknessRegularization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitialThicknessRegularization(; reg = TikhonovRegularization(), t₀ = 1994.0)</code></pre><p>A composite regularization type designed for initial ice thickness. It combines a simple spatial regularization (e.g., <code>TikhonovRegularization</code>) with a reference initial time.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>reg::AbstractSimpleRegularization = TikhonovRegularization()</code>: The spatial regularization operator applied to the initial field. By default, a Tikhonov (Laplacian-based) regularization is used.</li><li><code>t₀::AbstractFloat = 1994.0</code>: The reference initial time (e.g., year) at which the regularization applies.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L44-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Inversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G&lt;:AbstractGlacier, M&lt;:Sleipnir.Model, P&lt;:Sleipnir.Parameters}-api"><a class="docstring-binding" href="#ODINN.Inversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G&lt;:AbstractGlacier, M&lt;:Sleipnir.Model, P&lt;:Sleipnir.Parameters}-api"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function Inversion(
    model::M,
    glaciers::Vector{G},
    parameters::P
) where {G &lt;: Sleipnir.AbstractGlacier, M &lt;: Sleipnir.Model, P &lt;: Sleipnir.Parameters}</code></pre><p>Constructor for Inversion struct with glacier model information, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Inversion</code>: A new instance of the Inversion struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/Inversion.jl#L23-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Inversion-api"><a class="docstring-binding" href="#ODINN.Inversion-api"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Inversion{MODEL, CACHE, GLACIER, RES} &lt;: Simulation</code></pre><p>An object representing an inversion simulation. It can involve at the same time a classical inversion and a functional inversion (i.e. the inversion of a function using some data-driven regressor).</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li><li><code>results::ODINN.Results</code>: A <code>ODINN.Results</code> instance to store the results of the inversion and of the forward simulations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/Inversion.jl#L3-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.InversionBinder-api"><a class="docstring-binding" href="#ODINN.InversionBinder-api"><code>ODINN.InversionBinder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InversionBinder{FI &lt;: Inversion, CA &lt;: ComponentArray}</code></pre><p>Struct used for the binding with SciMLSensitivity. It is defined as a SciMLStructure and it contains the inversion structure and the vector of parameters to differentiate.</p><p><strong>Fields</strong></p><ul><li><code>simulation::FI</code>: Inversion instance.</li><li><code>θ::CA</code>: ComponentArray that contains the parameters used to differentiate the iceflow.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/sciml_utils.jl#L10-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}(;
    initial_conditions::Vector{F} = [1.0],
    lower_bound::Vector{F} = [0.0],
    upper_bound::Vector{F} = [Inf],
    regions_split::Vector{Int} = [1, 1],
    x_tol::F = 1.0e-3,
    f_tol::F = 1.0e-3,
    solver = BFGS()
)</code></pre><p>Initialize the parameters for the inversion process.</p><p><strong>Arguments</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: Starting point for optimization.</li><li><code>lower_bound::Vector{F}</code>: Lower bounds for optimization variables.</li><li><code>upper_bound::Vector{F}</code>: Upper bounds for optimization variables.</li><li><code>regions_split::Vector{Int}</code>: Defines the amount of region split based on altitude and distance to border for the inversion process.</li><li><code>x_tol::F</code>: Tolerance for variables convergence.</li><li><code>f_tol::F</code>: Tolerance for function value convergence.</li><li><code>solver</code>: Optimization solver to be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/InversionParameters.jl#L27-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.InversionParameters-api"><a class="docstring-binding" href="#ODINN.InversionParameters-api"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}</code></pre><p>A mutable struct that holds parameters for inversion processes. This struct is a subtype of <code>AbstractParameters</code>.</p><p><strong>Fields</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: A vector of initial conditions.</li><li><code>lower_bound::Vector{F}</code>: A vector specifying the lower bounds for the parameters.</li><li><code>upper_bound::Vector{F}</code>: A vector specifying the upper bounds for the parameters.</li><li><code>regions_split::Vector{Int}</code>: A vector indicating how the regions are split.</li><li><code>x_tol::F</code>: The tolerance for the solution&#39;s x-values.</li><li><code>f_tol::F</code>: The tolerance for the function values.</li><li><code>solver::Any</code>: The solver to be used for the inversion process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/InversionParameters.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.L2Sum-api"><a class="docstring-binding" href="#ODINN.L2Sum-api"><code>ODINN.L2Sum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">L2Sum{I &lt;: Integer} &lt;: AbstractSimpleLoss</code></pre><p>Struct that defines an L2 sum loss. The sum is defined only on pixels inside the glacier. The parameter <code>distance</code> controls the pixels that should be used to compute the sum. In order for a pixel to be used, it should be at least at <code>distance</code> from the glacier border. The mask defining the glacier borders are computed using the ground truth ice thickness.</p><p><span>$loss(a,b) = sum_{i\in\text{mask}} (a[i]-b[i])^2 / normalization$</span></p><p><strong>Fields</strong></p><ul><li><code>distance::I</code>: Distance to border.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Losses.jl#L14-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LogSum-api"><a class="docstring-binding" href="#ODINN.LogSum-api"><code>ODINN.LogSum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogSum{I &lt;: Integer, F &lt;: AbstractFloat} &lt;: AbstractSimpleLoss</code></pre><p>Struct that defines a Logarithmic sum loss.</p><p><span>$loss(a,b) = log^2( (a + ϵ) / (b + ϵ) ) / normalization$</span></p><p><strong>Fields</strong></p><ul><li><code>distance::I</code>: Distance to border.</li><li><code>ϵ::F</code>: Epsilon used inside the loss function to handle division by zero and log(0).   It somehow represents the minimum value the loss function should be sensible to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Losses.jl#L32-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LossH-api"><a class="docstring-binding" href="#ODINN.LossH-api"><code>ODINN.LossH</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LossH{L &lt;: AbstractSimpleLoss} &lt;: AbstractLoss</code></pre><p>Struct that defines the ice thickness loss.</p><p><strong>Fields</strong></p><ul><li><code>loss::L</code>: Type of loss to use for the ice thickness. Default is <code>L2Sum()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Losses.jl#L49-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LossHV-api"><a class="docstring-binding" href="#ODINN.LossHV-api"><code>ODINN.LossHV</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LossHV{
    F &lt;: AbstractFloat,
    LH &lt;: AbstractLoss,
    LV &lt;: AbstractLoss,
} &lt;: AbstractLoss</code></pre><p>Struct that defines the ice thickness and ice velocity loss. It consists of two fields that define the ice thickness and ice velocity loss. It also has a scaling coefficient that balances the ice velocity term in the loss.</p><p><span>$loss(\hat H,H) = loss_H(\hat H,H) + scaling * loss_V(\hat V,V)$</span></p><p>with <span>$\hat V$</span> computed from <span>$\hat H$</span> for the SIA.</p><p><strong>Fields</strong></p><ul><li><code>hLoss::LH</code>: Type of loss to use for the ice thickness. Default is <code>LossH()</code>.</li><li><code>vLoss::LV</code>: Type of loss to use for the ice velocity. Default is <code>LossV()</code>.</li><li><code>scaling::F</code>: Scaling of the ice velocity term. Default is <code>1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Losses.jl#L79-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LossV-api"><a class="docstring-binding" href="#ODINN.LossV-api"><code>ODINN.LossV</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LossV{L &lt;: AbstractSimpleLoss} &lt;: AbstractLoss</code></pre><p>Struct that defines the ice velocity loss.</p><p><strong>Fields</strong></p><ul><li><code>loss::L</code>: Type of loss to use for the ice velocity. Default is <code>L2Sum()</code>.</li><li><code>component::Symbol</code>: Component of the velocity field used in the loss.   Options include :xy for both x and y component, and :abs for the norm/magnitude of the velocity.</li><li><code>scale_loss::Bool</code>: Whether to scale the loss function with the reference ice   velocity magnitude.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Losses.jl#L61-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.MatrixCacheGlacierId-api"><a class="docstring-binding" href="#ODINN.MatrixCacheGlacierId-api"><code>ODINN.MatrixCacheGlacierId</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MatrixCacheGlacierId &lt;: Cache</code></pre><p>A cache structure for storing a matrix value (<code>Float64</code> 2D array) along with their associated vector-Jacobian products (VJP). It also stores the glacier ID as an integer. This is typically used to invert a spatially varying field per glacier. Fields:</p><ul><li><code>value::Array{Float64, 2}</code>: The cached matrix value.</li><li><code>vjp_inp::Array{Float64, 2}</code>: VJP with respect to inputs.</li><li><code>vjp_θ::Vector{Float64}</code>: VJP with respect to parameters.</li><li><code>glacier_id::Int64</code>: Glacier ID in the list of simulated glaciers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Cache.jl#L63-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.MatrixCacheInterp-api"><a class="docstring-binding" href="#ODINN.MatrixCacheInterp-api"><code>ODINN.MatrixCacheInterp</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MatrixCacheInterp(nodes_H, nodes_∇S, interp_θ)</code></pre><p>A mutable cache structure for storing interpolation data on a 2D grid, used to efficiently evaluate and reuse interpolated matrices and their gradients. This interpolation makes complex inversions feasible since it allows the precomputation of all gradients before the solving the reverse PDE associated to the adjoint variable.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{Float64, 2}</code>: Matrix to store value of the diffusivity.</li><li><code>nodes_H::Vector{Float64}</code>: Grid nodes corresponding to the first interpolation dimension, typically representing values of ice thickness <code>H</code>.</li><li><code>nodes_∇S::Vector{Float64}</code>: Grid nodes corresponding to the second interpolation dimension, typically representing absolute values of slope <code>∇S</code>.</li><li><code>interp_θ::Interpolations.GriddedInterpolation{Vector{Float64}, 2, Matrix{Vector{Float64}}, Interpolations.Gridded{InterPolations.Linear{InterPolations.Throw{OnGrid}}}, Tuple{Vector{Float64}, Vector{Float64}}}</code>: A gridded linear interpolation object mapping <code>(nodes_H, nodes_∇S)</code> to parameter vectors <code>θ</code>. Used to compute interpolated parameters and enable fast evaluation during repeated model calls.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Cache.jl#L6-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.MultiLoss-api"><a class="docstring-binding" href="#ODINN.MultiLoss-api"><code>ODINN.MultiLoss</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiLoss(; losses = (L2Sum(),), λs = (1.0,))</code></pre><p>Combines multiple loss functions into a single weighted objective.</p><p><code>MultiLoss</code> enables composing several individual loss terms—each possibly representing a different physical constraint, data fidelity term, or regularization penalty—into a single differentiable loss function.</p><p><strong>Keyword Arguments (Constructor)</strong></p><ul><li><code>losses::Tuple = (L2Sum(),)</code>: A tuple of loss objects (each subtype of <code>AbstractLoss</code>) to be combined.</li><li><code>λs::Tuple = (1.0,)</code>:  A tuple of scalar weights or hyperparameters corresponding to each loss term.</li></ul><p><strong>Fields (Struct)</strong></p><ul><li><code>losses::TL</code>: Tuple of loss functions.</li><li><code>λs::TS</code>: Tuple of weighting coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/MultiLoss.jl#L3-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.NeuralNetwork-api"><a class="docstring-binding" href="#ODINN.NeuralNetwork-api"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NeuralNetwork{
    ChainType &lt;: Lux.Chain,
    ComponentVectorType &lt;: ComponentVector,
    NamedTupleType &lt;: NamedTuple,
} &lt;: FunctionalModel</code></pre><p>Feed-forward neural network.</p><p><strong>Fields</strong></p><ul><li><code>architecture::ChainType</code>: <code>Flux.Chain</code> neural network architecture</li><li><code>θ::ComponentVectorType</code>: Neural network parameters</li><li><code>st::NamedTupleType</code>: Neural network status</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/NeuralNetwork.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.NoVJP-api"><a class="docstring-binding" href="#ODINN.NoVJP-api"><code>ODINN.NoVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>No VJP flavor when the contribution of a given term should not be computed inside the adjoint calculation (e.g. MB).</p><p><code>NoVJP</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/VJPTypes.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.PerGlacierModel-api"><a class="docstring-binding" href="#ODINN.PerGlacierModel-api"><code>ODINN.PerGlacierModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PerGlacierModel &lt;: TrainableModel</code></pre><p>Abstract type representing per glacier optimizable components of the model. This is a subtype of <code>TrainableModel</code>. Typically used for classical inversions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/Model.jl#L18-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Results-api"><a class="docstring-binding" href="#ODINN.Results-api"><code>ODINN.Results</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Results{RES &lt;: Sleipnir.Results, STAT &lt;: TrainingStats}</code></pre><p>Mutable struct containing the results of an inversion. This object stores both the results of the optimization through <code>TrainingStats</code> and the simulation results of the forward evaluations using the optimized variables through <code>Sleipnir.Results</code>. It expands the functionalities offered by <code>Sleipnir.Results</code> to allow saving the results of an inversion. Multiple dispatch is used to select either <code>Sleipnir.Results</code> or <code>ODINN.Results</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>simulation::Vector{RES}</code>: Vector of <code>Sleipnir.Results</code> representing the results of a forward evaluation for each glacier.</p></li><li><p><code>stats::STAT</code>: Training statistics gathered during the optimization.</p><p>function Results(       simulation::Vector{&lt;: Sleipnir.Results},       stats::TrainingStats,   )</p></li></ul><p>Constructor for the <code>Results</code> object used to track statistics during training and the results of the forward evaluations simulated with the optimized variables.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Vector{&lt;: Sleipnir.Results}</code>: Vector of <code>Sleipnir.Results</code> associated to the forward simulation of each glacier.</li><li><code>stats::TrainingStats</code>: Training statistics.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/results/Results.jl#L69-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.RheologyRegularization-api"><a class="docstring-binding" href="#ODINN.RheologyRegularization-api"><code>ODINN.RheologyRegularization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RheologyRegularization(; reg = TikhonovRegularization())</code></pre><p>Regularization of the gridded rheology <code>A</code> in the context of classical inversions. It can include a spatial smoothing operator through the field <code>reg</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>reg::AbstractSimpleRegularization = TikhonovRegularization()</code>: Spatial regularization operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L75-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.SIA2D_D_target-api"><a class="docstring-binding" href="#ODINN.SIA2D_D_target-api"><code>ODINN.SIA2D_D_target</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SIA2D_D_target(; interpolation=:None, n_interp_half=20,
                 prescale=nothing, postscale=nothing)</code></pre><p>Inversion of general diffusivity as a function of physical parameters.</p><p>D(H, ∇S, θ) = H * NN(H, ∇S; θ)</p><p>So now we are learning the velocity field given by D * ∇S. This inversion is similar to learnign the velocity field assuming that this is parallel to the gradient in surface ∇S.</p><p><strong>Arguments</strong></p><ul><li><code>interpolation::Symbol = :None</code>: Specifies the interpolation method. Options include <code>:Linear</code>, <code>:None</code>.</li><li><code>n_interp_half::Int = 20</code>: Half-width of the interpolation stencil. Determines resolution of interpolation.</li><li><code>prescale::Union{Fin, Nothing} = nothing</code>: Optional prescaling function or factor applied before parametrization. Must be of type <code>Fin</code> or <code>nothing</code>.</li><li><code>postscale::Union{Fout, Nothing} = nothing</code>: Optional postscaling function or factor applied after parametrization. Must be of type <code>Fout</code> or <code>nothing</code>.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>Fin</code>: Type of the prescale function or operator.</li><li><code>Fout</code>: Type of the postscale function or operator.</li></ul><p><strong>Supertype</strong></p><ul><li><code>AbstractSIA2DTarget</code>: Inherits from the abstract target type for 2D SIA modeling.</li></ul><p><strong>Returns</strong></p><ul><li>An instance of <code>SIA2D_D_target</code> configured with optional scaling and interpolation parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_D_pure.jl#L3-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.ScalarCacheGlacierId-api"><a class="docstring-binding" href="#ODINN.ScalarCacheGlacierId-api"><code>ODINN.ScalarCacheGlacierId</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ScalarCacheGlacierId &lt;: Cache</code></pre><p>A cache structure for storing a scalar value as a zero-dimensional array of <code>Float64</code> along with their associated vector-Jacobian products (VJP). It also stores the glacier ID as an integer. This is typically used to invert a single scalar per glacier. Fields:</p><ul><li><code>value::Array{Float64, 0}</code>: The cached scalar value.</li><li><code>vjp_inp::Array{Float64, 0}</code>: VJP with respect to inputs. Must be defined but never used in   practice since this cache is used for classical inversions and the law does not have inputs.</li><li><code>vjp_θ::Vector{Float64}</code>: VJP with respect to parameters.</li><li><code>glacier_id::Int64</code>: Glacier ID in the list of simulated glaciers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Cache.jl#L39-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.SciMLSensitivityAdjoint-api"><a class="docstring-binding" href="#ODINN.SciMLSensitivityAdjoint-api"><code>ODINN.SciMLSensitivityAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct that defines the SciMLSensitivity adjoint flavor. This is the default behavior in ODINN.</p><p><code>SciMLSensitivityAdjoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/AdjointTypes.jl#L18-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.TikhonovRegularization-api"><a class="docstring-binding" href="#ODINN.TikhonovRegularization-api"><code>ODINN.TikhonovRegularization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TikhonovRegularization(; operator = :laplacian, distance = 3)</code></pre><p>A simple regularization type implementing Tikhonov regularization (also known as ridge regularization) for inverse problems.</p><p>This struct includes both the forward and reverse (adjoint) operators, which are required for the computation of the gradients with respect to the model parameters.</p><p><strong>Keyword Arguments (Constructor)</strong></p><ul><li><code>operator::Symbol = :laplacian</code>: The regularization operator to use. Currently, only <code>:laplacian</code> is implemented, which penalizes large gradients by applying the Laplacian operator.</li><li><code>distance::Integer = 3</code>: A width parameter to determine how far from the margin evaluate the loss.</li></ul><p><strong>Fields (Struct)</strong></p><ul><li><code>operator_forward::Function</code>: The forward regularization operator (e.g., <code>∇²</code>).</li><li><code>operator_reverse::Function</code>: The reverse-mode (VJP) of the operator (e.g., <code>VJP_λ_∂∇²a_∂a</code>).</li><li><code>distance::Integer</code>: The distance parameter controlling the extent of regularization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L12-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><a class="docstring-binding" href="#ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><code>ODINN.TrainingStats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TrainingStats(;
    retcode::Union{String, Nothing} = nothing,
    losses::Vector{F} = Float64[],
    niter::I = 0,
    θ::Union{ComponentVector, Nothing} = nothing,
    θ_hist::Union{Vector{ComponentVector}, Nothing} = ComponentVector[],
    ∇θ_hist::Union{Vector{ComponentVector}, Nothing} = ComponentVector[]
) where {F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>Constructor for TrainingStats object used to store important information during training.</p><p><strong>Arguments</strong></p><ul><li><code>retcode</code>: Report code of the optimization.</li><li><code>losses</code>: Vector storing the value of the loss function at each iteration.</li><li><code>niter</code>: Total number of iterations/epochs.</li><li><code>θ</code>: Parameters of neural network after training</li><li><code>θ_hist</code>: History of parameters of neural network during training</li><li><code>∇θ_hist</code>: History of gradients training</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/results/Results.jl#L29-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.TrainingStats-api"><a class="docstring-binding" href="#ODINN.TrainingStats-api"><code>ODINN.TrainingStats</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct TrainingStats{F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>An object with the information of the training.</p><p><strong>Fields</strong></p><ul><li><code>retcode::Union{String, Nothing}</code>: Report code of the optimization.</li><li><code>losses::Vector{F}</code>: Vector storing the value of the loss function at each iteration.</li><li><code>niter::I</code>: Total number of iterations/epochs.</li><li><code>θ::Union{&lt;: ComponentVector, Nothing}</code>: Parameters of neural network after training</li><li><code>θ_hist::Vector{&lt;: ComponentVector}</code>: History of parameters of neural network during training</li><li><code>∇θ_hist::Vector{&lt;: ComponentVector}</code>: History of gradients training</li><li><code>lastCall::DateTime</code>: Last time the callback diagnosis was called.   This is used to compute the time per iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/results/Results.jl#L3-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ&lt;:AbstractAdjointMethod-api"><a class="docstring-binding" href="#ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ&lt;:AbstractAdjointMethod-api"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UDEparameters(; sensealg, optim_autoAD, grad, optimization_method, empirical_loss_function, target) where {ADJ &lt;: AbstractAdjointMethod}</code></pre><p>Create a <code>UDEparameters</code> object for configuring the sensitivity analysis and optimization of a Universal Differential Equation (UDE).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm</code>: The sensitivity algorithm to use for adjoint calculations. Defaults to <code>GaussAdjoint(autojacvec=SciMLSensitivity.EnzymeVJP())</code>.</li><li><code>optim_autoAD::AbstractADType</code>: The automatic differentiation type for optimization. Defaults to <code>Optimization.AutoEnzyme()</code>.</li><li><code>grad::ADJ</code>: The adjoint gradient computation method. Defaults to <code>ContinuousAdjoint()</code>.</li><li><code>optimization_method::String</code>: The optimization method to use. Must be either <code>&quot;AD+AD&quot;</code> or <code>&quot;AD+Diff&quot;</code>. Defaults to <code>&quot;AD+AD&quot;</code>.</li><li><code>empirical_loss_function::AbstractLoss</code>: The loss function to use for optimization. Defaults to <code>LossH()</code>.</li><li><code>target::Union{Symbol, Nothing}</code>: The target variable for optimization. Defaults to <code>:A</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UDEparameters</code> object configured with the specified sensitivity, optimization, and loss settings.</li></ul><p><strong>Description</strong></p><p>This function creates a <code>UDEparameters</code> object that encapsulates the configuration for sensitivity analysis, optimization, and loss computation in a Universal Differential Equation (UDE) framework. It verifies that the provided <code>optimization_method</code> is valid and constructs the solver parameters accordingly.</p><p><strong>Notes</strong></p><ul><li>The <code>optimization_method</code> must be either <code>&quot;AD+AD&quot;</code> (automatic differentiation for both forward and backward passes) or <code>&quot;AD+Diff&quot;</code> (automatic differentiation combined with finite differences).</li><li>The <code>empirical_loss_function</code> determines how the loss is computed during optimization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/UDEparameters.jl#L31-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.UDEparameters-api"><a class="docstring-binding" href="#ODINN.UDEparameters-api"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A mutable struct that holds parameters for a UDE (Universal Differential Equation).</p><pre><code class="nohighlight hljs">UDEparameters{ADJ &lt;: AbstractAdjointMethod} &lt;: AbstractParameters</code></pre><p><strong>Fields</strong></p><ul><li><code>sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm</code>: The sensitivity algorithm used for adjoint sensitivity analysis.</li><li><code>optimization_method::String</code>: The optimization method to be used.</li><li><code>target::Symbol</code>: The target variable for the optimization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/UDEparameters.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VJPsPrepLaw-api"><a class="docstring-binding" href="#ODINN.VJPsPrepLaw-api"><code>ODINN.VJPsPrepLaw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VJPsPrepLaw &lt;: AbstractPrepVJP</code></pre><p>A container struct that holds all objects needed to compute vector-Jacobian products (VJPs) for a law using DifferentiationInterface.</p><p>Fields:</p><ul><li><code>f_θ_first</code>: Function to evaluate the law with parameters θ as the first argument.</li><li><code>f_inp_first</code>: Function to evaluate the law with inputs as the first argument.</li><li><code>prep_θ</code>: Precomputed gradient preparation for parameters θ.</li><li><code>prep_inp</code>: Precomputed gradient preparation for inputs.</li></ul><p>This struct is used to prepare the VJP computation with DifferentiationInterface (DI). Depending on the AD backend, DI might require to precompile code and this struct stores the results. This allows each VJP call to be fast in the adjoint PDE by reusing the preparation results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/auto_VJP.jl#L3-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VelocityRegularization-api"><a class="docstring-binding" href="#ODINN.VelocityRegularization-api"><code>ODINN.VelocityRegularization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelocityRegularization(; reg = TikhonovRegularization(), components = :abs, distance = 3)</code></pre><p>Regularization for velocity fields, combining a spatial smoothing operator with optional component control.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>reg::AbstractSimpleRegularization = TikhonovRegularization()</code>: Spatial regularization operator.</li><li><code>components::Symbol = :abs</code>: Determines which velocity components to regularize (e.g. <code>:abs</code>, <code>:x</code>, <code>:y</code>).</li><li><code>distance::Integer = 3</code>: Distance to glacier margin.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L59-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copyto!-Union{Tuple{CA}, Tuple{FI}, Tuple{InversionBinder{FI, CA}, InversionBinder{FI, CA}}} where {FI&lt;:Inversion, CA&lt;:ComponentArrays.ComponentArray}-api"><a class="docstring-binding" href="#Base.copyto!-Union{Tuple{CA}, Tuple{FI}, Tuple{InversionBinder{FI, CA}, InversionBinder{FI, CA}}} where {FI&lt;:Inversion, CA&lt;:ComponentArrays.ComponentArray}-api"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copyto!(
    dest::InversionBinder{FI, CA},
    src::InversionBinder{FI, CA},
) where {FI &lt;: Inversion, CA &lt;: ComponentArray}</code></pre><p>Overload Base.copyto! as we need a way to copy the SciMLStructure. It is used in SciMLSensitivity to differentiate the callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/sciml_utils.jl#L85-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{InversionBinder{FI, CA}}, Tuple{CA}, Tuple{FI}} where {FI&lt;:Inversion, CA&lt;:ComponentArrays.ComponentArray}-api"><a class="docstring-binding" href="#Base.zero-Union{Tuple{InversionBinder{FI, CA}}, Tuple{CA}, Tuple{FI}} where {FI&lt;:Inversion, CA&lt;:ComponentArrays.ComponentArray}-api"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(
    p::InversionBinder{FI, CA},
) where {FI &lt;: Inversion, CA &lt;: ComponentArray}</code></pre><p>Overload Base.zero as we need a way to copy the SciMLStructure. It is used in SciMLSensitivity to differentiate the callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/sciml_utils.jl#L71-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.precompute_all_VJPs_laws!-Tuple{SIA2Dmodel, SIA2DCache, Inversion, Integer, Real, Any}-api"><a class="docstring-binding" href="#Huginn.precompute_all_VJPs_laws!-Tuple{SIA2Dmodel, SIA2DCache, Inversion, Integer, Real, Any}-api"><code>Huginn.precompute_all_VJPs_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">precompute_all_VJPs_laws!(
    SIA2D_model::SIA2Dmodel,
    SIA2D_cache::SIA2DCache,
    simulation::Inversion,
    glacier_idx::Integer,
    t::Real,
    θ,
)</code></pre><p>Precomputes the vector-Jacobian products (VJPs) for all laws used in the SIA2D ice flow model for a given glacier, time, and model parameters.</p><p>Depending on which target (<code>U</code>, <code>Y</code>, or neither) is provided in <code>SIA2D_model</code>, this function checks if the corresponding law supports VJP precomputation and, if so, triggers the appropriate precompute routine for that law. If neither <code>U</code> nor <code>Y</code> is provided, precomputes VJPs for the <code>A</code>, <code>C</code>, and <code>n</code> laws.</p><p><strong>Arguments</strong></p><ul><li><code>SIA2D_model::SIA2Dmodel</code>: The model containing the configuration and   laws used for SIA2D ice flow.</li><li><code>SIA2D_cache::SIA2DCache</code>: A cache object holding intermediate values   and storage relevant for precomputations.</li><li><code>simulation::Inversion</code>: Simulation object containing global simulation parameters.</li><li><code>glacier_idx::Integer</code>: Index of the glacier being simulated.</li><li><code>t::Real</code>: Current time in the simulation.</li><li><code>θ</code>: Model parameters or state variables for the simulation step.</li></ul><p><strong>Notes</strong></p><ul><li>This routine is intended as a preparatory step for manual adjoint.</li><li>Only laws supporting VJP precomputation are processed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L591-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.run!-Tuple{Inversion}-api"><a class="docstring-binding" href="#Huginn.run!-Tuple{Inversion}-api"><code>Huginn.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(simulation::Inversion)</code></pre><p>Run the training process for a given <code>Inversion</code> simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Inversion</code>: The simulation object containing the parameters and settings for the inversion process.</li></ul><p><strong>Description</strong></p><p>This function initiates the training of a Universal Differential Equation (UDE) for the provided simulation. It prints a message indicating the start of the training process, calls the <code>train_UDE!</code> function to perform the training, and collects the results in <code>results_list</code>. The results are intended to be saved using <code>Sleipnir.save_results_file!</code>, but this step is currently commented out and will be enabled once the optimization is working. Finally, the garbage collector is triggered to free up memory.</p><p><strong>Notes</strong></p><ul><li>The <code>Sleipnir.save_results_file!</code> function call is currently commented out and should be enabled once the optimization process is confirmed to be working.</li><li>The garbage collector is explicitly run using <code>GC.gc()</code> to manage memory usage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L3-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.CallbackOptimizationSet-Tuple{Any, Any}-api"><a class="docstring-binding" href="#ODINN.CallbackOptimizationSet-Tuple{Any, Any}-api"><code>ODINN.CallbackOptimizationSet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CallbackOptimizationSet(θ, l; callbacks)</code></pre><p>Helper to combine callbacks for Optimization function. This executes the action of each callback.   (equivalent to CallbackSet for DifferentialEquations.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/callback_utils.jl#L131-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.ComponentVector2Vector-Tuple{ComponentArrays.ComponentVector}-api"><a class="docstring-binding" href="#ODINN.ComponentVector2Vector-Tuple{ComponentArrays.ComponentVector}-api"><code>ODINN.ComponentVector2Vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ComponentVector2Vector(cv::ComponentVector)</code></pre><p>Transform a <code>ComponentVector</code> into a <code>Vector</code> of same length. This function creates a new <code>Vector</code> and does not mutate the original <code>ComponentVector</code>.</p><p>Arguments:</p><ul><li><code>cv::ComponentVector</code>: Input <code>ComponentVector</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L187-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Diffusivity-Tuple{SIA2D_D_target}-api"><a class="docstring-binding" href="#ODINN.Diffusivity-Tuple{SIA2D_D_target}-api"><code>ODINN.Diffusivity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Diffusivity(target::SIA2D_D_target; H, ∇S, θ, iceflow_model, glacier, params)</code></pre><p>Compute the effective diffusivity field for a 2D shallow ice model using the diagnostic <code>target</code> and  a predicted velocity matrix <code>U</code>.</p><p>This function uses a learned or specified model to estimate the velocity matrix <code>U</code>, then calculates the diffusivity as either <code>H .* U</code> (if dimensions match) or the averaged <code>H</code> times <code>U</code> if dimensions differ by one grid cell (staggered grid). Errors if dimensions are incompatible.</p><p><strong>Arguments</strong></p><ul><li><code>target::SIA2D_D_target</code>: Diagnostic target object defining interpolation and scaling rules.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: Ice thickness.</li><li><code>∇S</code>: Ice surface slope.</li><li><code>θ</code>: Parameters of the model.</li><li><code>iceflow_model</code>: Iceflow model used for simulation.</li><li><code>glacier</code>: Glacier data.</li><li><code>params</code>: Model parameters.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix of diffusivity values with the same shape as <code>H</code> or staggered by one cell, depending on <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li>An error if the dimensions of <code>U</code> and <code>H</code> are not compatible for diffusivity calculation.</li></ul><p><strong>Notes</strong></p><p>Supports both grid-matched and staggered configurations by averaging <code>H</code> where necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_D_pure.jl#L39-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.GaussQuadrature-Tuple{Any, Any, Int64}-api"><a class="docstring-binding" href="#ODINN.GaussQuadrature-Tuple{Any, Any, Int64}-api"><code>ODINN.GaussQuadrature</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Gauss Quadratrue for numerical integration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/gradient.jl#L428-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LawA-Tuple{Sleipnir.Parameters}-api"><a class="docstring-binding" href="#ODINN.LawA-Tuple{Sleipnir.Parameters}-api"><code>ODINN.LawA</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LawA(params::Sleipnir.Parameters; scalar::Bool=true)</code></pre><p>Construct a law that defines an ice rheology A per glacier to invert. This can be either a spatially varying A or a scalar value per glacier based on the value of <code>scalar</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: Parameters struct used to retrieve the minimum and   maximum values of A for scaling the parameter to invert.</li><li><code>scalar::Bool</code>: Whether the ice rheology to invert is a scalar per glacier, or a   spatially varying <code>A</code> per glacier (matrix to invert).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Laws.jl#L363-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LawA-api"><a class="docstring-binding" href="#ODINN.LawA-api"><code>ODINN.LawA</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function LawA(
    nn_model::NeuralNetwork,
    params::Sleipnir.Parameters;
    precompute_VJPs::Bool = true,
)</code></pre><p>Constructs a law object for the creep coefficient <code>A</code> in the SIA based on a neural network that takes as input the long term air temperature. The creep coefficient <code>A</code> with this law is a scalar. See also <code>SIA2D_A_target</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nn_model::NeuralNetwork</code>: A neural network model containing the architecture   <code>archi</code> and state <code>st</code> used for evaluation of the law.</li><li><code>params::Sleipnir.Parameters</code>: Parameters struct used to retrieve the minimum and   maximum values of A for scaling of the neural network output.</li><li><code>precompute_VJPs::Bool</code>: If <code>true</code>, enables precomputation of vector-Jacobian   products before solving the adjoint PDE for efficient autodiff.</li></ul><p><strong>Returns</strong></p><ul><li><code>A_law</code>: A <code>Law{ScalarCache}</code> instance that computes the creep coefficient <code>A</code>   based on an input temperature using the neural network. The law scales the   output to the physical bounds defined by <code>params</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The VJP is computed automatically using DifferentiationInterface.</li></ul><p><strong>Details</strong></p><ul><li>The function wraps the architecture and state of the neural network in a<code>StatefulLuxLayer</code>.</li><li>The resulting law takes input variables, applies the neural network, and scales its output   to be between <code>params.physical.minA</code> and <code>params.physical.maxA</code>.</li><li>The in-place assignment to <code>cache</code> is ignored in differentiation to allow gradient   computation with Zygote when using DifferentiationInterface.</li><li>The <code>init_cache</code> function initializes the cache with a scalar zero for the forward   placeholder, and with a vector of zeros for the VJP placeholder.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nn_model = NeuralNetwork(params)
A_law = LawA(nn_model, params; precompute_VJPs=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Laws.jl#L258-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LawU-Tuple{NeuralNetwork, Sleipnir.Parameters}-api"><a class="docstring-binding" href="#ODINN.LawU-Tuple{NeuralNetwork, Sleipnir.Parameters}-api"><code>ODINN.LawU</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LawU(
    nn_model::NeuralNetwork,
    params::Sleipnir.Parameters;
    max_NN::Union{F, Nothing} = 50.0,
    prescale_bounds::Union{Vector{Tuple{F,F}}, Nothing} = [(0.0, 300.0), (0.0, 0.5)],
) where {F &lt;: AbstractFloat}</code></pre><p>Constructs a law object for the diffusive velocity <code>U</code> in the SIA based on a neural network that takes as input the ice thickness <code>H̄</code> and the surface slope <code>∇S</code>. The diffusive velocity <code>U</code> with this law is a matrix and the diffusivity in the SIA is obtained through D = U * H̄. See also <code>SIA2D_D_target</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nn_model::NeuralNetwork</code>: A neural network model containing the architecture   <code>archi</code> and state <code>st</code> used for evaluation of the law.</li><li><code>params::Sleipnir.Parameters</code>: Parameters struct. Not used for the moment but kept   as an argument to keep consistency with other equivalent functions <code>LawA</code> and   <code>LawY</code>.</li><li><code>max_NN::Union{F, Nothing}</code>: Expected maximum value of the neural network output.   If set to <code>nothing</code>, no postscaling is applied.</li><li><code>prescale_bounds::Union{Vector{Tuple{F,F}}, Nothing}</code>: Vector of tuples where each   tuple defines the lower and upper bounds of the input for scaling.   If set to <code>nothing</code>, no prescaling is applied.</li><li><code>precompute_interpolation::Bool</code>: Determines which cache to use depending if interpolation   is used or not for the evaluation of gradients.</li><li><code>precompute_VJPs::Bool</code>: Determines is VJPs are stored in the cache during the reverse   step.</li></ul><p><strong>Returns</strong></p><ul><li><code>U_law</code>: A <code>Law{Array{Float64, 2}}</code> instance that computes the diffusive velocity <code>U</code>   based on the ice thickness <code>H̄</code> and the surface slope <code>∇S</code> using the neural network.   The law scales the output using the <code>max_NN</code> argument.</li></ul><p><strong>Notes</strong></p><ul><li>The computation is compatible with Zygote for automatic differentiation.</li></ul><p><strong>Details</strong></p><ul><li>The function wraps the architecture and state of the neural network in a<code>StatefulLuxLayer</code>.</li><li>The resulting law takes input variables, applies the neural network, and scales its output   to match <code>max_NN</code>.</li><li>The in-place assignment to <code>cache</code> is ignored in differentiation to allow gradient   computation with Zygote.</li><li>The <code>init_cache</code> function initializes the cache with a zero matrix.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nn_model = NeuralNetwork(params)
bounds_H = (0.0, 300.0)
bounds_∇S = (0.0, 0.5)
U_law = LawU(nn_model, params; max_NN = 50.0, prescale_bounds = [bounds_H, bounds_∇S])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Laws.jl#L34-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LawY-Union{Tuple{F}, Tuple{NeuralNetwork, Sleipnir.Parameters}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.LawY-Union{Tuple{F}, Tuple{NeuralNetwork, Sleipnir.Parameters}} where F&lt;:AbstractFloat-api"><code>ODINN.LawY</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LawY(
    nn_model::NeuralNetwork,
    params::Sleipnir.Parameters;
    max_NN::Union{F, Nothing} = nothing,
    prescale_bounds::Vector{Tuple{F,F}} = [(-25.0, 0.0), (0.0, 500.0)],
) where {F &lt;: AbstractFloat}</code></pre><p>Constructs a law object for the hybrid diffusivity <code>Y</code> in the SIA based on a neural network that takes as input the long term air temperature and the ice thickness <code>H̄</code>. The hybrid diffusivity <code>Y</code> with this law is a matrix as it depends on the ice thickness. This law is used in an hybrid setting where the <code>n</code> exponent in the mathematical expression of the diffusivity is different from the one used to generate the ground truth. The goal of this law is to retrieve the missing part of the diffusivity. Please refer to <code>SIA2D_D_hybrid_target</code> for a mathematical definition.</p><p><strong>Arguments</strong></p><ul><li><code>nn_model::NeuralNetwork</code>: A neural network model containing the architecture   <code>archi</code> and state <code>st</code> used for evaluation of the law.</li><li><code>params::Sleipnir.Parameters</code>: Parameters struct used to retrieve the maximum   value of A for scaling of the neural network output.</li><li><code>max_NN::Union{F, Nothing}</code>: Expected maximum value of the neural network output.   If not specified, the law takes as an expected maximum value <code>params.physical.maxA</code>.</li><li><code>prescale_bounds::Vector{Tuple{F,F}}</code>: Vector of tuples where each tuple defines   the lower and upper bounds of the input for scaling.</li></ul><p><strong>Returns</strong></p><ul><li><code>Y_law</code>: A <code>Law{Array{Float64, 2}}</code> instance that computes the hybrid diffusivity <code>Y</code>   based on an input temperature and ice thickness using the neural network. The   law scales the output to the physical bounds defined by <code>params</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The computation is compatible with Zygote for automatic differentiation.</li></ul><p><strong>Details</strong></p><ul><li>The function wraps the architecture and state of the neural network in a<code>StatefulLuxLayer</code>.</li><li>The resulting law takes input variables, applies the neural network, and scales its output   to match the maximum value which is either <code>max_NN</code> or <code>params.physical.maxA</code>.</li><li>The in-place assignment to <code>cache</code> is ignored in differentiation to allow gradient   computation with Zygote.</li><li>The <code>init_cache</code> function initializes the cache with a zero matrix.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">nn_model = NeuralNetwork(params)
bounds_T = (-25.0, 0.0)
bounds_H = (0.0, 500.0)
Y_law = LawY(nn_model, params; prescale_bounds = [bounds_T, bounds_H])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Laws.jl#L173-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.LuxFunction-Tuple{Function, Union{SubArray, Vector}}-api"><a class="docstring-binding" href="#ODINN.LuxFunction-Tuple{Function, Union{SubArray, Vector}}-api"><code>ODINN.LuxFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>This function allows to extend the Wrapper layers define in Lux to matrices operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/NN_utils.jl#L45-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Model-Union{Tuple{}, Tuple{TAR}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, TAR&lt;:AbstractTarget}-api"><a class="docstring-binding" href="#ODINN.Model-Union{Tuple{}, Tuple{TAR}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, TAR&lt;:AbstractTarget}-api"><code>ODINN.Model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Model(;
    iceflow::Union{IFM, Nothing} = nothing,
    mass_balance::Union{MBM, Nothing} = nothing,
    regressors::Union{NamedTuple, Nothing} = nothing,
    target::Union{TAR, Nothing} = nothing,
) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel, TAR &lt;: AbstractTarget}</code></pre><p>Creates a new model instance using the provided iceflow, mass balance, and machine learning components.</p><p><strong>Arguments</strong></p><ul><li><code>iceflow::Union{IFM, Nothing}</code>: The iceflow model to be used. Can be a single model or <code>nothing</code>.</li><li><code>mass_balance::Union{MBM, Nothing}</code>: The mass balance model to be used. Can be a single model or <code>nothing</code>.</li><li><code>regressors::Union{NamedTuple, Nothing}</code>: The regressors to be used in the laws.</li></ul><p><strong>Returns</strong></p><ul><li><code>model</code>: A new instance of <code>Sleipnir.Model</code> initialized with the provided components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/Model.jl#L41-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Parameters-Tuple{}-api"><a class="docstring-binding" href="#ODINN.Parameters-Tuple{}-api"><code>ODINN.Parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Constructor for the <code>Parameters</code> type. Since some of the subtypes of parameters are defined in different packages of the ODINN ecosystem, this constructor will call the constructors of the different subtypes and return a <code>Parameters</code> object with the corresponding subtypes.  The <code>Parameters</code> mutable struct is defined in <code>Sleipnir.jl</code> using abstract types, which are later on defined in the different packages of the ODINN ecosystem.</p><pre><code class="nohighlight hljs">Parameters(;
        physical::PhysicalParameters = PhysicalParameters(),
        simulation::SimulationParameters = SimulationParameters(),
        solver::SolverParameters = SolverParameters(),
        hyper::Hyperparameters = Hyperparameters(),
        UDE::UDEparameters = UDEparameters()
        inversion::InversionParameters = InversionParameters()
        )</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: Physical parameters for the simulation.</li><li><code>simulation::SimulationParameters</code>: Parameters related to the simulation setup.</li><li><code>solver::SolverParameters</code>: Parameters for the solver configuration.</li><li><code>hyper::Hyperparameters</code>: Hyperparameters for the model.</li><li><code>UDE::UDEparameters</code>: Parameters specific to the UDE (Universal Differential Equation).</li><li><code>inversion::InversionParameters</code>: Parameters for inversion processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/parameters/UDEparameters.jl#L78-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.SIA2D_UDE!-Tuple{Matrix{&lt;:Real}, Matrix{&lt;:Real}, InversionBinder, Real}-api"><a class="docstring-binding" href="#ODINN.SIA2D_UDE!-Tuple{Matrix{&lt;:Real}, Matrix{&lt;:Real}, InversionBinder, Real}-api"><code>ODINN.SIA2D_UDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Currently just used for Enzyme</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L659-L661">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.SIA2D_grad!-Tuple{Any, Any, Inversion}-api"><a class="docstring-binding" href="#ODINN.SIA2D_grad!-Tuple{Any, Any, Inversion}-api"><code>ODINN.SIA2D_grad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Inverse with batch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/gradient.jl#L3-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.SIA2D_grad_batch!-Tuple{Any, Inversion}-api"><a class="docstring-binding" href="#ODINN.SIA2D_grad_batch!-Tuple{Any, Inversion}-api"><code>ODINN.SIA2D_grad_batch!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute gradient glacier per glacier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/gradient.jl#L42-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.T_A_Alaw-Tuple{Simulation, Integer, Any, AbstractFloat}-api"><a class="docstring-binding" href="#ODINN.T_A_Alaw-Tuple{Simulation, Integer, Any, AbstractFloat}-api"><code>ODINN.T_A_Alaw</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T_A_Alaw(simulation::Simulation, glacier_idx::Integer, θ, t::AbstractFloat)</code></pre><p>Evaluate the A law when it defines a mapping between the long term air temperature and the creep coefficient <code>A</code> and return both the input temperature <code>T</code> and the computed creep coefficient <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: The simulation object containing model data and parameters.</li><li><code>glacier_idx::Integer</code>: Index specifying which glacier to evaluate.</li><li><code>θ</code>: Model parameters to be used in the law.</li><li><code>t::AbstractFloat</code>: The time at which to evaluate the law. For this law it is useless   but in the general setting, a law needs a time <code>t</code> in order to retrieve the inputs.   For the sake of consistency, this input was kept.</li></ul><p><strong>Returns</strong></p><ul><li><code>(T, A)</code>: A tuple containing:<ul><li><code>T</code>: The input long term air temperature for the specified glacier.</li><li><code>A</code>: The evaluated creep coefficient for the specified glacier.</li></ul></li></ul><p><strong>Details</strong></p><ul><li>The function checks that the inputs of the A law are exactly as expected (long term air temperature only).</li><li>Retrieves the long term air temperature for the specific glacier.</li><li>Evaluates the creep coefficient using the law.</li><li>Returns both the temperature and creep coefficient as a tuple. Since the cache of <code>A</code> is a zero dimensional array, it is converted to float before returning the value.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">T, A = T_A_Alaw(simulation, glacier_idx, θ, 2010.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/laws_utils.jl#L43-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA∂H_continuous</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂H_continuous(
    λ::Matrix{R},
    H::Matrix{R},
    θ,
    simulation::SIM,
    t::R,
) where {R &lt;: Real, SIM &lt;: Simulation}</code></pre><p>Implementation of the continuous VJP of the SIA2D equation with respect to H. Given λ and H, it returns the VJP of λ^T * ∂(SIA2D)/∂H (H).</p><p>Arguments:</p><ul><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li></ul><p>Returns:</p><ul><li><code>dλ::Matrix{R}</code>: Jacobian vector product, also called input gradient in reverse-mode AD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/adjoint.jl#L410-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VJP_λ_∂SIA∂H_discrete-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#ODINN.VJP_λ_∂SIA∂H_discrete-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA∂H_discrete</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂H_discrete(
    λ::Matrix{R},
    H::Matrix{R},
    θ,
    simulation::SIM,
    t::R,
) where {R &lt;:Real, SIM &lt;: Simulation}</code></pre><p>Implementation of the discrete VJP of the SIA2D equation with respect to H. Given λ and H, it returns the VJP of λ^T * ∂(SIA2D)/∂H (H).</p><p>Arguments:</p><ul><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li></ul><p>Returns:</p><ul><li><code>dλ::Matrix{R}</code>: Jacobian vector product, also called input gradient in reverse-mode AD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/adjoint.jl#L9-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA∂θ_continuous</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂θ_continuous(
    λ::Matrix{R},
    H::Matrix{R},
    θ,
    simulation::SIM,
    t::R,
) where {R &lt;: Real, SIM &lt;: Simulation}</code></pre><p>Implementation of the continuous VJP of the SIA2D equation with respect to θ. Given λ, H and θ, it returns the VJP of λ^T * ∂(SIA2D)/∂θ (θ).</p><p>Arguments:</p><ul><li><code>θ</code>: Vector of parameters</li><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li></ul><p>Returns:</p><ul><li><code>∂θ</code>: Jacobian vector product with respect to θ, also called input gradient in   reverse-mode AD. It has the same type as θ.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/adjoint.jl#L545-L567">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VJP_λ_∂SIA∂θ_discrete-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#ODINN.VJP_λ_∂SIA∂θ_discrete-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA∂θ_discrete</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂θ_discrete(
    λ::Matrix{R},
    H::Matrix{R},
    θ,
    simulation::SIM,
    t::R,
) where {R &lt;: Real, SIM &lt;: Simulation}</code></pre><p>Implementation of the discrete VJP of the SIA2D equation with respect to θ. Given λ, H and θ, it returns the VJP of λ^T * ∂(SIA2D)/∂θ (θ).</p><p>Arguments:</p><ul><li><code>θ</code>: Vector of parameters</li><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li></ul><p>Returns:</p><ul><li><code>∂θ</code>: Jacobian vector product with respect to θ, also called input gradient in   reverse-mode AD. It has the same type as θ.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/adjoint.jl#L148-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.VJP_λ_∂∇²a_∂a-Union{Tuple{R}, Tuple{Matrix{R}, Matrix{R}, R, R}} where R&lt;:Real-api"><a class="docstring-binding" href="#ODINN.VJP_λ_∂∇²a_∂a-Union{Tuple{R}, Tuple{Matrix{R}, Matrix{R}, R, R}} where R&lt;:Real-api"><code>ODINN.VJP_λ_∂∇²a_∂a</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VJP_λ_∂∇²a_∂a(λ::Matrix{R}, a::Matrix{R}, Δx::R, Δy::R) where {R&lt;:Real}</code></pre><p>Computes the vector-Jacobian product (VJP) of the Laplacian operator <code>∇²</code> with respect to its input field <code>a</code>. This function effectively propagates sensitivities (adjoints) <code>λ</code> backward through the Laplacian, as required in adjoint or reverse-mode differentiation.</p><p><strong>Arguments</strong></p><ul><li><code>λ::Matrix{R}</code>: Adjoint field associated with the Laplacian output.</li><li><code>a::Matrix{R}</code>: Input scalar field to the Laplacian operator.</li><li><code>Δx::R</code>: Grid spacing in the x-direction.</li><li><code>Δy::R</code>: Grid spacing in the y-direction.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{R}</code>: The adjoint (VJP) with respect to <code>a</code>, i.e. <code>∂⟨λ, ∇²a⟩/∂a</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L344-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Vector2ComponentVector-Tuple{Vector, ComponentArrays.ComponentVector}-api"><a class="docstring-binding" href="#ODINN.Vector2ComponentVector-Tuple{Vector, ComponentArrays.ComponentVector}-api"><code>ODINN.Vector2ComponentVector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Vector2ComponentVector(v::Vector, cv_template::ComponentVector)</code></pre><p>Transform a vector <code>v</code> to a <code>ComponentVector</code> that has the same structure as <code>cv_template</code>. This function creates a new <code>ComponentVector</code> and copies the values of <code>v</code> explicitly. The arguments <code>v</code> and <code>cv_template</code> must be of the same length.</p><p>Arguments:</p><ul><li><code>v::Vector</code>: Vector whose values are copied.</li><li><code>cv_template::ComponentVector</code>: ComponentVector whose structure is used to create a new <code>ComponentVector</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L170-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.Velocityꜛ-Tuple{SIA2D_D_target}-api"><a class="docstring-binding" href="#ODINN.Velocityꜛ-Tuple{SIA2D_D_target}-api"><code>ODINN.Velocityꜛ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Function to evaluate derivatives of ice surface velocity in D inversion.</p><p>TODO: This functions right now just make a call to the regular functions used for the calculation of the adjoint. This is not correct, but we keep it as this for now until we figure out how to do this in the case of the D inversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_D_pure.jl#L192-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN._batch_iceflow_UDE-Tuple{InversionBinder, Integer, SciMLBase.ODEProblem}-api"><a class="docstring-binding" href="#ODINN._batch_iceflow_UDE-Tuple{InversionBinder, Integer, SciMLBase.ODEProblem}-api"><code>ODINN._batch_iceflow_UDE</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_batch_iceflow_UDE(
    container::InversionBinder,
    glacier_idx::Integer,
    iceflow_prob::ODEProblem,
)</code></pre><p>Define the callbacks to be called by the ODE solver, solve the ODE and create the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L451-L459">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN._ml_model_postscale-Tuple{Union{SubArray, Vector}, Any}-api"><a class="docstring-binding" href="#ODINN._ml_model_postscale-Tuple{Union{SubArray, Vector}, Any}-api"><code>ODINN._ml_model_postscale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_ml_model_postscale(
    Y::Vector,
    max_NN,
)</code></pre><p>Applies an exponential transformation to each element in <code>Y</code>, then rescales the result by multiplying with <code>max_NN</code>. For each element, the transformation is: <code>max_NN * exp((Y - 1.0) / Y)</code></p><p><strong>Arguments</strong></p><ul><li><code>Y::Vector</code>: Values to be post-processed.</li><li><code>max_NN</code>: Scalar representing the maximum value for rescaling.</li></ul><p><strong>Returns</strong></p><ul><li>The rescaled values after applying the exponential transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L66-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN._ml_model_prescale-Union{Tuple{F}, Tuple{Vector, Array{Tuple{F, F}, 1}}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN._ml_model_prescale-Union{Tuple{F}, Tuple{Vector, Array{Tuple{F, F}, 1}}} where F&lt;:AbstractFloat-api"><code>ODINN._ml_model_prescale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_ml_model_prescale(
    X::Vector,
    prescale_bounds::Vector{Tuple{F, F}},
) where {F &lt;: AbstractFloat}</code></pre><p>Scales each element of the input vector <code>X</code> using the corresponding bounds from <code>prescale_bounds</code>. For each index <code>i</code>, <code>X[i]</code> is normalized based on the interval specified in <code>prescale_bounds[i]</code> using the <code>normalize</code> function. This function is typically used to ensure that the scales of the inputs of a neural network are comparable to each other.</p><p><strong>Arguments</strong></p><ul><li><code>X::Vector</code>: A vector of input values to be normalized.</li><li><code>prescale_bounds::Vector{Tuple{F, F}}</code>: A vector of tuples specifying the lower and upper bounds   for normalization of each corresponding element in <code>X</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A vector where each element is the normalized value of the corresponding input, using the   specified bounds.</li></ul><p><strong>Notes</strong></p><ul><li>The length of <code>X</code> and <code>prescale_bounds</code> must be equal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L31-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN._pred_NN-Union{Tuple{F}, Tuple{Vector{F}, Vararg{Any, 4}}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN._pred_NN-Union{Tuple{F}, Tuple{Vector{F}, Vararg{Any, 4}}} where F&lt;:AbstractFloat-api"><code>ODINN._pred_NN</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_pred_NN(inp::Vector{F}, smodel, θ, prescale, postscale) where {F &lt;: AbstractFloat}</code></pre><p>Compute the output of a neural network model on the input vector <code>inp</code>.</p><p><strong>Arguments</strong></p><ul><li><code>inp::Vector{F}</code>: Input vector of floats.</li><li><code>smodel</code>: The neural network model.</li><li><code>θ</code>: Parameters for the neural network model.</li><li><code>prescale</code>: Function to scale the input vector before passing it to the model.</li><li><code>postscale</code>: Function to scale the model output.</li></ul><p><strong>Returns</strong></p><ul><li>The single (scalar) output value from the neural network after applying <code>prescale</code>   to the input, evaluating the model, and then applying <code>postscale</code>. The result is   extracted via <code>only</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The function assumes that the neural network, when evaluated, returns an iterable with exactly one element.</li><li>Using <code>only</code> will throw an error if the output is not exactly one element.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mymodel = StatefulLuxLayer{true}(archi, nothing, st)
y = _pred_NN([1.0, 2.0], mymodel, θ, prescale_fn, postscale_fn)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Laws.jl#L3-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.aggregate∇θ-Tuple{Vector{&lt;:ComponentArrays.ComponentArray}, Any, ODINN.TrainableComponents}-api"><a class="docstring-binding" href="#ODINN.aggregate∇θ-Tuple{Vector{&lt;:ComponentArrays.ComponentArray}, Any, ODINN.TrainableComponents}-api"><code>ODINN.aggregate∇θ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">aggregate∇θ(∇θ::Vector{&lt;: ComponentArray}, θ, submodels::TrainableComponents)</code></pre><p>Aggregate the vector of gradients <code>∇θ</code> as a single <code>ComponentArray</code>. The argument <code>∇θ</code> is the vector of all the gradients computed for each glacier. This function aggregates them based on the optimizable components of <code>submodels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/Model.jl#L191-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.backward_loss-Union{Tuple{F}, Tuple{MultiLoss, Matrix{F}, Any, Any, Any, Any, F, Integer, Any, Any, F, Any}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.backward_loss-Union{Tuple{F}, Tuple{MultiLoss, Matrix{F}, Any, Any, Any, Any, F, Integer, Any, Any, F, Any}} where F&lt;:AbstractFloat-api"><code>ODINN.backward_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">backward_loss(
    lossType::MultiLoss,
    H_pred::Matrix{F},
    H_ref,
    V_ref, Vx_ref, Vy_ref,
    t::F,
    glacier_idx::Integer,
    θ,
    simulation,
    normalization::F,
    Δt,
) where {F &lt;: AbstractFloat}</code></pre><p>Computes the gradient of a composite loss defined by a <code>MultiLoss</code> object with respect to both the predicted field <code>H_pred</code> and model parameters <code>θ</code>.</p><p>Each sub-loss&#39;s backward gradient is weighted by its corresponding coefficient in <code>lossType.λs</code> and summed to form the total gradient.</p><p><strong>Arguments</strong></p><ul><li><code>lossType::MultiLoss</code>: Composite loss object containing individual losses and weights.</li><li><code>H_pred::Matrix{F}</code>: Predicted ice thickness.</li><li><code>H_ref::Matrix{F}</code>: Reference ice thickness.</li><li><code>t::F</code>: Current time or simulation step.</li><li><code>glacier_idx::Integer</code>: Glacier id in the list of glaciers in <code>simulation</code>.</li><li><code>θ</code>: Model parameters used in the simulation.</li><li><code>simulation</code>: Simulation object providing necessary context for gradient computation.</li><li><code>normalization::F</code>: Normalization factor applied within each individual loss.</li><li><code>Δt</code>: Named tuple containing the time step to use for the approximation of continuous in time loss terms.   For example if <code>LossH</code> is used, there must be a term <code>Δt.H</code> containing the time step since the last   computation of the ice thickness loss term. If the current time <code>t</code> where the loss is evaluated does not   correspond to a time step of the <code>LossH</code> term, then the value of <code>Δt.H</code> has no impact.</li></ul><p><strong>Returns</strong></p><ul><li><code>(∂L∂H, ∂L∂θ)</code>: Tuple containing:<ul><li><code>∂L∂H::Matrix{F}</code>: Gradient of the composite loss with respect to <code>H_pred</code>.</li><li><code>∂L∂θ</code>: Gradient of the composite loss with respect to model parameters <code>θ</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/MultiLoss.jl#L100-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.batch_loss_iceflow_transient-Tuple{InversionBinder, Integer, SciMLBase.ODEProblem}-api"><a class="docstring-binding" href="#ODINN.batch_loss_iceflow_transient-Tuple{InversionBinder, Integer, SciMLBase.ODEProblem}-api"><code>ODINN.batch_loss_iceflow_transient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">batch_loss_iceflow_transient(
    container::InversionBinder,
    glacier_idx::Integer,
    iceflow_prob::ODEProblem,
)</code></pre><p>Solve the ODE, retrieve the results and compute the loss.</p><p>Arguments:</p><ul><li><code>container::InversionBinder</code>: SciMLStruct that contains the simulation structure and the vector of parameters to optimize.</li><li><code>glacier_idx::Integer</code>: Index of the glacier.</li><li><code>iceflow_prob::ODEProblem</code>: Iceflow problem defined as an ODE with respect to time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L360-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.callback_diagnosis-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#ODINN.callback_diagnosis-Tuple{Any, Any, Any}-api"><code>ODINN.callback_diagnosis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">callback_diagnosis(θ, l, simulation; save::Bool = false, tbLogger::Union{&lt;: TBLogger, Nothing} = nothing)</code></pre><p>Callback function to track and diagose training. It includes print and updates in simulation::Simulation. It also logs training statistics with tensorboard if tbLogger is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/callback_utils.jl#L48-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.callback_plots_A-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#ODINN.callback_plots_A-Tuple{Any, Any, Any}-api"><code>ODINN.callback_plots_A</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">callback_plots_A(θ, l, simulation)</code></pre><p>Callback function to generate plots during training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/callback_utils.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.cap_D-Tuple{Any}-api"><a class="docstring-binding" href="#ODINN.cap_D-Tuple{Any}-api"><code>ODINN.cap_D</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Normalization of D to cap at a maximum physical value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L139-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.create_interpolation-Union{Tuple{Matrix}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.create_interpolation-Union{Tuple{Matrix}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.create_interpolation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_interpolation(A::Matrix; n_interp_half::Int) -&gt; Vector{Float64}</code></pre><p>Construct a one-dimensional interpolation grid from the elements of a matrix <code>A</code> by flattening it and delegating to <a href="#ODINN.create_interpolation-Union{Tuple{Matrix}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>create_interpolation(::Vector)</code></a>. This is a  convenience method that allows users to pass a 2D array to the function <code>create_interpolation(A::Vector)</code> directly without manually reshaping it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L284-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.create_interpolation-Union{Tuple{Vector}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.create_interpolation-Union{Tuple{Vector}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.create_interpolation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_interpolation(
    A::Vector;
    n_interp_half::Int,
    dilation_factor = 1.0,
    minA_unif::Union{F, Nothing} = nothing,
    minA_quantile::Union{F, Nothing} = nothing,
    maxA_unif::Union{F, Nothing} = nothing,
    maxA_quantile::Union{F, Nothing} = nothing
    ) where {F &lt;: AbstractFloat}</code></pre><p>Construct a one-dimensional interpolation grid from the data in <code>A</code>, combining uniformly spaced and quantile-based sampling points.</p><p>This hybrid interpolation grid provides both coverage of the entire range of values and higher resolution in regions where <code>A</code> has dense data, making it useful for interpolation or machine learning applications that need balanced sampling.</p><p><strong>Arguments</strong></p><ul><li><code>A::Vector</code>: Input data vector (typically containing positive values).</li><li><code>n_interp_half::Int</code>: Number of points used for both the uniform and quantile-based subsets of the interpolation grid.</li><li><code>dilation_factor::Real = 1.0</code>: Optional multiplier applied to <code>maximum(A)</code> to slightly extend the grid beyond the data range (useful to avoid extrapolation issues).</li><li><code>minA_unif::Union{F, Nothing} = nothing</code>: Minimum value used for the uniform interpolation</li><li><code>minA_quantile::Union{F, Nothing} = nothing</code>: Maximum value used for the uniform interpolation</li><li><code>maxA_unif::Union{F, Nothing} = nothing</code>: Minimum value used for the quantile interpolation</li><li><code>maxA_quantile::Union{F, Nothing} = nothing</code>: Maximum value used for the quantile interpolation</li></ul><p><strong>Returns</strong></p><p>A sorted, unique vector of interpolation nodes combining:</p><ul><li><code>n_interp_half</code> uniformly spaced values between <code>0</code> and <code>dilation_factor * maximum(A)</code></li><li><code>n_interp_half</code> quantile-based values computed from the positive entries of <code>A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L200-L234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.create_results-Tuple{Any, Inversion, Any}-api"><a class="docstring-binding" href="#ODINN.create_results-Tuple{Any, Inversion, Any}-api"><code>ODINN.create_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_results(θ, simulation::Inversion, mappingFct)</code></pre><p>Given the parameters θ, solve the iceflow problem for all the glaciers and aggregate the results for all of them. This function is typically used at the end of a training once θ has been optimized and one wants to run one last forward simulation in order to retrieve statistics about each of the iceflow problems.</p><p>Arguments:</p><ul><li><code>θ</code>: Parameters to use for the forward simulation.</li><li><code>simulation::Inversion</code>: Simulation structure that contains all the required information about the inversion.</li><li><code>mappingFct</code>: Function to use to process the glaciers. Either <code>map</code> for a sequential processing or <code>pmap</code> for multiprocessing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L235-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.define_iceflow_prob-Tuple{Any, Inversion, Integer}-api"><a class="docstring-binding" href="#ODINN.define_iceflow_prob-Tuple{Any, Inversion, Integer}-api"><code>ODINN.define_iceflow_prob</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">define_iceflow_prob(
    simulation::Inversion,
    glacier_idx::Integer,
)</code></pre><p>Given a <code>simulation</code> struct and a <code>glacier_idx</code>, build the iceflow problem that has to be solved in the ODE solver. In practice, the returned iceflow problem is used inside <code>simulate_iceflow_UDE!</code> through <code>remake</code>. The definition of the iceflow problem has to be done outside of the gradient computation, otherwise Zygote fails at differentiating it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L553-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}-api"><a class="docstring-binding" href="#ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}-api"><code>ODINN.enable_multiprocessing</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enable_multiprocessing(params::Sleipnir.Parameters) -&gt; Int</code></pre><p>Configures and enables multiprocessing based on the provided simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: A parameter object containing simulation settings, including the number of workers (<code>params.simulation.workers</code>) and whether multiprocessing is enabled (<code>params.simulation.multiprocessing</code>).</li></ul><p><strong>Behavior</strong></p><ul><li>If multiprocessing is enabled (<code>params.simulation.multiprocessing == true</code>) and the specified number of workers (<code>params.simulation.workers</code>) is greater than 0:<ul><li>Adds the required number of worker processes if the current number of processes (<code>nprocs()</code>) is less than the specified number of workers.</li><li>Suppresses precompilation output on the worker processes and ensures the <code>ODINN</code> module is loaded on all workers.</li><li>If the specified number of workers is 1, removes all worker processes.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>The number of worker processes (<code>nworkers()</code>) after configuration.</li></ul><p><strong>Notes</strong></p><ul><li>This function uses <code>@eval</code> to dynamically add or remove worker processes.</li><li>Precompilation output is suppressed on workers to reduce noise in the console.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/setup/config.jl#L66-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.eval_law-Tuple{AbstractLaw, Simulation, Integer, NamedTuple, Any}-api"><a class="docstring-binding" href="#ODINN.eval_law-Tuple{AbstractLaw, Simulation, Integer, NamedTuple, Any}-api"><code>ODINN.eval_law</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_law(law::AbstractLaw, simulation::Simulation, glacier_idx::Integer, inputs::NamedTuple, θ)</code></pre><p>Evaluates a law on the specified glacier within a simulation context and for a user defined input.</p><p><strong>Arguments</strong></p><ul><li><code>law::AbstractLaw</code>: The law object to be evaluated. Must provide a function <code>f</code> and an <code>init_cache</code> method.</li><li><code>simulation::Simulation</code>: The simulation context, containing model parameters and machine learning components.</li><li><code>glacier_idx::Integer</code>: Index identifying which glacier in the simulation to evaluate the law for.</li><li><code>input_values::NamedTuple</code>: Input data required by the law and provided by the user.</li><li><code>θ</code>: Weights used in the law to make inference. This can be <code>nothing</code> when the law has no parameter.</li></ul><p><strong>Returns</strong></p><ul><li>The updated cache after evaluating the law. The cache contains the result of the law&#39;s computation for the specified glacier and inputs.</li></ul><p><strong>Details</strong></p><ul><li>The function initializes a cache for the law using <code>init_cache</code>.</li><li>If the simulation has a machine learning model, the model&#39;s parameters (<code>θ</code>) are updated in-place with the provided <code>θ</code>.</li><li>The law&#39;s function is then called with the cache, inputs, and parameters. The result is stored in the cache and the cache is returned.</li><li>In future versions, the design may change so that only <code>inputs</code> and <code>θ</code> are needed, with the cache handled separately so that no <code>simulation</code> is required.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = eval_law(simulation.model.iceflow.A, simulation, glacier_idx, (; T=273.15), θ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/laws_utils.jl#L3-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.evaluate_H₀-Tuple{ComponentArrays.ComponentArray, Glacier2D, Symbol, Integer}-api"><a class="docstring-binding" href="#ODINN.evaluate_H₀-Tuple{ComponentArrays.ComponentArray, Glacier2D, Symbol, Integer}-api"><code>ODINN.evaluate_H₀</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate_H₀(
    θ::ComponentArray,
    glacier::Glacier2D,
    filter::Symbol,
    glacier_id::Integer,
)</code></pre><p>Evaluate the initial ice thickness <code>H₀</code> for a given glacier, optionally applying a smooth thresholding function.</p><p><strong>Arguments</strong></p><ul><li><code>θ::ComponentArray</code>: A <code>ComponentArray</code> containing glacier parameters.</li><li><code>glacier::Glacier2D</code>: Glacier for which to evaluate <code>H₀</code>.</li><li><code>filter::Symbol</code>: Specifies the smoothing function to apply to the raw initial condition:<ul><li><code>:identity</code>: applies the identity function (no change).</li><li><code>:softplus</code>: applies the softplus function <code>log(1 + exp(x))</code> to ensure positivity.</li><li><code>:Zang1980</code>: applies the <code>σ_zang</code> function (Zang 1980) as a smooth positivity threshold.</li></ul></li><li><code>glacier_id::Integer</code>: Index of the glacier in order to retrieve the parameters of the IC in θ.</li></ul><p><strong>Returns</strong></p><ul><li>A numeric value or array representing the filtered initial ice thickness for the specified glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/InitialCondition_utils.jl#L2-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.evaluate_∂H₀-Tuple{ComponentArrays.ComponentArray, Glacier2D, Symbol, Integer}-api"><a class="docstring-binding" href="#ODINN.evaluate_∂H₀-Tuple{ComponentArrays.ComponentArray, Glacier2D, Symbol, Integer}-api"><code>ODINN.evaluate_∂H₀</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate_∂H₀(
    θ::ComponentArray,
    glacier::Glacier2D,
    filter::Symbol,
    glacier_id::Integer,
)</code></pre><p>Evaluate the derivative of the initial ice thickness <code>H₀</code> for a given glacier, optionally applying a smooth thresholding function.</p><p><strong>Arguments</strong></p><ul><li><code>θ::ComponentArray</code>: A <code>ComponentArray</code> containing glacier parameters.</li><li><code>glacier::Glacier2D</code>: Glacier for which to evaluate <code>∂H₀</code>.</li><li><code>filter::Symbol</code>: Specifies the smoothing function to apply to the raw initial condition:<ul><li><code>:identity</code>: applies the identity function (no change).</li><li><code>:softplus</code> — applies the softplus function <code>log(1 + exp(x))</code> to ensure positivity.</li><li><code>:Zang1980</code> — applies the <code>σ_zang</code> function (Zang 1980) as a smooth positivity threshold.</li></ul></li><li><code>glacier_id::Integer</code>: Index of the glacier in order to retrieve the parameters of the IC in θ.</li></ul><p><strong>Returns</strong></p><ul><li>A numeric value or array representing the filtered initial ice thickness for the specified glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/InitialCondition_utils.jl#L42-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.feed_input_cache!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Any, Any}-api"><a class="docstring-binding" href="#ODINN.feed_input_cache!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Any, Any}-api"><code>ODINN.feed_input_cache!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">feed_input_cache!(
    SIA2D_model::SIA2Dmodel,
    SIA2D_cache::SIA2DCache,
    simulation,
    glacier_idx::Integer,
    θ,
    result
)</code></pre><p>Populate the input cache of an <code>SIA2DCache</code> instance with interpolation nodes for ice thickness (<code>H</code>) and surface slope (<code>∇S</code>), based on the results of a previous forward simulation. This function is required just when results of the forward pass are required to evaluate the elements of the cache in the reverse step.</p><p>This function prepares the interpolation knots used later by the reverse evaluation of the adjoint SIA2D model.</p><p>Right now, this function is just required for the inversion w.r.t to D, which is indicated by the boolean variable <code>SIA2D_model.U_is_provided</code>. Other inversions may not required the definition of this function.</p><p><strong>Arguments</strong></p><ul><li><code>SIA2D_model::SIA2Dmodel</code>: The 2D shallow-ice approximation model instance.</li><li><code>SIA2D_cache::SIA2DCache</code>: The cache object that stores precomputed interpolation nodes.</li><li><code>simulation</code>: The simulation object containing glacier configurations and model settings.</li><li><code>glacier_idx::Integer</code>: Index of the glacier within <code>simulation.glaciers</code> for which the cache is being populated.</li><li><code>θ</code>: Model parameters (not directly used in this function but included for interface consistency).</li><li><code>result</code>: Output of a previous forward run containing ice thickness fields <code>H</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/Cache.jl#L87-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.fourier_feature-api"><a class="docstring-binding" href="#ODINN.fourier_feature-api"><code>ODINN.fourier_feature</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fourier_feature(v, n::Integer=10, random=false, σ=5.0)</code></pre><p>Generates a Fourier feature embedding of a vector <code>v</code>, optionally using randomized projections.</p><p><strong>Arguments</strong></p><ul><li><code>v</code>: Input vector to be transformed (typically a coordinate or feature vector).</li><li><code>n::Integer=10</code>: Number of Fourier features to generate (default is 10).</li><li><code>random::Bool=false</code>: Whether to use random Fourier features (default is <code>false</code>).</li><li><code>σ::Float64=5.0</code>: Standard deviation of the normal distribution used for random feature projection (only used if <code>random=true</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>2n</code>-dimensional vector consisting of sine and cosine features of the transformed input vector.</li></ul><p><strong>Notes</strong></p><p>Fourier features help to overcome spectral bias in neural networks and can further help to learn higher frequncy components of the function faster. For more information, see Tancik et. al (2020), &quot;Fourier Features Let Networks Learn High Frequency Functions in Low Dimensional Domains&quot;.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = [0.5, 1.0]
features = fourier_feature(v, n=4, random=true, σ=2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/NN_utils.jl#L7-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.generate_batches-Tuple{S} where S&lt;:Simulation-api"><a class="docstring-binding" href="#ODINN.generate_batches-Tuple{S} where S&lt;:Simulation-api"><code>ODINN.generate_batches</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_batches(simulation::S; shuffle=false) where {S &lt;: Simulation}</code></pre><p>Generate a data loader for batching simulations, optionally shuffling the batches.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::S</code>: A <code>Simulation</code> object (or subtype of <code>Simulation</code>) containing the data to be batched.</li><li><code>shuffle::Bool=false</code>: A flag indicating whether to shuffle the batches. Defaults to <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataLoader</code> object that provides batched access to the simulation data.</li></ul><p><strong>Description</strong></p><p>This function creates a <code>DataLoader</code> for batching the provided simulation object. The <code>DataLoader</code> allows for efficient iteration over the simulation data in batches. The batch size is set to <code>1</code> by default, and the <code>shuffle</code> flag determines whether the batches are shuffled. If <code>shuffle</code> is enabled, a warning is logged to indicate that the batches used for parallelization are being shuffled.</p><p><strong>Notes</strong></p><ul><li>The batch size is fixed at <code>1</code> in this implementation. To modify the batch size, you may need to adjust the <code>DataLoader</code> initialization.</li><li>Shuffling the batches may affect reproducibility and parallelization behavior.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/ML_utils.jl#L157-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.generate_simulation_batches-Tuple{Inversion}-api"><a class="docstring-binding" href="#ODINN.generate_simulation_batches-Tuple{Inversion}-api"><code>ODINN.generate_simulation_batches</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_simulation_batches(simulation::Inversion)</code></pre><p>Generate batches of simulations from a <code>Inversion</code> object for parallel or batched processing.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Inversion</code>: A <code>Inversion</code> object containing the model, glaciers, parameters, results, and statistics for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>Inversion</code> objects, each representing a batch of simulations. Each batch contains a subset of glaciers, models, and results from the original simulation.</li></ul><p><strong>Description</strong></p><p>This function splits the glaciers and associated data in the <code>simulation</code> object into smaller batches for processing. Each batch is represented as a new <code>Inversion</code> object. The number of batches is determined by the <code>nbatches</code> variable (currently set to 1). If the simulation results are empty, the function creates batches with empty results. Otherwise, it includes the corresponding results for each glacier in the batches.</p><p><strong>Notes</strong></p><ul><li>The number of glaciers (<code>ninstances</code>) must be divisible by the number of batches (<code>nbatches</code>). An assertion is used to enforce this condition.</li><li>The function currently defaults to <code>nbatches = 1</code>, meaning no actual batching is performed. This can be updated to use <code>simulation.parameters.hyper.batchsize</code> for dynamic batching.</li><li>If the simulation results are empty, the function creates batches with empty results objects.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/ML_utils.jl#L109-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.get_default_NN-Tuple{Any, Any}-api"><a class="docstring-binding" href="#ODINN.get_default_NN-Tuple{Any, Any}-api"><code>ODINN.get_default_NN</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_NN(θ_trained, ft; lightNN=false)</code></pre><p>Generates a neural network.</p><p><strong>Arguments</strong></p><ul><li><code>θ_trained</code>: Pre-trained neural network parameters (optional).</li><li><code>ft</code>: Float type used.</li><li><code>lightNN</code>: Boolean that determines if a light architecture is returned or not.</li></ul><p><strong>Returns</strong></p><ul><li><code>UA</code>: <code>Lux.Chain</code> neural network architecture.</li><li><code>θ</code>: Neural network parameters.</li><li><code>st</code>: Lux state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/ML_utils.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.grad_loss_iceflow!-Tuple{Any, Any, Inversion, Any}-api"><a class="docstring-binding" href="#ODINN.grad_loss_iceflow!-Tuple{Any, Any, Inversion, Any}-api"><code>ODINN.grad_loss_iceflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grad_loss_iceflow!(dθ, θ, simulation::Inversion, mappingFct)</code></pre><p>Compute the gradient with respect to θ for all the glaciers and assign the result in-place to <code>dθ</code>.</p><p>Arguments:</p><ul><li><code>dθ</code>: Gradient of the parameters where the computed gradient should be stored.</li><li><code>θ</code>: Parameters to differentiate.</li><li><code>simulation::Inversion</code>: Simulation structure that contains all the required information about the inversion.</li><li><code>mappingFct</code>: Function to use to process the glaciers. Either <code>map</code> for a sequential processing or <code>pmap</code> for multiprocessing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L290-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.grad_loss_iceflow!-Tuple{Any, Inversion, Any}-api"><a class="docstring-binding" href="#ODINN.grad_loss_iceflow!-Tuple{Any, Inversion, Any}-api"><code>ODINN.grad_loss_iceflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grad_loss_iceflow!(θ, simulation::Inversion, mappingFct)</code></pre><p>Compute the gradient with respect to θ for all the glaciers and return the result out-of-place. See the in-place implementation for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L305-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.grad_parallel_loss_iceflow!-Tuple{Any, Inversion, Integer}-api"><a class="docstring-binding" href="#ODINN.grad_parallel_loss_iceflow!-Tuple{Any, Inversion, Integer}-api"><code>ODINN.grad_parallel_loss_iceflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grad_parallel_loss_iceflow!(θ, simulation::Inversion, glacier_idx::Integer)</code></pre><p>Compute the gradient with respect to θ for a particular glacier and return the computed gradient. This function defines the iceflow problem and then calls Zygote to differentiate <code>batch_loss_iceflow_transient</code> with respect to θ. It uses the SciMLSensitivity implementation under the hood to compute the adjoint of the ODE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L324-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.loss-Union{Tuple{F}, Tuple{LogSum, Matrix{F}, Matrix{F}, BitMatrix, F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.loss-Union{Tuple{F}, Tuple{LogSum, Matrix{F}, Matrix{F}, BitMatrix, F}} where F&lt;:AbstractFloat-api"><code>ODINN.loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function loss(
    lossType::LogSum,
    a::Matrix{F},
    b::Matrix{F},
    mask::BitMatrix,
    normalization::F,
) where {F &lt;: AbstractFloat}</code></pre><p>Compute logarithmic loss function for ice velocity fields following Morlighem, M. et al., &quot;Spatial patterns of basal drag inferred using control methods from a full-Stokes and simpler models for Pine Island Glacier, West Antarctica&quot;. Geophys. Res. Lett. 37, (2010). Given a minimum velocity ϵ the absolute velocity given by a and b, it computes the sum of</p><pre><code class="nohighlight hljs">log^2( (a + ϵ) / (b + ϵ) )</code></pre><p>It has been shown that this loss function enables robust estimation of drag coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Losses.jl#L188-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.loss-Union{Tuple{F}, Tuple{MultiLoss, Matrix{F}, Any, Any, Any, Any, F, Integer, Any, Any, F, Any}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.loss-Union{Tuple{F}, Tuple{MultiLoss, Matrix{F}, Any, Any, Any, Any, F, Integer, Any, Any, F, Any}} where F&lt;:AbstractFloat-api"><code>ODINN.loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loss(
    lossType::MultiLoss,
    H_pred::Matrix{F},
    H_ref,
    V_ref, Vx_ref, Vy_ref,
    t::F,
    glacier_idx::Integer,
    θ,
    simulation,
    normalization::F,
    Δt,
) where {F &lt;: AbstractFloat}</code></pre><p>Computes the weighted composite loss for a prediction <code>H_pred</code> against a reference <code>H_ref</code> using a <code>MultiLoss</code> object.</p><p>Each individual loss in <code>lossType.losses</code> is evaluated and multiplied by its corresponding weight in <code>lossType.λs</code>. The final loss is the sum of these weighted contributions.</p><p><strong>Arguments</strong></p><ul><li><code>lossType::MultiLoss</code>: Composite loss object containing individual losses and weights.</li><li><code>H_pred::Matrix{F}</code>: Predicted ice thickness.</li><li><code>H_ref::Matrix{F}</code>: Reference ice thickness.</li><li><code>t::F</code>: Current time or simulation step.</li><li><code>glacier_idx::Integer</code>: Glacier id in the list of glaciers in <code>simulation</code>.</li><li><code>θ</code>: Model parameters used in the simulation.</li><li><code>simulation</code>: Simulation object providing necessary context for loss evaluation.</li><li><code>normalization::F</code>: Normalization factor applied within each individual loss.</li><li><code>Δt</code>: Named tuple containing the time step to use for the approximation of continuous in time loss terms.   For example if <code>LossH</code> is used, there must be a term <code>Δt.H</code> containing the time step since the last   computation of the ice thickness loss term. If the current time <code>t</code> where the loss is evaluated does not   correspond to a time step of the <code>LossH</code> term, then the value of <code>Δt.H</code> has no impact.</li></ul><p><strong>Returns</strong></p><ul><li><code>F</code>: The total scalar loss, computed as the sum of weighted individual losses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/MultiLoss.jl#L33-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.loss_iceflow_transient-Tuple{Any, Inversion, Any}-api"><a class="docstring-binding" href="#ODINN.loss_iceflow_transient-Tuple{Any, Inversion, Any}-api"><code>ODINN.loss_iceflow_transient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loss_iceflow_transient(θ, simulation::Inversion, mappingFct)</code></pre><p>Given the parameters θ, this function:</p><ol><li>Solves the iceflow problem for all the glaciers.</li><li>Computes the loss function defined as the sum of the loss functions for each of the glaciers.  The loss function of each glacier depends on the type of loss. Refer to <code>empirical_loss_function</code> in  the UDE parameters for more information. The loss function is transient meaning that the state of the  glacier is compared to a reference at different time steps over the simulated period.</li><li>Return the value of the loss function.</li></ol><p>Arguments:</p><ul><li><code>θ</code>: Parameters to use for the forward simulation.</li><li><code>simulation::Inversion</code>: Simulation structure that contains all the required information about the inversion.</li><li><code>mappingFct</code>: Function to use to process the glaciers. Either <code>map</code> for a sequential processing or <code>pmap</code> for multiprocessing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L263-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.merge_batches-Tuple{Vector}-api"><a class="docstring-binding" href="#ODINN.merge_batches-Tuple{Vector}-api"><code>ODINN.merge_batches</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge_batches(results::Vector)</code></pre><p>Merge simulation results from multiple batches into a single collection.</p><p><strong>Arguments</strong></p><ul><li><code>results::Vector</code>: A vector where each element is a collection of results (e.g., arrays or vectors) from a batch.</li></ul><p><strong>Returns</strong></p><ul><li>A single collection containing all the merged results from the input batches.</li></ul><p><strong>Description</strong></p><p>This function takes a vector of results from multiple simulation batches and merges them into a single collection using vertical concatenation (<code>vcat</code>). It is useful for combining results that were processed in parallel or in separate batches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/ML_utils.jl#L139-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.normalize-Union{Tuple{Any}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.normalize-Union{Tuple{Any}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.normalize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normalize(X; lims::Tuple{F, F}; method = :shift) where {F &lt;: AbstractFloat}</code></pre><p>Normalize a variable by using an affine transformation defined by some input lower and upper bounds (m, M) and transforming to O(1) scale.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Input value.</li><li><code>lims::Tuple{F, F}</code>: Lower and upper bounds to use in the affine transformation.</li><li><code>method::Symbol</code>: Method to scale data.</li></ul><p><strong>Returns</strong></p><ul><li>The input variable scaled by the affine transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/target/target_utils.jl#L112-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.parallel_loss_iceflow_transient-Tuple{Any, Inversion}-api"><a class="docstring-binding" href="#ODINN.parallel_loss_iceflow_transient-Tuple{Any, Inversion}-api"><code>ODINN.parallel_loss_iceflow_transient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parallel_loss_iceflow_transient(θ, simulation::Inversion)</code></pre><p>Loop over a list of glaciers to process. When multiprocessing is enabled, each call of this function has a dedicated process. This function calls <code>batch_loss_iceflow_transient</code> which returns both the loss and the result structure. The function keeps only the loss.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L342-L348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.plot_law-Tuple{AbstractLaw, Simulation, NamedTuple, Any}-api"><a class="docstring-binding" href="#ODINN.plot_law-Tuple{AbstractLaw, Simulation, NamedTuple, Any}-api"><code>ODINN.plot_law</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_law(law::AbstractLaw, simulation::Simulation, inputs::NamedTuple, θ; glacier_idx=1, idx_fixed_input=0)</code></pre><p>Plot a law function with one or two input variables.</p><p><strong>Arguments</strong></p><ul><li><code>law::AbstractLaw</code>: The law to plot (e.g., a sliding law or creep law).</li><li><code>simulation::Simulation</code>: The simulation containing glaciers and parameters.</li><li><code>inputs::NamedTuple</code>: Named tuple of input variables for the law (e.g., <code>(T=iTemp(), H̄=iH̄())</code>).</li><li><code>θ</code>: Parameters for the law (can be <code>nothing</code> for laws without parameters).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>glacier_idx::Integer=1</code>: Index of the glacier to use for extracting input values (for 2D inputs).</li><li><code>idx_fixed_input::Integer=0</code>: For two-input laws, index (1 or 2) of the input to fix at its mean value. If <code>0</code>, plots a 3D surface.</li></ul><p><strong>Returns</strong></p><ul><li>A plot figure (1D line plot, 2D scatter, or 3D surface) and saves it to the simulation&#39;s working directory.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 1D plot (temperature input for Cuffey-Paterson law)
plot_law(A_law, simulation, (T=iTemp(),), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/laws/laws_plots.jl#L24-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.pretraining-Tuple{Lux.Chain}-api"><a class="docstring-binding" href="#ODINN.pretraining-Tuple{Lux.Chain}-api"><code>ODINN.pretraining</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pretraining(architecture::Lux.Chain;
            X::Matrix,
            Y::Matrix,
            nepochs::Int=3000,
            lossfn::GenericLossFunction=MSLELoss(; agg=mean, epsilon=1e-10),
            rng::AbstractRNG=Random.default_rng())</code></pre><p>Pretrains a neural network model using a input and output.</p><p><strong>Arguments</strong></p><ul><li><code>architecture::Lux.Chain</code>: The neural network architecture to be trained.</li><li><code>X::Matrix</code>: Input feature matrix where each column is a feature vector.</li><li><code>Y::Matrix</code>: Target output matrix corresponding to the inputs in <code>X</code>.</li><li><code>nepochs::Int=3000</code>: Number of training epochs (default is 3000).</li><li><code>lossfn::GenericLossFunction=MSLELoss(...)</code>: Loss function used for training. Defaults to Mean Squared Logarithmic Error.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: Random number generator used for parameter initialization.</li></ul><p><strong>Returns</strong></p><ul><li><code>architecture</code>: The trained neural network architecture.</li><li><code>θ_pretrain</code>: Trained parameters of the neural network.</li><li><code>st_pretrain</code>: Internal states of the trained model.</li></ul><p><strong>Notes</strong></p><p>Pretrainign helps to reduce the number of total epochs required to train the UDE by selecting a physical meaningful initialization for the model. The function initializes the model parameters and states using <code>Lux.setup</code>, then performs training using a custom <code>train_model!</code> function with ADAM optimizer. Loss values are printed every 100 epochs during training.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Lux, Random
arch = Chain(Dense(10 =&gt; 20, relu), Dense(20 =&gt; 1))
X = rand(10, 100)
Y = rand(1, 100)
model, params, state = pretraining(arch; X=X, Y=Y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/NN_utils.jl#L56-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.printProgressLoss-NTuple{4, Any}-api"><a class="docstring-binding" href="#ODINN.printProgressLoss-NTuple{4, Any}-api"><code>ODINN.printProgressLoss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printProgressLoss(iter, total_iters, loss, improvement)</code></pre><p>Print function to track training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/callback_utils.jl#L105-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.random_matrix-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#ODINN.random_matrix-Tuple{Any, Any, Any}-api"><code>ODINN.random_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_matrix(mean, std, corr_length)</code></pre><p>Generate a random matrix with entries drawn from a multivariate normal distribution whose mean is given by <code>mean</code> and whose covariance decays exponentially with grid distance.</p><p><strong>Arguments</strong></p><ul><li><code>mean::AbstractMatrix{&lt;:Real}</code>: Matrix specifying the spatial mean values at each grid point.   Entries equal to <code>0.0</code> are treated as inactive and skipped in sampling.</li><li><code>std::Real</code>: Standard deviation scaling factor for the covariance kernel.</li><li><code>corr_length::Real</code>: Correlation length parameter controlling how fast correlations   decay with Euclidean distance between grid points.</li></ul><p><strong>Returns</strong></p><ul><li><code>H_sample::Matrix{Float64}</code>: A random realization of the same size as <code>mean</code>, with correlated entries    drawn from <code>MvNormal(mean, Σ)</code>, where   <code>Σ[i,j] = std * exp(-‖coords[i] - coords[j]‖ / corr_length)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/InitialCondition_utils.jl#L121-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.safe_slice-Tuple{Any, Integer}-api"><a class="docstring-binding" href="#ODINN.safe_slice-Tuple{Any, Integer}-api"><code>ODINN.safe_slice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">safe_slice(obj, ind::Integer)</code></pre><p>Return a sliced object <code>obj</code> if <code>ind &gt; 0</code>, otherwise return 0.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/inverse/SIA2D/gradient.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.save_inversion_file!-Union{Tuple{SIM}, Tuple{Any, SIM}} where SIM&lt;:Simulation-api"><a class="docstring-binding" href="#ODINN.save_inversion_file!-Union{Tuple{SIM}, Tuple{Any, SIM}} where SIM&lt;:Simulation-api"><code>ODINN.save_inversion_file!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>This function saves the results of an inversion to a file in JLD2 format. If the <code>path</code> argument is not provided, the function will create a default path based on the current project directory. The results are saved in a file named <code>prediction_&lt;nglaciers&gt;glaciers_&lt;tspan&gt;.jld2</code>, where <code>&lt;nglaciers&gt;</code> is the number of glaciers in the simulation and <code>&lt;tspan&gt;</code> is the simulation time span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/results/trainingresult_utils.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.simulate_iceflow_UDE!-Tuple{InversionBinder, SciMLBase.DECallback, SciMLBase.ODEProblem, Any}-api"><a class="docstring-binding" href="#ODINN.simulate_iceflow_UDE!-Tuple{InversionBinder, SciMLBase.DECallback, SciMLBase.ODEProblem, Any}-api"><code>ODINN.simulate_iceflow_UDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_iceflow_UDE!(
    container::InversionBinder,
    cb::SciMLBase.DECallback,
    iceflow_prob::ODEProblem,
    tstops,
)</code></pre><p>Make a forward simulation of the iceflow UDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L520-L529">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.splitθ-Tuple{Any, Integer, ODINN.TrainableModel}-api"><a class="docstring-binding" href="#ODINN.splitθ-Tuple{Any, Integer, ODINN.TrainableModel}-api"><code>ODINN.splitθ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">splitθ(θ, glacier_idx::Integer, optimizableComponent::TrainableModel)</code></pre><p>Given a <code>ComponentVector</code> <code>θ</code>, a <code>glacier_idx</code> and an <code>optimizableComponent</code>, extract the content of <code>θ</code> relevant for the given <code>optimizableComponent</code> and glacier ID <code>glacier_idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/Model.jl#L174-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.train_UDE!-Tuple{Inversion, Optim.FirstOrderOptimizer}-api"><a class="docstring-binding" href="#ODINN.train_UDE!-Tuple{Inversion, Optim.FirstOrderOptimizer}-api"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>BFGS optim</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L106-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.train_UDE!-Tuple{Inversion}-api"><a class="docstring-binding" href="#ODINN.train_UDE!-Tuple{Inversion}-api"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">train_UDE!(
    simulation::Inversion;
    save_every_iter::Bool = false,
    logger::Union{&lt;: TBLogger, Nothing} = nothing
)</code></pre><p>Trains UDE based on the current Inversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L87-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.train_UDE!-Union{Tuple{AR}, Tuple{Inversion, AR}} where AR&lt;:Optimisers.AbstractRule-api"><a class="docstring-binding" href="#ODINN.train_UDE!-Union{Tuple{AR}, Tuple{Inversion, AR}} where AR&lt;:Optimisers.AbstractRule-api"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>ADAM optim</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/simulations/inversions/inversion_utils.jl#L170-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation-api"><a class="docstring-binding" href="#ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation-api"><code>ODINN.update_training_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_training_state!(simulation::S, l) where {S &lt;: Simulation}</code></pre><p>Update the training state to determine if the training has completed an epoch. If an epoch is completed, reset the minibatches, update the history loss, and increment the epoch count.</p><p><strong>Arguments</strong></p><ul><li><code>simulation</code>: The current state of the simulation or training process.</li><li><code>l</code>: The current loss value or other relevant metric.</li></ul><p><strong>Returns</strong></p><ul><li>None. This function updates the state in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/ML_utils.jl#L189-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.σ_zang-Tuple{Any}-api"><a class="docstring-binding" href="#ODINN.σ_zang-Tuple{Any}-api"><code>ODINN.σ_zang</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">σ_zang(x; β = 2.0)</code></pre><p>Smooth thresholding function for enforcing non-negativity and zero values for negative values following I. Zang, &quot;A smoothing-out technique for min—max optimization&quot; (1980).</p><p><strong>Arguments</strong></p><ul><li><code>x::Real</code>: Input value to be thresholded.</li><li><code>β::Real</code>: (optional) Parameter controlling the transition zone width. Default is 2.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/InitialCondition_utils.jl#L82-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.∂σ_zang-Tuple{Any}-api"><a class="docstring-binding" href="#ODINN.∂σ_zang-Tuple{Any}-api"><code>ODINN.∂σ_zang</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂σ_zang(x; β = 2.0)</code></pre><p>Derivative of the smooth thresholding function <code>σ_zang</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Real</code>: Input value to be thresholded.</li><li><code>β::Real</code>: (optional) Parameter controlling the transition zone width. Default is 2.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/models/trainable_components/InitialCondition_utils.jl#L102-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ODINN.∇²-Union{Tuple{F}, Tuple{Matrix{F}, F, F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#ODINN.∇²-Union{Tuple{F}, Tuple{Matrix{F}, F, F}} where F&lt;:AbstractFloat-api"><code>ODINN.∇²</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∇²(a::Matrix{F}, Δx::F, Δy::F) where {F&lt;:AbstractFloat}</code></pre><p>Computes the 2D Laplacian operator of a scalar field <code>a</code> on a regular grid using finite differences and staggered (dual–primal) averaging.</p><p><strong>Arguments</strong></p><ul><li><code>a::Matrix{F}</code>: 2D scalar field to differentiate.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{F}</code>: Approximation of the Laplacian ∇²a with boundary values set to <code>0.0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/e4666e1626c6d8f6ee398c6b975627348946c702/src/losses/Regularization.jl#L307-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.HalfarParameters-api"><a class="docstring-binding" href="#Huginn.HalfarParameters-api"><code>Huginn.HalfarParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HalfarParameters(; λ=0.0, H₀=3600.0, R₀=750000.0, n=3.0, A=1e-16, f=0.0, ρ=910.0, g=9.81)</code></pre><p>Holds parameters for the Halfar similarity solution of the shallow ice approximation (SIA).</p><p><strong>Parameters</strong></p><ul><li><code>λ::AbstractFloat=0.0</code>: Mass balance coefficient (used to model accumulation/ablation).</li><li><code>H₀::AbstractFloat=3600.0</code>: Dome height at initial time <code>t₀</code> [m].</li><li><code>R₀::AbstractFloat=750000.0</code>: Ice sheet margin radius at <code>t₀</code> [m].</li><li><code>n::AbstractFloat=3.0</code>: Glen flow law exponent.</li><li><code>A::AbstractFloat=1e-16</code>: Flow rate factor in Glen&#39;s law [Pa⁻ⁿ yr⁻¹].</li><li><code>f::AbstractFloat=0.0</code>: Fraction of isostatic bed depression (0 for fully grounded ice).</li><li><code>ρ::AbstractFloat=910.0</code>: Ice density [kg/m³].</li><li><code>g::AbstractFloat=9.81</code>: Gravitational acceleration [m/s²].</li></ul><p><strong>Notes</strong></p><p>Default parameters set as in Bueler (2005) &quot;Exact solutions and verification of numerical models for isothermalice sheets&quot;, experiment B.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/solutions/halfar.jl#L4-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.IceflowModel-api"><a class="docstring-binding" href="#Huginn.IceflowModel-api"><code>Huginn.IceflowModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IceflowModel</code></pre><p>An abstract type representing the base model for ice flow simulations. All specific ice flow models should subtype this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/IceflowModel.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier-api"><a class="docstring-binding" href="#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier-api"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Create a <code>Prediction</code> object using the given model, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for prediction.</li><li><code>glaciers::Vector{G}</code>: A vector of glacier objects, where each glacier is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the prediction.</li></ul><p><strong>Returns</strong></p><ul><li><code>Prediction</code>: A <code>Prediction</code> object based on the input values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/Prediction.jl#L33-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.Prediction-api"><a class="docstring-binding" href="#Huginn.Prediction-api"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Prediction{CACHE} &lt;: Simulation</code></pre><p>A mutable struct that represents a prediction simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the prediction.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the prediction.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the prediction.</li><li><code>results::Vector{Results}</code>: A vector of results obtained from the prediction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/Prediction.jl#L4-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SIA2DCache-api"><a class="docstring-binding" href="#Huginn.SIA2DCache-api"><code>Huginn.SIA2DCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SIA2DCache{
    R &lt;: Real,
    I &lt;: Integer,
    A_CACHE,
    C_CACHE,
    n_CACHE,
    p_CACHE,
    q_CACHE,
    n_H_CACHE,
    n_∇S_CACHE,
    Y_CACHE,
    U_CACHE
} &lt;: SIAmodel</code></pre><p>Store and preallocated all variables needed for running the 2D Shallow Ice Approximation (SIA) model efficiently.</p><p><strong>Type Parameters</strong></p><ul><li><code>R</code>: Real number type used for physical fields.</li><li><code>I</code>: Integer type used for indexing glaciers.</li><li><code>A_CACHE</code>, <code>C_CACHE</code>, <code>n_CACHE</code>: Types used for caching <code>A</code>, <code>C</code>, and <code>n</code>, which can be scalars, vectors, or matrices.</li><li><code>Y_CACHE</code>: Type used for caching <code>Y</code> which is a matrix.</li><li><code>U_CACHE</code>: Type used for caching <code>U</code> which is a matrix.</li></ul><p><strong>Fields</strong></p><ul><li><code>A::A_CACHE</code>: Flow rate factor.</li><li><code>C::C_CACHE</code>: Sliding coefficient.</li><li><code>n::n_CACHE</code>: Flow law exponent.</li><li><code>p::n_CACHE</code>: Sliding law exponent.</li><li><code>q::n_CACHE</code>: Sliding law exponent.</li><li><code>n_H::n_CACHE</code>: Exponent used for the power of <code>H</code> when using the <code>Y</code> law.</li><li><code>n_∇S::n_CACHE</code>: Exponent used for the power of <code>∇S</code> when using the <code>Y</code> law.</li><li><code>Y::Y_CACHE</code>: Hybrid diffusivity.</li><li><code>U::U_CACHE</code>: Diffusive velocity.</li><li><code>H₀::Matrix{R}</code>: Initial ice thickness.</li><li><code>H::Matrix{R}</code>: Ice thickness.</li><li><code>H̄::Matrix{R}</code>: Averaged ice thickness.</li><li><code>S::Matrix{R}</code>: Surface elevation.</li><li><code>dSdx::Matrix{R}</code>: Surface slope in the x-direction.</li><li><code>dSdy::Matrix{R}</code>: Surface slope in the y-direction.</li><li><code>D::Matrix{R}</code>: Diffusivity.</li><li><code>Dx::Matrix{R}</code>: Diffusivity in the x-direction.</li><li><code>Dy::Matrix{R}</code>: Diffusivity in the y-direction.</li><li><code>dSdx_edges::Matrix{R}</code>: Surface slope at edges in the x-direction.</li><li><code>dSdy_edges::Matrix{R}</code>: Surface slope at edges in the y-direction.</li><li><code>∇S::Matrix{R}</code>: Norm of the surface gradient.</li><li><code>∇Sy::Matrix{R}</code>: Surface gradient component in the y-direction.</li><li><code>∇Sx::Matrix{R}</code>: Surface gradient component in the x-direction.</li><li><code>Fx::Matrix{R}</code>: Flux in the x-direction.</li><li><code>Fy::Matrix{R}</code>: Flux in the y-direction.</li><li><code>Fxx::Matrix{R}</code>: Second derivative of flux in the x-direction.</li><li><code>Fyy::Matrix{R}</code>: Second derivative of flux in the y-direction.</li><li><code>V::Matrix{R}</code>: Velocity magnitude.</li><li><code>Vx::Matrix{R}</code>: Velocity in the x-direction.</li><li><code>Vy::Matrix{R}</code>: Velocity in the y-direction.</li><li><code>Γ::A_CACHE</code>: Basal shear stress.</li><li><code>MB::Matrix{R}</code>: Mass balance.</li><li><code>MB_mask::BitMatrix</code>: Boolean mask for applying the mass balance.</li><li><code>MB_total::Matrix{R}</code>: Total mass balance field.</li><li><code>glacier_idx::I</code>: Index of the glacier for use in simulations with multiple glaciers.</li><li><code>A_prep_vjps</code>, <code>C_prep_vjps</code>, <code>n_prep_vjps</code>, <code>Y_prep_vjps</code> and <code>U_prep_vjps</code>: Structs that contain the prepared VJP functions for the adjoint computation and for the different laws. Useful mainly when the user does not provide the VJPs and they are automatically inferred using DifferentiationInterface.jl which requires to store precompiled functions. When no gradient is computed, these structs are <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D.jl#L191-L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SIA2Dmodel-api"><a class="docstring-binding" href="#Huginn.SIA2Dmodel-api"><code>Huginn.SIA2Dmodel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SIA2Dmodel(A, C, n, Y, U, n_H, n_∇S)
SIA2Dmodel(params; A, C, n, Y, U, n_H, n_∇S)</code></pre><p>Create a <code>SIA2Dmodel</code>, representing a two-dimensional Shallow Ice Approximation (SIA) model.</p><p>The SIA model describes glacier flow under the assumption that deformation and basal sliding dominate the ice dynamics. It relies on:</p><ul><li><p>Glen&#39;s flow law for internal deformation, with flow rate factor <code>A</code> and exponent <code>n</code>,</p></li><li><p>A sliding law governed by coefficient <code>C</code>,</p></li><li><p>Optionally the user can provide either:</p><ul><li>A specific diffusive velocity <code>U</code> such that <code>D = U * H</code></li><li>A modified creep coefficient <code>Y</code> that takes into account the ice thickness such that <code>D = (C + Y * 2/(n+2)) * (ρ*g)^n * H^(n_H+1) * |∇S|^(n_∇S-1)</code> where <code>n_H</code> and <code>n_∇S</code> are optional parameters that control if the SIA should use the <code>n</code> law or not. This formulation is denoted as the hybrid diffusivity in the code.</li></ul></li></ul><p>This struct stores the laws used to compute these three parameters during a simulation. If not provided, default constant laws are used based on glacier-specific values.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Law for the flow rate factor. Defaults to a constant value from the glacier.</li><li><code>C</code>: Law for the sliding coefficient. Defaults similarly.</li><li><code>n</code>: Law for the flow law exponent. Defaults similarly.</li><li><code>p</code>: Law for the sliding law exponent (basal drag). Defaults similarly.</li><li><code>q</code>: Law for the sliding law exponent (normal stress). Defaults similarly.</li><li><code>Y</code>: Law for the hybrid diffusivity. Providing a law for <code>Y</code> discards the laws of <code>A</code>, <code>C</code> and <code>n</code>.</li><li><code>U</code>: Law for the diffusive velocity. Defaults behavior is to disable it and in such a case it is computed from <code>A</code>, <code>C</code> and <code>n</code>. Providing a law for <code>U</code> discards the laws of <code>A</code>, <code>C</code>, <code>n</code> and <code>Y</code>.</li><li><code>n_H::F</code>: The exponent to use for <code>H</code> in the SIA equation when using the Y law (hybrid diffusivity). It should be <code>nothing</code> when this law is not used.</li><li><code>n_∇S::F</code>: The exponent to use for <code>∇S</code> in the SIA equation when using the Y law (hybrid diffusivity). It should be <code>nothing</code> when this law is not used.</li><li><code>Y_is_provided::Bool</code>: Whether the diffusivity is provided by the user through the hybrid diffusivity <code>Y</code> or it has to be computed from the SIA formula from <code>A</code>, <code>C</code> and <code>n</code>.</li><li><code>U_is_provided::Bool</code>: Whether the diffusivity is provided by the user through the diffusive velocity <code>U</code> or it has to be computed from the SIA formula from <code>A</code>, <code>C</code> and <code>n</code>.</li><li><code>n_H_is_provided::Bool</code>: Whether the <code>H</code> exponent is prescribed by the user, or the one of the <code>n</code> law has to be used. This flag is used only when a law for <code>Y</code> is used.</li><li><code>n_∇S_is_provided::Bool</code>: Whether the <code>∇S</code> exponent is prescribed by the user, or the one of the <code>n</code> law has to be used. This flag is used only when a law for <code>Y</code> is used.</li><li><code>apply_A_in_SIA::Bool</code>: Whether the value of the <code>A</code> law should be computed each time the SIA is evaluated.</li><li><code>apply_C_in_SIA::Bool</code>: Whether the value of the <code>C</code> law should be computed each time the SIA is evaluated.</li><li><code>apply_n_in_SIA::Bool</code>: Whether the value of the <code>n</code> law should be computed each time the SIA is evaluated.</li><li><code>apply_p_in_SIA::Bool</code>: Whether the value of the <code>p</code> law should be computed each time the SIA is evaluated.</li><li><code>apply_q_in_SIA::Bool</code>: Whether the value of the <code>q</code> law should be computed each time the SIA is evaluated.</li><li><code>apply_Y_in_SIA::Bool</code>: Whether the value of the <code>Y</code> law should be computed each time the SIA is evaluated.</li><li><code>apply_U_in_SIA::Bool</code>: Whether the value of the <code>U</code> law should be computed each time the SIA is evaluated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D.jl#L10-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SIAmodel-api"><a class="docstring-binding" href="#Huginn.SIAmodel-api"><code>Huginn.SIAmodel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SIAmodel</code></pre><p>An abstract type representing the Shallow Ice Approximation (SIA) models. This type is a subtype of <code>IceflowModel</code> and serves as a base for all SIA-specific models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/IceflowModel.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><a class="docstring-binding" href="#Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Constructs a <code>SolverParameters</code> object with the specified parameters or using default values.</p><pre><code class="nohighlight hljs">SolverParameters(;
    solver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),
    reltol::F = 1e-12,
    step::F = 1.0/12.0,
    tstops::Vector{Sleipnir.Float} = Vector{Sleipnir.Float}(),
    save_everystep = false,
    progress::Bool = true,
    progress_steps::I = 10,
    maxiters::I = Int(1e5),
) where {F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>solver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm</code>: The ODE solver algorithm to use. Defaults to <code>RDPK3Sp35()</code>.</li><li><code>reltol::F</code>: The relative tolerance for the solver. Defaults to <code>1e-12</code>.</li><li><code>step::F</code>: The step size that controls at which frequency the solution should be computed and returned in the results. Defaults to <code>1.0/12.0</code> (i.e. a month).</li><li><code>tstops::Vector{Sleipnir.Float}</code>: Optional vector of time points where the solver should stop. Defaults to an empty vector.</li><li><code>save_everystep::Bool</code>: Whether to save the solution at every step computed by the solver. Defaults to <code>false</code>.</li><li><code>progress::Bool</code>: Whether to show progress during the solving process. Defaults to <code>true</code>.</li><li><code>progress_steps::I</code>: The number of steps between progress updates. Defaults to <code>10</code>.</li><li><code>maxiters::I</code>: Maximum number of iterations to perform in the iceflow solver. Defaults to <code>1e5</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>solver_parameters</code>: A <code>SolverParameters</code> object constructed with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/parameters/SolverParameters.jl#L30-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SolverParameters-api"><a class="docstring-binding" href="#Huginn.SolverParameters-api"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A mutable struct that holds parameters for the solver.</p><pre><code class="nohighlight hljs">SolverParameters{F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Fields</strong></p><ul><li><code>solver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm</code>: The algorithm used for solving differential equations.</li><li><code>reltol::F</code>: The relative tolerance for the solver.</li><li><code>step::F</code>: The step size that controls at which frequency the results must be saved.</li><li><code>tstops::Vector{F}</code>: Optional vector of time points where the solver should stop to store the results.</li><li><code>save_everystep::Bool</code>: Flag indicating whether to save the solution at every step computed by the solver.</li><li><code>progress::Bool</code>: Flag indicating whether to show progress during the solving process.</li><li><code>progress_steps::I</code>: The number of steps between progress updates.</li><li><code>maxiters::I</code>: Maximum number of iterations to perform in the iceflow solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/parameters/SolverParameters.jl#L3-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.iAvgGriddedTemp-api"><a class="docstring-binding" href="#Huginn.iAvgGriddedTemp-api"><code>Huginn.iAvgGriddedTemp</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">iAvgGriddedTemp &lt;: AbstractInput</code></pre><p>Input that represents the long term air temperature over the glacier grid. It is computed using the OGGM climate data over a period predefined in Gungnir (i.e. around 30 years).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Inputs.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.iAvgScalarTemp-api"><a class="docstring-binding" href="#Huginn.iAvgScalarTemp-api"><code>Huginn.iAvgScalarTemp</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">iAvgScalarTemp &lt;: AbstractInput</code></pre><p>Input that represents the long term air temperature over the whole glacier. It is computed using the OGGM climate data over a period predefined in Gungnir (i.e. around 30 years).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Inputs.jl#L5-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.iCPDD-api"><a class="docstring-binding" href="#Huginn.iCPDD-api"><code>Huginn.iCPDD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">iCPDD &lt;: AbstractInput</code></pre><p>Input that represents the cumulative positive degree days (PDD) over the last time window <code>window</code>. It is computed by summing the daily PDD values from <code>t - window</code> to <code>t</code> using the glacier&#39;s climate data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Inputs.jl#L41-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.iH̄-api"><a class="docstring-binding" href="#Huginn.iH̄-api"><code>Huginn.iH̄</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">iH̄ &lt;: AbstractInput</code></pre><p>Input that represents the ice thickness in the SIA. It is the averaged ice thickness computed on the dual grid, that is <code>H̄ = avg(H)</code> which is different from the ice thickness solution H.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Inputs.jl#L72-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.iTopoRough-api"><a class="docstring-binding" href="#Huginn.iTopoRough-api"><code>Huginn.iTopoRough</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">iTopoRough{F&lt;:AbstractFloat} &lt;: AbstractInput</code></pre><p>Input that represents the topographic roughness of the glacier. It is computed as the curvature of the glacier bed (or surface) over a specified window size. The curvature can be calculated in different directions (flow, cross-flow, or both) and using different curvature types (scalar or variability).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Inputs.jl#L111-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.i∇S-api"><a class="docstring-binding" href="#Huginn.i∇S-api"><code>Huginn.i∇S</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">i∇S &lt;: AbstractInput</code></pre><p>Input that represents the surface slope in the SIA. It is computed using the bedrock elevation and the ice thickness solution H. The spatial differences are averaged over the opposite axis:</p><pre><code class="language-julia hljs">S = B + H
∇S = (avg_y(diff_x(S) / Δx) .^ 2 .+ avg_x(diff_y(S) / Δy) .^ 2) .^ (1/2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Inputs.jl#L89-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.ConstantA-Tuple{F} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Huginn.ConstantA-Tuple{F} where F&lt;:AbstractFloat-api"><code>Huginn.ConstantA</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ConstantA(A::F) where {F &lt;: AbstractFloat}</code></pre><p>Law that represents a constant A in the SIA.</p><p><strong>Arguments:</strong></p><ul><li><code>A::F</code>: Rheology factor A.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Laws.jl#L3-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.CuffeyPaterson-Tuple{}-api"><a class="docstring-binding" href="#Huginn.CuffeyPaterson-Tuple{}-api"><code>Huginn.CuffeyPaterson</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CuffeyPaterson(; scalar::Bool = true)</code></pre><p>Create a rheology law for the flow rate factor <code>A</code>. The created law maps the long term air temperature to <code>A</code> using the values from Cuffey &amp; Peterson through <code>polyA_PatersonCuffey</code> that returns a polynomial which is then evaluated at a given temperature in the law.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Laws.jl#L33-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.Halfar-Tuple{HalfarParameters}-api"><a class="docstring-binding" href="#Huginn.Halfar-Tuple{HalfarParameters}-api"><code>Huginn.Halfar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Halfar(halfar_params::HalfarParameters) -&gt; (_halfar::Function, t₀_years::Float64)</code></pre><p>Constructs the Halfar similarity solution to the SIA for a radially symmetric ice sheet dome following Bueler (2005) &quot;Exact solutions and verification of numerical models for isothermalice sheets&quot;</p><p><strong>Arguments</strong></p><ul><li><code>halfar_params::HalfarParameters</code>: A struct containing physical and geometric parameters for the Halfar solution, including dome height, margin radius, Glen exponent, and other constants.</li></ul><p><strong>Returns</strong></p><ul><li><code>_halfar::Function</code>: A function <code>(x, y, t) -&gt; H</code> that evaluates the ice thickness <code>H</code> at position <code>(x, y)</code> and time <code>t</code> (in <strong>years</strong>).</li><li><code>t₀_years::Float64</code>: The characteristic timescale <code>t₀</code> (in <strong>years</strong>) of the solution, based on the specified parameters.</li></ul><p><strong>Description</strong></p><p>The solution has the form:</p><p class="math-container">\[H(r, t) = H₀ (t / t₀)^(-α) [1 - ((t / t₀)^(-β) (r / R₀))^((n+1)/n)]^{n / (2n + 1)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/solutions/halfar.jl#L41-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.Halfar_velocity-Tuple{HalfarParameters}-api"><a class="docstring-binding" href="#Huginn.Halfar_velocity-Tuple{HalfarParameters}-api"><code>Huginn.Halfar_velocity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Halfar_velocity(halfar_params::HalfarParameters)</code></pre><p>Same as Halfar(halfar_params), but instead of returning a function that gives the ice thickness as a function of space and time, this returns the ice surface velocity according to the Shallow Ice Approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/solutions/halfar.jl#L101-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R, Any}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R, Any}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><code>Huginn.SIA2D!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SIA2D!(
    dH::Matrix{R},
    H::Matrix{R},
    simulation::SIM,
    t::R,
    θ,
) where {R &lt;:Real, SIM &lt;: Simulation}</code></pre><p>Simulates the evolution of ice thickness in a 2D shallow ice approximation (SIA) model. Works in-place.</p><p><strong>Arguments</strong></p><ul><li><code>dH::Matrix{R}</code>: Matrix to store the rate of change of ice thickness.</li><li><code>H::Matrix{R}</code>: Matrix representing the ice thickness.</li><li><code>simulation::SIM</code>: Simulation object containing model parameters and state.</li><li><code>t::R</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p><strong>Details</strong></p><p>This function updates the ice thickness <code>H</code> and computes the rate of change <code>dH</code> using the shallow ice approximation in 2D. It retrieves necessary parameters from the <code>simulation</code> object, enforces positive ice thickness values, updates glacier surface altimetry and computes surface gradients. It then applies the necessary laws that are not updated via callbacks (<code>A</code>, <code>C</code>, <code>n</code> or <code>U</code> depending on the use-case) and computes the flux components, and flux divergence.</p><p><strong>Notes</strong></p><ul><li>The function operates on a staggered grid for computing gradients and fluxes.</li><li>Surface elevation differences are capped using upstream ice thickness to impose boundary conditions.</li><li>The function modifies the input matrices <code>dH</code> and <code>H</code> in-place.</li></ul><p>See also <code>SIA2D</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L3-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.SyntheticC-Tuple{Sleipnir.Parameters}-api"><a class="docstring-binding" href="#Huginn.SyntheticC-Tuple{Sleipnir.Parameters}-api"><code>Huginn.SyntheticC</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SyntheticC(params::Sleipnir.Parameters)</code></pre><p>Creates a synthetic law for calculating the parameter <code>C</code> using a nonlinear sigmoid transformation based on the ratio of <code>CPDD</code> (cumulative positive degree days) to <code>topo_roughness</code> (topographic roughness). The law is parameterized by minimum and maximum values (<code>Cmin</code>, <code>Cmax</code>) from <code>params.physical</code>, and applies a sigmoid scaling to smoothly interpolate between these bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Laws.jl#L73-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.V_from_H-Union{Tuple{SIM}, Tuple{F}, Tuple{SIM, Matrix{F}, Real, Any}} where {F&lt;:AbstractFloat, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#Huginn.V_from_H-Union{Tuple{SIM}, Tuple{F}, Tuple{SIM, Matrix{F}, Real, Any}} where {F&lt;:AbstractFloat, SIM&lt;:Simulation}-api"><code>Huginn.V_from_H</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V_from_H(
    simulation::SIM,
    H::Matrix{F},
    t::Real,
    θ,
) where {F &lt;: AbstractFloat, SIM &lt;: Simulation}</code></pre><p>Compute surface velocity from ice thickness using the SIA model. It relies on <code>surface_V</code> to compute <code>Vx</code> and <code>Vy</code> and it additionally computes the magnitude of the velocity <code>V</code>.</p><p>Arguments:</p><ul><li><code>simulation::SIM</code>: The simulation structure used to retrieve the physical parameters.</li><li><code>H::Matrix{F}</code>: The ice thickness matrix.</li><li><code>t::R</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p>Returns:</p><ul><li><code>Vx</code>: x axis component of the surface velocity.</li><li><code>Vy</code>: y axis component of the surface velocity.</li><li><code>V</code>: Magnitude velocity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L549-L574">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.apply_MB_mask!-Tuple{Any, SIA2DCache}-api"><a class="docstring-binding" href="#Huginn.apply_MB_mask!-Tuple{Any, SIA2DCache}-api"><code>Huginn.apply_MB_mask!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_MB_mask!(H, ifm::SIA2DCache)</code></pre><p>Apply the mass balance (MB) mask to the iceflow model in-place. This function ensures that no MB is applied on the borders of the glacier to prevent overflow.</p><p><strong>Arguments:</strong></p><ul><li><code>H</code>: Ice thickness.</li><li><code>ifm::SIA2DCache</code>: Iceflow cache of the SIA2D that provides the mass balance information and that is modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L318-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg!-Tuple{Any, Any}-api"><a class="docstring-binding" href="#Huginn.avg!-Tuple{Any, Any}-api"><code>Huginn.avg!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg!(O, I)</code></pre><p>Compute the average of adjacent elements in the input array <code>I</code> and store the result in the output array <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the averaged values will be stored.</li><li><code>I</code>: Input array from which the adjacent elements will be averaged.</li></ul><p><strong>Details</strong></p><p>This function uses the <code>@views</code> macro to avoid creating temporary arrays and the <code>@.</code> macro to broadcast the operations. The averaging is performed by taking the mean of each 2x2 block of elements in <code>I</code> and storing the result in the corresponding element in <code>O</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L46-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.avg-Tuple{Any}-api"><code>Huginn.avg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg(A::AbstractArray)</code></pre><p>Compute the average of each 2x2 block in the input array <code>A</code>. The result is an array where each element is the average of the corresponding 2x2 block in <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: A 2D array of numerical values.</li></ul><p><strong>Returns</strong></p><ul><li>A 2D array of the same type as <code>A</code>, where each element is the average of a 2x2 block from <code>A</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L91-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg_surface_V!-Union{Tuple{R}, Tuple{SIM}, Tuple{SIM, R, Any}} where {SIM&lt;:Simulation, R&lt;:Real}-api"><a class="docstring-binding" href="#Huginn.avg_surface_V!-Union{Tuple{R}, Tuple{SIM}, Tuple{SIM, R, Any}} where {SIM&lt;:Simulation, R&lt;:Real}-api"><code>Huginn.avg_surface_V!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg_surface_V!(simulation::SIM, t::R, θ) where {SIM &lt;: Simulation, R &lt;: Real}</code></pre><p>Calculate the average surface velocity for a given simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: A simulation object of type <code>SIM</code> which is a subtype of <code>Simulation</code>.</li><li><code>t::R</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p><strong>Description</strong></p><p>This function computes the average surface velocity components (<code>Vx</code> and <code>Vy</code>) and the resultant velocity (<code>V</code>) for the ice flow model within the given simulation. It first calculates the surface velocities at the initial and current states, then averages these velocities and updates the ice flow model&#39;s velocity fields.</p><p><strong>Notes</strong></p><ul><li>The function currently uses a simple averaging method and may need more datapoints for better interpolation.    # TODO: Add more datapoints to better interpolate this</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L298-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg_x!-Tuple{Any, Any}-api"><a class="docstring-binding" href="#Huginn.avg_x!-Tuple{Any, Any}-api"><code>Huginn.avg_x!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg_x!(O, I)</code></pre><p>Compute the average of adjacent elements along the first dimension of array <code>I</code> and store the result in array <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the averaged values will be stored.</li><li><code>I</code>: Input array from which adjacent elements will be averaged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L65-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg_x-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.avg_x-Tuple{Any}-api"><code>Huginn.avg_x</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg_x(A::AbstractArray)</code></pre><p>Compute the average of adjacent elements along the first dimension of the array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: Input array.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> with one less element along the first dimension, containing the averages of adjacent elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L107-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg_y!-Tuple{Any, Any}-api"><a class="docstring-binding" href="#Huginn.avg_y!-Tuple{Any, Any}-api"><code>Huginn.avg_y!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg_y!(O, I)</code></pre><p>Compute the average of adjacent elements along the second dimension of array <code>I</code> and store the result in array <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the averaged values will be stored.</li><li><code>I</code>: Input array from which the adjacent elements will be averaged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L77-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.avg_y-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.avg_y-Tuple{Any}-api"><code>Huginn.avg_y</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">avg_y(A::AbstractArray)</code></pre><p>Compute the average of adjacent elements along the second dimension of the input array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: An array of numeric values.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> containing the averages of adjacent elements along the second dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L122-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer-api"><a class="docstring-binding" href="#Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer-api"><code>Huginn.batch_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE!(glacier_idx::I, simulation::Prediction) where {I &lt;: Integer}</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE in-place for a given set of laws prescribed in the simulation object. It creates the iceflow problem, the necessary callbacks and solve the PDE.</p><p><strong>Arguments:</strong></p><ul><li><code>glacier_idx::I</code>: Integer ID of the glacier.</li><li><code>simulation::Prediction</code>: Simulation object that contains all the necessary information to solve the iceflow.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Results</code> instance that stores the iceflow solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L19-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.build_callback-Tuple{SIA2Dmodel, SIA2DCache, Real, Any, Any}-api"><a class="docstring-binding" href="#Huginn.build_callback-Tuple{SIA2Dmodel, SIA2DCache, Real, Any, Any}-api"><code>Huginn.build_callback</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_callback(model::SIA2Dmodel, cache::SIA2DCache, glacier_idx::Real, θ, tspan) -&gt; CallbackSet</code></pre><p>Return a <code>CallbackSet</code> that updates the cached values of <code>A</code>, <code>C</code>, <code>n</code> and <code>U</code> at provided time intervals.</p><p>Each law can optionally specify a callback frequency via <code>callback_freq</code>.</p><ul><li>If <code>callback_freq &gt; 0</code>, a <code>PeriodicCallback</code> is used to update the corresponding component at regular intervals.</li><li>If <code>callback_freq == 0</code>, a <code>PresetTimeCallback</code> is used to trigger the update only at the initial time (taken from <code>tspan[1]</code>).</li><li>If no callback is specified for a component, a dummy <code>CallbackSet</code> is returned.</li></ul><p>Arguments:</p><ul><li><code>model::SIA2Dmodel</code>: The ice flow model definition.</li><li><code>cache::SIA2DCache</code>: Model cache for efficient component access and updates.</li><li><code>glacier_idx::Real</code>: Index of the glacier in the simulation.</li><li><code>θ</code>: Optional parameter for law evaluation.</li><li><code>tspan</code>: Tuple or floats specifying the simulation time span. Used to determine initial callback time when <code>freq == 0</code>.</li></ul><p>Returns:</p><ul><li>A <code>CallbackSet</code> containing all the callbacks for periodic or preset updates of model components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D.jl#L423-L446">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.d2dx-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64}} where T&lt;:Real-api"><a class="docstring-binding" href="#Huginn.d2dx-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64}} where T&lt;:Real-api"><code>Huginn.d2dx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d2dx(f::Matrix{T}, i::Int, j::Int, Δx::Float64) where T &lt;: Real</code></pre><p>Compute the second central difference in the x-direction at (i,j).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L199-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.d2dxy-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64, Float64}} where T&lt;:Real-api"><a class="docstring-binding" href="#Huginn.d2dxy-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64, Float64}} where T&lt;:Real-api"><code>Huginn.d2dxy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d2dxy(f::Matrix{T}, i::Int, j::Int, Δx::Float64, Δy::Float64) where T &lt;: Real</code></pre><p>Compute the mixed second central difference (∂²f/∂x∂y) at (i,j).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L217-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.d2dy-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64}} where T&lt;:Real-api"><a class="docstring-binding" href="#Huginn.d2dy-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64}} where T&lt;:Real-api"><code>Huginn.d2dy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d2dy(f::Matrix{T}, i::Int, j::Int, Δy::Float64) where T &lt;: Real</code></pre><p>Compute the second central difference in the y-direction at (i,j).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L208-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F&lt;:AbstractFloat-api"><code>Huginn.define_callback_steps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">define_callback_steps(tspan::Tuple{F, F}, step::F) where {F &lt;: AbstractFloat}</code></pre><p>Defines the times to stop for the DiscreteCallback given a step and a timespan.</p><p><strong>Arguments</strong></p><ul><li><code>tspan::Tuple{F, F}</code>: A tuple representing the start and end times.</li><li><code>step::F</code>: The step size for generating the callback steps.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{F}</code>: A vector of callback steps within the specified time span.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/parameters/SolverParameters.jl#L105-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.diff_x!-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#Huginn.diff_x!-Tuple{Any, Any, Any}-api"><code>Huginn.diff_x!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diff_x!(O, I, Δx)</code></pre><p>Compute the finite difference of array <code>I</code> along the first dimension and store the result in array <code>O</code>. The difference is computed using the spacing <code>Δx</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array to store the finite differences.</li><li><code>I</code>: Input array from which finite differences are computed.</li><li><code>Δx</code>: Spacing between points in the first dimension.</li></ul><p><strong>Notes</strong></p><ul><li>The function uses <code>@views</code> to avoid copying data when slicing arrays.</li><li>The operation is performed in-place, modifying the contents of <code>O</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L7-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.diff_x-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.diff_x-Tuple{Any}-api"><code>Huginn.diff_x</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diff_x(A::AbstractArray)</code></pre><p>Compute the difference along the first dimension of the array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: Input array.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> containing the differences along the first dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L137-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.diff_y!-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#Huginn.diff_y!-Tuple{Any, Any, Any}-api"><code>Huginn.diff_y!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diff_y!(O, I, Δy)</code></pre><p>Compute the finite difference along the y-axis and store the result in <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the result will be stored.</li><li><code>I</code>: Input array from which the finite difference is computed.</li><li><code>Δy</code>: The spacing between points in the y-direction.</li></ul><p><strong>Description</strong></p><p>This function calculates the finite difference along the y-axis for the input array <code>I</code> and stores the result in the output array <code>O</code>. The calculation is performed using the formula:</p><pre><code class="nohighlight hljs">O = (I[:,begin+1:end] - I[:,1:end - 1]) / Δy</code></pre><p>The <code>@views</code> macro is used to avoid copying data when slicing the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L25-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.diff_y-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.diff_y-Tuple{Any}-api"><code>Huginn.diff_y</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diff_y(A::AbstractArray)</code></pre><p>Compute the difference between adjacent elements along the second dimension (columns) of the input array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: An array of numeric values.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> containing the differences between adjacent elements along the second dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L153-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}-api"><a class="docstring-binding" href="#Huginn.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}-api"><code>Huginn.generate_ground_truth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_ground_truth(
    glaciers::Vector{G},
    params::Sleipnir.Parameters,
    model::Sleipnir.Model,
    tstops::Vector{F};
    store::Tuple=(:H, :V),
) where {G &lt;: Sleipnir.AbstractGlacier, F &lt;: AbstractFloat}</code></pre><p>Generate ground truth data for a glacier simulation by using the laws specified in the model and running a forward model. It returns a new vector of glaciers with updated <code>thicknessData</code> and <code>velocityData</code> fields based on the <code>store</code> argument.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{G}</code>: A vector of glacier objects of type <code>G</code>, where <code>G</code> is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>params::Sleipnir.Parameters</code>: Simulation parameters.</li><li><code>model::Sleipnir.Model</code>: The model to use for the simulation.</li><li><code>tstops::Vector{F}</code>: A vector of time steps at which the simulation will be evaluated.</li><li><code>store::Tuple</code>: Which generated simulation products to store. It can include <code>:H</code> and/or <code>:V</code>.</li></ul><p><strong>Description</strong></p><ol><li>Runs a forward model simulation for the glaciers using the provided laws, parameters, model, and time steps.</li><li>Build a new vector of glaciers and store the simulation results as ground truth in the <code>glaciers</code> struct. For each glacier it populates the <code>thicknessData</code> field if <code>store</code> contains <code>:H</code> and it populates <code>velocityData</code> if <code>store</code> contains <code>:V</code>.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">glaciers = [glacier1, glacier2] # dummy example
params = Huginn.Parameters() # to be filled
model = Huginn.Model() # to be filled
tstops = 0.0:1.0:10.0

glaciers = generate_ground_truth(glaciers, params, model, tstops)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L215-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.generate_ground_truth_prediction-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}-api"><a class="docstring-binding" href="#Huginn.generate_ground_truth_prediction-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}-api"><code>Huginn.generate_ground_truth_prediction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_ground_truth_prediction(
    glaciers::Vector{G},
    params::Sleipnir.Parameters,
    model::Sleipnir.Model,
    tstops::Vector{F},
) where {G &lt;: Sleipnir.AbstractGlacier, F &lt;: AbstractFloat}</code></pre><p>Wrapper for <code>generate_ground_truth</code> that also updates the <code>glaciers</code> field of the <code>Prediction</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{G}</code>: A vector of glacier objects of type <code>G</code>, where <code>G</code> is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>params::Sleipnir.Parameters</code>: Simulation parameters.</li><li><code>model::Sleipnir.Model</code>: The model to use for the simulation.</li><li><code>tstops::Vector{F}</code>: A vector of time steps at which the simulation will be evaluated.</li></ul><p><strong>Description</strong></p><p>This function calls <code>generate_ground_truth</code> to generate ground truth data for the glaciers using the provided laws, parameters, model, and time steps. In addition, it updates the <code>glaciers</code> field of the <code>Prediction</code> object with the newly generated glaciers containing the ground truth data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">glaciers = [glacier1, glacier2] # dummy example
params = Huginn.Parameters() # to be filled
model = Huginn.Model() # to be filled
tstops = 0.0:1.0:10.0

prediction = generate_ground_truth_prediction(glaciers, params, model, tstops)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L271-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.generate_result-Union{Tuple{SIM}, Tuple{SIM, Any, Any}} where SIM&lt;:Simulation-api"><a class="docstring-binding" href="#Huginn.generate_result-Union{Tuple{SIM}, Tuple{SIM, Any, Any}} where SIM&lt;:Simulation-api"><code>Huginn.generate_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_result(placeholder_sim::SIM, A, n) where {SIM &lt;: Simulation}</code></pre><p>Generate the result of a simulation by initializing the model with the specified parameters and running the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: An instance of a type that is a subtype of <code>Simulation</code>.</li><li><code>A</code>: The parameter to set for <code>simulation.model.iceflow.A</code>.</li><li><code>n</code>: The parameter to set for <code>simulation.model.iceflow.n</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>result</code>: The first result from the simulation&#39;s results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/plotting/plotting_utils.jl#L106-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.inn-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.inn-Tuple{Any}-api"><code>Huginn.inn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inn(A::AbstractArray)</code></pre><p>Extracts the inner part of a 2D array <code>A</code>, excluding the first and last rows and columns.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: A 2D array from which the inner part will be extracted.</li></ul><p><strong>Returns</strong></p><ul><li>A subarray of <code>A</code> containing all elements except the first and last rows and columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L169-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.inn1-Tuple{Any}-api"><a class="docstring-binding" href="#Huginn.inn1-Tuple{Any}-api"><code>Huginn.inn1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inn1(A::AbstractArray)</code></pre><p>Returns a view of the input array <code>A</code> excluding the last row and the last column.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The input array from which a subarray view is created.</li></ul><p><strong>Returns</strong></p><ul><li>A view of the input array <code>A</code> that includes all elements except the last row and the last column.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L184-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.polyA_PatersonCuffey-Tuple{}-api"><a class="docstring-binding" href="#Huginn.polyA_PatersonCuffey-Tuple{}-api"><code>Huginn.polyA_PatersonCuffey</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polyA_PatersonCuffey()</code></pre><p>Returns a function of the coefficient A as a polynomial of the temperature. The values used to fit the polynomial come from Cuffey &amp; Peterson.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/laws/Laws.jl#L19-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.precompute_all_VJPs_laws!-Tuple{SIA2Dmodel, SIA2DCache, Prediction, Integer, Real, Any}-api"><a class="docstring-binding" href="#Huginn.precompute_all_VJPs_laws!-Tuple{SIA2Dmodel, SIA2DCache, Prediction, Integer, Real, Any}-api"><code>Huginn.precompute_all_VJPs_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">precompute_all_VJPs_laws!(
    SIA2D_model::SIA2Dmodel,
    SIA2D_cache::SIA2DCache,
    simulation::Prediction,
    glacier_idx::Integer,
    t::Real,
    θ,
)</code></pre><p>Function that does nothing and its existence is just to support multiple dispatch. The implementation that is useful is available in ODINN when simulation is a <code>Inversion</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L273-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.project_curvatures-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#Huginn.project_curvatures-Tuple{Any, Any, Any}-api"><code>Huginn.project_curvatures</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">project_curvatures(H, eₚ, eₛ)</code></pre><p>Computes the scalar second derivative of the surface in a specific direction.</p><p><strong>Arguments</strong></p><ul><li><code>H</code>: Hessian matrix (2x2).</li><li><code>eₚ</code>: Principal direction vector 1 (2x1).</li><li><code>eₛ</code>: Principal direction vector 2 (2x1).</li></ul><p><strong>Returns</strong></p><ul><li><code>Kₚ</code>: Curvature in the direction of <code>eₚ</code>.</li><li><code>Kₛ</code>: Curvature in the direction of <code>eₛ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L227-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.run!-Tuple{Prediction}-api"><a class="docstring-binding" href="#Huginn.run!-Tuple{Prediction}-api"><code>Huginn.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(simulation::Prediction)</code></pre><p>In-place run of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.simulate_iceflow_PDE!-Union{Tuple{F}, Tuple{SIM}, Tuple{SIM, SciMLBase.DECallback, Any, Vector{F}}} where {SIM&lt;:Simulation, F&lt;:AbstractFloat}-api"><a class="docstring-binding" href="#Huginn.simulate_iceflow_PDE!-Union{Tuple{F}, Tuple{SIM}, Tuple{SIM, SciMLBase.DECallback, Any, Vector{F}}} where {SIM&lt;:Simulation, F&lt;:AbstractFloat}-api"><code>Huginn.simulate_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_iceflow_PDE!(
    simulation::SIM,
    cb::SciMLBase.DECallback,
    du,
    tstops::Vector{F},
) where {SIM &lt;: Simulation, F &lt;: AbstractFloat}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code> in-place and create the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L84-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.surface_V!-Union{Tuple{R}, Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM, R, Any}} where {SIM&lt;:Simulation, R&lt;:Real}-api"><a class="docstring-binding" href="#Huginn.surface_V!-Union{Tuple{R}, Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM, R, Any}} where {SIM&lt;:Simulation, R&lt;:Real}-api"><code>Huginn.surface_V!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">surface_V!(H::Matrix{&lt;:Real}, simulation::SIM, t::R, θ) where {SIM &lt;: Simulation, R &lt;: Real}</code></pre><p>Compute the surface velocities of a glacier using the Shallow Ice Approximation (SIA) in 2D.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{&lt;:Real}</code>: The ice thickness matrix.</li><li><code>simulation::SIM</code>: The simulation object containing parameters and model information.</li><li><code>t::R</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vx</code>: The x-component of the surface velocity.</li><li><code>Vy</code>: The y-component of the surface velocity.</li></ul><p><strong>Description</strong></p><p>This function updates the glacier surface altimetry and computes the surface gradients on edges using a staggered grid. It then calculates the surface velocities based on the Shallow Ice Approximation (SIA) model.</p><p><strong>Details</strong></p><ul><li><code>params</code>: The simulation parameters.</li><li><code>iceflow_model</code>: The ice flow model from the simulation.</li><li><code>glacier</code>: The glacier object from the simulation.</li><li><code>B</code>: The bedrock elevation matrix.</li><li><code>H̄</code>: The average ice thickness matrix.</li><li><code>dSdx</code>, <code>dSdy</code>: The surface gradient matrices in x and y directions.</li><li><code>∇S</code>, <code>∇Sx</code>, <code>∇Sy</code>: The gradient magnitude and its components.</li><li><code>Γꜛ</code>: The surface stress.</li><li><code>D</code>: The diffusivity matrix.</li><li><code>A</code>: The flow rate factor.</li><li><code>n</code>: The flow law exponent.</li><li><code>C</code>: The sliding coefficient.</li><li><code>Δx</code>, <code>Δy</code>: The grid spacing in x and y directions.</li><li><code>ρ</code>: The ice density.</li><li><code>g</code>: The gravitational acceleration.</li></ul><p>The function computes the surface gradients, averages the ice thickness, and calculates the surface stress and diffusivity. Finally, it computes the surface velocities <code>Vx</code> and <code>Vy</code> based on the gradients and diffusivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L331-L371">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, SIM, Real, Any}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, SIM, Real, Any}} where {R&lt;:Real, SIM&lt;:Simulation}-api"><code>Huginn.surface_V</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">surface_V(
    H::Matrix{R},
    simulation::SIM,
    t::Real,
    θ,
) where {R &lt;: Real, SIM &lt;: Simulation}</code></pre><p>Compute the surface velocities of a glacier using the Shallow Ice Approximation (SIA) in 2D.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{R}</code>: Ice thickness matrix.</li><li><code>simulation::SIM</code>: Simulation object containing parameters and model information.</li><li><code>t::R</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vx</code>: Matrix of surface velocities in the x-direction.</li><li><code>Vy</code>: Matrix of surface velocities in the y-direction.</li></ul><p><strong>Details</strong></p><p>This function computes the surface velocities of a glacier by updating the glacier surface altimetry and calculating the surface gradients on the edges. It uses a staggered grid approach to compute the gradients and velocities.</p><p><strong>Notes</strong></p><ul><li>The function assumes that the <code>simulation</code> object contains the necessary parameters and model information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L446-L475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.thickness_velocity_data-Union{Tuple{F}, Tuple{Prediction, Vector{F}}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Huginn.thickness_velocity_data-Union{Tuple{F}, Tuple{Prediction, Vector{F}}} where F&lt;:AbstractFloat-api"><code>Huginn.thickness_velocity_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">thickness_velocity_data(
    prediction::Prediction,
    tstops::Vector{F};
    store::Tuple=(:H, :V),
) where {F &lt;: AbstractFloat}</code></pre><p>Return a new vector of glaciers with the simulated thickness and ice velocity data for each of the glaciers.</p><p><strong>Arguments</strong></p><ul><li><code>prediction::Prediction</code>: A <code>Prediction</code> object containing the simulation results and associated glaciers.</li><li><code>tstops::Vector{F}</code>: A vector of time steps (of type <code>F &lt;: AbstractFloat</code>) at which the simulation was evaluated.</li><li><code>store::Tuple</code>: Which generated simulation products to store. It can include <code>:H</code> and/or <code>:V</code>.</li></ul><p><strong>Description</strong></p><p>This function iterates over the glaciers in the <code>Prediction</code> object and generates the simulated data based on the <code>store</code> argument at corresponding time steps (<code>t</code>). If <code>store</code> includes <code>:H</code>, then the ice thickness is stored. If <code>store</code> includes <code>:V</code>, then it computes the surface ice velocity data and store it. A new vector of glaciers is created and each glacier is a copy with an updated <code>thicknessData</code> and <code>velocityData</code> fields.</p><p><strong>Notes</strong></p><ul><li>The function asserts that the time steps (<code>ts</code>) in the simulation results match the provided <code>tstops</code>. If they do not match, an error is raised.</li></ul><p><strong>Returns</strong></p><p>A new vector of glaciers where each glacier is a copy of the original one with the updated <code>thicknessData</code> and <code>velocityData</code> based on the values provided in <code>store</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/simulations/predictions/prediction_utils.jl#L144-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Huginn.∇slope-Union{Tuple{T}, Tuple{Matrix{T}, T, T}} where T&lt;:Real-api"><a class="docstring-binding" href="#Huginn.∇slope-Union{Tuple{T}, Tuple{Matrix{T}, T, T}} where T&lt;:Real-api"><code>Huginn.∇slope</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∇slope(S::Matrix{T}, Δx::T, Δy::T) where T &lt;: Real</code></pre><p>Compute the magnitude of the surface slope ∇S for a scalar field <code>S</code> defined on a rectilinear grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/iceflow_utils.jl#L251-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.apply_all_callback_laws!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Real, Any}-api"><a class="docstring-binding" href="#Sleipnir.apply_all_callback_laws!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Real, Any}-api"><code>Sleipnir.apply_all_callback_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_all_callback_laws!(
    SIA2D_model::SIA2Dmodel,
    SIA2D_cache::SIA2DCache,
    simulation,
    glacier_idx::Integer,
    t::Real,
    θ,
)</code></pre><p>Applies the different laws required by the SIA2D glacier model for a given glacier and simulation state. If <code>U_is_provided</code> is <code>true</code> in <code>SIA2D_model</code> and <code>U</code> is a callback law, it applies the law for <code>U</code> only. Otherwise if <code>Y_is_provided</code> and <code>Y</code> is a callback law, it applies the law for <code>Y</code> only. Finally, if <code>U_is_provided</code> and <code>Y_is_provided</code> are false, the function checks and applies the laws for <code>A</code>, <code>C</code>, and <code>n</code>, if they are defined as &quot;callback&quot; laws (i.e., handled as callbacks by the ODE solver). Results are written in-place to the cache for subsequent use in the simulation step.</p><p><strong>Arguments</strong></p><ul><li><code>SIA2D_model</code>: The model object containing the laws (<code>A</code>, <code>C</code>, <code>n</code>, <code>Y</code> and <code>U</code>).</li><li><code>SIA2D_cache</code>: A cache object to store the evaluated values of the laws (<code>A</code>, <code>C</code>, <code>n</code>, <code>Y</code> and <code>U</code>) for the current step.</li><li><code>simulation</code>: The simulation object.</li><li><code>glacier_idx::Integer</code>: Index of the glacier being simulated, used to select data for multi-glacier simulations.</li><li><code>t::Real</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p><strong>Notes</strong></p><ul><li>The function mutates the contents of <code>SIA2D_cache</code>.</li><li>Only &quot;callback&quot; laws are applied.</li><li>This function is typically used in the manual adjoint and in the tests where only portions of the code are applied and we need to apply all the laws used in the iceflow model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L206-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.apply_all_non_callback_laws!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Real, Any}-api"><a class="docstring-binding" href="#Sleipnir.apply_all_non_callback_laws!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Real, Any}-api"><code>Sleipnir.apply_all_non_callback_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function apply_all_non_callback_laws!(
    SIA2D_model::SIA2Dmodel,
    SIA2D_cache::SIA2DCache,
    simulation,
    glacier_idx::Integer,
    t::Real,
    θ,
)</code></pre><p>Applies the different laws required by the SIA2D glacier model for a given glacier and simulation state. If <code>U_is_provided</code> is <code>true</code> in <code>SIA2D_model</code> and <code>U</code> is not a callback law, it applies the law for <code>U</code> only. Otherwise if <code>Y_is_provided</code> and <code>Y</code> is not a callback law, it applies the law for <code>Y</code> only. Finally, if <code>U_is_provided</code> and <code>Y_is_provided</code> are false, the function checks and applies the laws for <code>A</code>, <code>C</code>, and <code>n</code>, unless they are defined as &quot;callback&quot; laws (i.e., handled as callbacks by the ODE solver). Results are written in-place to the cache for subsequent use in the simulation step.</p><p><strong>Arguments</strong></p><ul><li><code>SIA2D_model</code>: The model object containing the laws (<code>A</code>, <code>C</code>, <code>n</code>, <code>Y</code> and <code>U</code>).</li><li><code>SIA2D_cache</code>: A cache object to store the evaluated values of the laws (<code>A</code>, <code>C</code>, <code>n</code>, <code>Y</code> and <code>U</code>) for the current step.</li><li><code>simulation</code>: The simulation object.</li><li><code>glacier_idx::Integer</code>: Index of the glacier being simulated, used to select data for multi-glacier simulations.</li><li><code>t::Real</code>: Current simulation time.</li><li><code>θ</code>: Parameters of the laws to be used in the SIA. Can be <code>nothing</code> when no learnable laws are used.</li></ul><p><strong>Notes</strong></p><ul><li>The function mutates the contents of <code>SIA2D_cache</code>.</li><li>&quot;Callback&quot; laws are skipped, as they are expected to be handled outside this function.</li><li>This function is typically called at each simulation time step for each glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L139-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.init_cache-Tuple{SIA2Dmodel, Any, Int64, Any}-api"><a class="docstring-binding" href="#Sleipnir.init_cache-Tuple{SIA2Dmodel, Any, Int64, Any}-api"><code>Sleipnir.init_cache</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function init<em>cache( iceflow</em>model::SIA2Dmodel, glacier::AbstractGlacier, glacier_idx::I, θ, ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable in-place mutation.</p><p>Keyword arguments</p><ul><li><code>iceflow_model</code>: Iceflow model used for simulation.</li><li><code>glacier_idx</code>: Index of glacier.</li><li><code>glacier</code>: <code>Glacier</code> to provide basic initial state of the ice flow model.</li><li><code>θ</code>: Optional parameters of the laws.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.12.5/src/models/iceflow/SIA2D/SIA2D.jl#L333-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.MBmodel-api"><a class="docstring-binding" href="#Muninn.MBmodel-api"><code>Muninn.MBmodel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MBmodel &lt;: AbstractModel</code></pre><p>An abstract type representing a mass balance model in the Muninn package. This serves as a base type for all specific mass balance models, ensuring they adhere to a common interface and can be used interchangeably within the ODINN framework.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/MBmodel.jl#L4-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.TImodel-api"><a class="docstring-binding" href="#Muninn.TImodel-api"><code>Muninn.TImodel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TImodel &lt;: MBmodel</code></pre><p>An abstract type representing a temperature index mass balance models within the ODINN framework. This type serves as a parent type for more specialized mass balance models, ensuring they adhere to a common interface defined by the <code>MBmodel</code> abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/MBmodel.jl#L18-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TImodel1(params::Sleipnir.Parameters; DDF::F = 7.0/1000.0, acc_factor::F = 1.0/1000.0) where {F &lt;: AbstractFloat}</code></pre><p>Create a temperature index model with one degree-day factor (DDF) with the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: The simulation parameters.</li><li><code>DDF::F</code>: Degree-day factor (default is 7.0/1000.0).</li><li><code>acc_factor::F</code>: Accumulation factor (default is 1.0/1000.0).</li></ul><p><strong>Returns</strong></p><ul><li><code>TI1_model</code>: An instance of TImodel1 with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/MBmodel.jl#L46-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.TImodel1-api"><a class="docstring-binding" href="#Muninn.TImodel1-api"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TImodel1{F &lt;: AbstractFloat}</code></pre><p>A structure representing a temperature index model with degree-day factor and accumulation factor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>DDF::F</code>: Degree-day factor, which is a coefficient used to convert temperature into melt.</li><li><code>acc_factor::F</code>: Accumulation factor, which is a coefficient used to adjust the accumulation of mass.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: A subtype of <code>AbstractFloat</code> representing the type of the factors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/MBmodel.jl#L27-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Muninn.TImodel2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TImodel2(params::Sleipnir.Parameters; DDF_snow::F = 3.0/1000.0, DDF_ice::F = 6.0/1000.0, acc_factor::F = 1.0/1000.0) where {F &lt;: AbstractFloat}</code></pre><p>Create a temperature-index model with two degree-day factors (TImodel2) for mass balance calculations.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: The parameters object containing simulation settings.</li><li><code>DDF_snow::F</code>: Degree-day factor for snow (default: 3.0/1000.0).</li><li><code>DDF_ice::F</code>: Degree-day factor for ice (default: 6.0/1000.0).</li><li><code>acc_factor::F</code>: Accumulation factor (default: 1.0/1000.0).</li></ul><p><strong>Returns</strong></p><ul><li><code>TI2_model</code>: An instance of the TImodel2 with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/MBmodel.jl#L92-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.TImodel2-api"><a class="docstring-binding" href="#Muninn.TImodel2-api"><code>Muninn.TImodel2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TImodel2{F &lt;: AbstractFloat}</code></pre><p>A type representing a temperature-index model with parameters for snow and ice degree-day factors, and an accumulation factor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>DDF_snow::F</code>: Degree-day factor for snow, which determines the melt rate of snow per degree above the melting point.</li><li><code>DDF_ice::F</code>: Degree-day factor for ice, which determines the melt rate of ice per degree above the melting point.</li><li><code>acc_factor::F</code>: Accumulation factor, which scales the accumulation of snow.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: A subtype of <code>AbstractFloat</code>, representing the numeric type used for the model parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/MBmodel.jl#L71-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{Any, Sleipnir.Model, G, F, Any}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api"><a class="docstring-binding" href="#Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{Any, Sleipnir.Model, G, F, Any}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api"><code>Muninn.MB_timestep!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MB_timestep!(cache, model::Model, glacier::G, step::F, t) where {F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Simulates a mass balance timestep for a given glacier model.</p><p><strong>Arguments</strong></p><ul><li><code>cache</code>: The model cache to update.</li><li><code>model::Model</code>: The glacier model containing iceflow and mass balance information.</li><li><code>glacier::G</code>: The glacier object containing climate and DEM data.</li><li><code>step::F</code>: The timestep duration.</li><li><code>t</code>: The current time.</li></ul><p><strong>Description</strong></p><p>This function performs the following steps:</p><ol><li>Computes the period from the previous timestep to the current time.</li><li>Retrieves cumulative climate data for the specified period.</li><li>Downscales the climate dataset to a 2D grid based on the glacier&#39;s DEM.</li><li>Computes the mass balance for the glacier and updates the model&#39;s iceflow mass balance.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/mass_balance_utils.jl#L66-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api"><a class="docstring-binding" href="#Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api"><code>Muninn.MB_timestep</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MB_timestep(model::Model, glacier::G, step::F, t::F) where {F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Calculate the mass balance (MB) for a glacier over a given timestep.</p><p><strong>Keyword arguments</strong></p><ul><li><code>model::Model</code>: The model containing mass balance parameters.</li><li><code>glacier::G</code>: The glacier object containing climate and DEM data.</li><li><code>step::F</code>: The timestep duration.</li><li><code>t::F</code>: The current time.</li></ul><p><strong>Returns</strong></p><ul><li><code>MB::Matrix{F}</code>: The computed mass balance matrix for the given timestep.</li></ul><p><strong>Details</strong></p><ol><li>Computes the period between the current time <code>t</code> and the previous step <code>t - step</code>.</li><li>Retrieves cumulative climate data for the specified period.</li><li>Downscales the climate data to a 2D grid based on the glacier&#39;s DEM.</li><li>Computes the mass balance using the downscaled climate data.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/mass_balance_utils.jl#L32-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep, AbstractFloat}-api"><a class="docstring-binding" href="#Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep, AbstractFloat}-api"><code>Muninn.compute_MB</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_MB(
    mb_model::TImodel1,
    climate_2D_period::Climate2Dstep,
    step::AbstractFloat,
)</code></pre><p>Compute the mass balance (MB) for a given mass balance model and climate period.</p><p><strong>Arguments</strong></p><ul><li><code>mb_model::TImodel1</code>: The mass balance model containing parameters such as accumulation factor (<code>acc_factor</code>) and degree-day factor (<code>DDF</code>).</li><li><code>climate_2D_period::Climate2Dstep</code>: The climate data for a specific period, including snow accumulation (<code>snow</code>) and positive degree days (<code>PDD</code>).</li><li><code>step::AbstractFloat</code>: The step used to update MB. This scales the MB so that the accumulation and degree-day factors are scaled monthly.</li></ul><p><strong>Returns</strong></p><ul><li>A numerical array representing the computed mass balance, calculated as the difference between the product of the accumulation factor and snow, and the product of the degree-day factor and positive degree days.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.9.2/src/models/mass_balance/mass_balance_utils.jl#L4-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractData-api"><a class="docstring-binding" href="#Sleipnir.AbstractData-api"><code>Sleipnir.AbstractData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractData</code></pre><p>Abstract type that represents data. Used to implement <code>ThicknessData</code> and <code>SurfaceVelocityData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/Data.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractGlacier-api"><a class="docstring-binding" href="#Sleipnir.AbstractGlacier-api"><code>Sleipnir.AbstractGlacier</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractGlacier</code></pre><p>An abstract type representing a glacier. This serves as a base type for different glacier implementations in the <code>Sleipnir</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/Glacier2D.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractInput-api"><a class="docstring-binding" href="#Sleipnir.AbstractInput-api"><code>Sleipnir.AbstractInput</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractInput</code></pre><p>Abstract type representing an input source for a <code>Law</code>. Concrete subtypes must implement:</p><ul><li><code>default_name(::ConcreteInput)</code>: returns the default field name (as a <code>Symbol</code>) under which this input will be accessed in the law&#39;s input <code>NamedTuple</code>.</li><li><code>get_input(::ConcreteInput, simulation, glacier_idx, t)</code>: retrieves the actual input value given the simulation context, glacier index, and time <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/GenInput.jl#L4-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractLaw-api"><a class="docstring-binding" href="#Sleipnir.AbstractLaw-api"><code>Sleipnir.AbstractLaw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractLaw</code></pre><p>Abstract type representing a synthetic law. Currently it&#39;s only used for testing by making easier to create dumb laws, but in the future it may be cleaner to use different concrete type of laws (for example <code>CallbackLaw</code>, <code>ContinuousLaw</code>, or <code>LearnableLaw</code>)</p><p>Concrete subtypes must implement:</p><ul><li><code>apply_law!(::ConcreteLaw, state, simulation, glacier_idx, t, θ)</code></li><li><code>init_cache(::ConcreteLaw, glacier, glacier_idx)</code></li><li><code>law_VJP_input(::ConcreteLaw, cache, simulation, glacier_idx, t, θ)</code></li><li><code>law_VJP_θ(::ConcreteLaw, cache, simulation, glacier_idx, t, θ)</code></li><li><code>precompute_law_VJP(::ConcreteLaw, cache, vjpsPrepLaw, simulation, glacier_idx, t, θ)</code></li><li><code>cache_type(::ConcreteLaw)</code></li><li><code>is_callback_law(::ConcreteLaw)</code></li><li><code>is_precomputable_law_VJP(::ConcreteLaw)</code></li><li><code>callback_freq(::ConcreteLaw)</code></li><li><code>inputs(::ConcreteLaw)</code></li><li><code>inputs_defined(::ConcreteLaw)</code></li><li><code>apply_law_in_model(::ConcreteLaw)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/AbstractLaw.jl#L8-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractModel-api"><a class="docstring-binding" href="#Sleipnir.AbstractModel-api"><code>Sleipnir.AbstractModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractModel</code></pre><p>An abstract type that serves as a base for all model types in ODINN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/models/Model.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractParameters-api"><a class="docstring-binding" href="#Sleipnir.AbstractParameters-api"><code>Sleipnir.AbstractParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractParameters</code></pre><p>An abstract type that serves as a base for all parameter-related types in the ODINN ecosystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/Parameters.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.AbstractPrepVJP-api"><a class="docstring-binding" href="#Sleipnir.AbstractPrepVJP-api"><code>Sleipnir.AbstractPrepVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPrepVJP</code></pre><p>Abstract type representing the preparation of Vector-Jacobian Product (VJP) computations for the laws. Subtypes of <code>AbstractPrepVJP</code> are used to handle any precomputations or setup required before evaluating VJPs, such as configuring automatic differentiation backends or precompiling code. This type provides a flexible interface for implementing custom VJP preparation strategies for different laws. It is for internal use only and not exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/GenInput.jl#L60-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Cache-api"><a class="docstring-binding" href="#Sleipnir.Cache-api"><code>Sleipnir.Cache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Cache</code></pre><p>Abstract type for defining a cache struct of a law.</p><p>Mandatory field:</p><ul><li><code>value</code>: Store the result of a forward evaluation.</li></ul><p>Optional fields:</p><ul><li><code>vjp_inp</code>: Store the result of the evaluation of the vector-Jacobian product (VJP) with respect to the inputs.</li><li><code>vjp_θ</code>: Store the result of the evaluation of the vector-Jacobian product (VJP) with respect to the parameters θ.</li></ul><p>Notes:</p><ul><li>If a concrete subtype does not implement <code>vjp_inp</code> and <code>vjp_θ</code>, the law should not be used for gradient computation, and therefore for inversions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Cache.jl#L5-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Climate2D-api"><a class="docstring-binding" href="#Sleipnir.Climate2D-api"><code>Sleipnir.Climate2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A mutable struct representing a 2D climate for a glacier with various buffers and datasets.</p><pre><code class="nohighlight hljs">Climate2D{CLIMRAW &lt;: RasterStack, CLIMRAWSTEP &lt;: RasterStack, CLIMSTEP &lt;: ClimateStep, CLIM2DSTEP &lt;: Climate2Dstep, F &lt;: AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><p><code>raw_climate::CLIMRAW</code>: Raw climate dataset for the whole simulation.</p></li><li><p><code>climate_raw_step::CLIMRAWSTEP</code>: Raw climate trimmed for the current step to avoid memory allocations.</p></li><li><p><code>climate_step::ClimateStep</code>: Climate data for the current step.</p></li><li><p><code>climate_2D_step::Climate2Dstep</code>: 2D climate data for the current step to feed to the mass balance (MB) model.</p></li><li><p><code>longterm_temps::Vector{F}</code>: Long-term temperatures for the ice rheology.</p></li><li><p><code>avg_temps::F</code>: Intermediate buffer for computing average temperatures.</p></li><li><p><code>avg_gradients::F</code>: Intermediate buffer for computing average gradients.</p></li><li><p><code>ref_hgt::F</code>: Reference elevation of the raw climate data.</p><p>Climate2D( rgi_id, params::Parameters, S::Matrix{&lt;: AbstractFloat}, Coords::Dict, )</p></li></ul><p>Initialize the climate data given a RGI ID, a matrix of surface elevation and glacier coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id</code>: The glacier RGI ID.</li><li><code>params::Parameters</code>: The parameters containing simulation settings and paths.</li><li><code>S::Matrix{&lt;: AbstractFloat}</code>: Matrix of surface elevation used to initialize the downscaled climate data.</li><li><code>Coords::Dict</code>: Coordinates of the glacier.</li></ul><p><strong>Description</strong></p><p>This function initializes the climate data for a glacier by:</p><ol><li><p>Creating a dummy period based on the simulation time span and step.</p></li><li><p>Loading the raw climate data from a NetCDF file.</p></li><li><p>Calculating the cumulative climate data for the dummy period.</p></li><li><p>Downscaling the cumulative climate data to a 2D grid.</p></li><li><p>Retrieving long-term temperature data for the glacier.</p></li><li><p>Returning the climate data, including raw climate data, cumulative climate data, downscaled 2D climate data, long-term temperatures, average temperatures, and average gradients.</p><p>Climate2D( raw<em>climate::RasterStack, climate</em>raw<em>step::RasterStack, climate</em>step::ClimateStep, climate<em>2D</em>step::Climate2Dstep, longterm<em>temps::Vector{&lt;: AbstractFloat}, avg</em>temps::AbstractFloat, avg<em>gradients::AbstractFloat, ref</em>hgt::AbstractFloat, )</p></li></ol><p>Initialize the climate data with the fields provided as arguments. Refer to the list of fields for a complete description of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/Climate2D.jl#L69-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Climate2Dstep-api"><a class="docstring-binding" href="#Sleipnir.Climate2Dstep-api"><code>Sleipnir.Climate2Dstep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Climate2Dstep{F &lt;: AbstractFloat}</code></pre><p>A mutable struct representing a 2D climate time step with various climate-related parameters.</p><p><strong>Keyword arguments</strong></p><ul><li><code>temp::Matrix{F}</code>: Temperature matrix.</li><li><code>PDD::Matrix{F}</code>: Positive Degree Days matrix.</li><li><code>snow::Matrix{F}</code>: Snowfall matrix.</li><li><code>rain::Matrix{F}</code>: Rainfall matrix.</li><li><code>gradient::F</code>: Gradient value.</li><li><code>avg_gradient::F</code>: Average gradient value.</li><li><code>x::Vector{F}</code>: X-coordinates vector.</li><li><code>y::Vector{F}</code>: Y-coordinates vector.</li><li><code>ref_hgt::F</code>: Reference height.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/Climate2D.jl#L4-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ClimateStep-api"><a class="docstring-binding" href="#Sleipnir.ClimateStep-api"><code>Sleipnir.ClimateStep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ClimateStep{F &lt;: AbstractFloat}</code></pre><p>Mutable struct that represents a climate step before downscaling.</p><p><strong>Keyword arguments</strong></p><ul><li><code>prcp::F</code>: Cumulative precipitation for the given period.</li><li><code>temp::F</code>: Cumulative temperature at the reference elevation for the given period.</li><li><code>gradient::F</code>: Cumulative temperature gradient for the given period.</li><li><code>avg_temp::F</code>: Average temperature over the time step.</li><li><code>avg_gradient::F</code>: Average temperature gradient over the time step.</li><li><code>ref_hgt::F</code>: Reference elevation of the raw climate data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/Climate2D.jl#L40-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ConstantLaw-api"><a class="docstring-binding" href="#Sleipnir.ConstantLaw-api"><code>Sleipnir.ConstantLaw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConstantLaw{CACHE_TYPE}(init_cache)</code></pre><p>Creates a constant law of type <code>ConstantLaw{CACHE_TYPE}</code> that holds a fixed value for the entire simulation.</p><p>This is useful to inject glacier-specific or global constants into the simulation without modifying them over time. The update function is a no-op, and only the <code>init_cache</code> function matters.</p><p><strong>Arguments</strong></p><ul><li><code>init_cache::Function</code>: A function <code>init_cache(simulation, glacier_idx, θ)::T</code> that provides the constant value.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>CACHE_TYPE</code>: The type of the cache. Must be specified manually and should match the return type of <code>init_cache</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs"># Same value for all glaciers
n_law = ConstantLaw{Float64}(Returns(4.))

# Value depending on the glacier
n_law = ConstantLaw{Float64}((sim, i, θ) -&gt; sim.glaciers[i].n)

# Learned value
n_law = ConstantLaw{Float64}((sim, i, θ) -&gt; θ.n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Law.jl#L338-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Container-api"><a class="docstring-binding" href="#Sleipnir.Container-api"><code>Sleipnir.Container</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Container</code></pre><p>Abstract type that defines a container to be used in the PDE solver. It is useful to retrieve the <code>simulation</code> object when applying callback laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/AbstractLaw.jl#L69-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.CustomVJP-api"><a class="docstring-binding" href="#Sleipnir.CustomVJP-api"><code>Sleipnir.CustomVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CustomVJP &lt;: VJPType</code></pre><p>Indicates that a law uses a custom-defined function for VJP computation. This is used when the VJP is provided manually rather than computed automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L68-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.DIVJP-api"><a class="docstring-binding" href="#Sleipnir.DIVJP-api"><code>Sleipnir.DIVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DIVJP &lt;: VJPType</code></pre><p>Indicates that a law uses the default VJP computation provided by DifferentiationInterface.jl. This is used when no custom VJP function is provided, and the Vector-Jacobian Product (VJP) is computed automatically using DifferentiationInterface.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L76-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.GenInputsAndApply-api"><a class="docstring-binding" href="#Sleipnir.GenInputsAndApply-api"><code>Sleipnir.GenInputsAndApply</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GenInputsAndApply{IN, F}</code></pre><p>Given a tuple of <code>AbstractInput</code>s and a function <code>f</code>, returns a callable struct. This struct <code>with_input_f</code> can be evaluated as a function that generates the inputs and then applies the function&#39;s law <code>with_input_f.f</code>. It is for internal use only and it isn&#39;t exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/GenInput.jl#L28-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><a class="docstring-binding" href="#Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><code>Sleipnir.Glacier1D</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function Glacier1D(; rgi<em>id::String = &quot;&quot;, climate::Union{Climate1D, Nothing} = nothing, H₀::Vector{F} = Vector{Sleipnir.Float}([]), S::Vector{F} = Vector{Sleipnir.Float}([]), B::Vector{F} = Vector{Sleipnir.Float}([]), V::Vector{F}= Vector{Sleipnir.Float}([]), A::Union{F, Nothing} = nothing, C::Union{F, Nothing} = nothing, n::Union{F, Nothing} = nothing, w₀::Union{Vector{F}, Nothing} = nothing, λ::Union{Vector{F}, Nothing} = nothing, slope::Vector{F} = Vector{Sleipnir.Float}([]), dist</em>border::Vector{F} = Vector{Sleipnir.Float}([]), Coords::Dict{String, Vector{Float64}} = Dict{String, Vector{Float64}}(&quot;lon&quot; =&gt; [], &quot;lat&quot; =&gt; []), Δx::F = 0, Δy::F = 0, nx::I = 0, ny::I = 0, ) where {F &lt;: AbstractFloat, I &lt;: Integer}</p><p>Constructor for empty 2D Glacier object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/Glacier1D.jl#L29-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Glacier2D-Tuple{Glacier2D}-api"><a class="docstring-binding" href="#Sleipnir.Glacier2D-Tuple{Glacier2D}-api"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Glacier2D(
    glacier::Glacier2D;
    thicknessData::Union{&lt;: ThicknessData, Nothing} = nothing,
    velocityData::Union{&lt;: SurfaceVelocityData, Nothing} = nothing,
)</code></pre><p>Copies a <code>Glacier2D</code> object and updates the thickness and/or surface velocity data.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::Glacier2D</code>: The original glacier struct.</li><li><code>thicknessData::Union{&lt;: ThicknessData, Nothing}</code>: Thickness data structure that is used to store the reference values. Default is <code>nothing</code> which keeps the existing thickness data.</li><li><code>velocityData::Union{&lt;: SurfaceVelocityData, Nothing}</code>: Surface velocity data structure that is used to store the reference values. Default is <code>nothing</code> which keeps the existing surface velocity data.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Glacier2D</code> object that is a copy of the original one with the thickness and/or surface velocity data updated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/Glacier2D.jl#L207-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Glacier2D-Tuple{String, Sleipnir.Parameters}-api"><a class="docstring-binding" href="#Sleipnir.Glacier2D-Tuple{String, Sleipnir.Parameters}-api"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Glacier2D(
    rgi_id::String,
    params::Parameters;
    masking::Union{Int, Nothing, BitMatrix} = 2,
    smoothing=false
)</code></pre><p>Build glacier object for a given RGI ID and parameters.</p><p><strong>Arguments</strong></p><ul><li><p><code>rgi_id::String</code>: The RGI ID of the glacier.</p></li><li><p><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</p></li><li><p><code>masking::Union{Int, Nothing, BitMatrix}</code>: Type of mask applied to the glacier to determine regions with no ice.</p><ul><li>When <code>masking</code> is an <code>Int</code>, the mask is based on the initial ice thickness <code>H₀</code> and it is set to true for pixels outside at a distance of the glacier borders greater than the value of <code>masking</code>.</li><li>When <code>masking</code> is set to <code>nothing</code>, the mask is set to a <code>BitMatrix</code> full of falses.</li><li>When <code>masking</code> is a <code>BitMatrix</code>, this matrix is used for the mask. Defaults to <code>2</code>.</li></ul></li><li><p><code>smoothing::Bool=false</code>: Optional; whether to apply smoothing to the initial ice thickness. Default is <code>false</code>.</p></li><li><p><code>test::Bool=false</code>: Optional; test flag. Default is <code>false</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>glacier::Glacier2D</code>: A <code>Glacier2D</code> object initialized with the glacier data.</li></ul><p><strong>Description</strong></p><p>This function loads and initializes the glacier data for a given RGI ID. It retrieves the initial ice thickness conditions based on the specified source in the parameters, applies optional smoothing, and initializes the glacier&#39;s topographical and velocity data. The function also handles Mercator projection for the glacier coordinates and filters glacier borders in high elevations to avoid overflow problems.</p><p><strong>Notes</strong></p><ul><li>The function reverses the matrices for ice thickness, bedrock, and other data to match the required orientation.</li><li>If the Mercator projection includes latitudes larger than 80°, a warning is issued.</li><li>If the glacier data is missing, the function updates a list of missing glaciers and issues a warning.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L201-L239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Glacier2D-Union{Tuple{}, Tuple{SURFVELDATA}, Tuple{THICKDATA}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer, THICKDATA&lt;:(Union{Nothing, var&quot;#s119&quot;} where var&quot;#s119&quot;&lt;:ThicknessData), SURFVELDATA&lt;:(Union{Nothing, var&quot;#s118&quot;} where var&quot;#s118&quot;&lt;:SurfaceVelocityData)}-api"><a class="docstring-binding" href="#Sleipnir.Glacier2D-Union{Tuple{}, Tuple{SURFVELDATA}, Tuple{THICKDATA}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer, THICKDATA&lt;:(Union{Nothing, var&quot;#s119&quot;} where var&quot;#s119&quot;&lt;:ThicknessData), SURFVELDATA&lt;:(Union{Nothing, var&quot;#s118&quot;} where var&quot;#s118&quot;&lt;:SurfaceVelocityData)}-api"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Glacier2D(;
    rgi_id::String = &quot;&quot;,
    name::String = &quot;&quot;,
    climate::Climate2D = nothing,
    H₀::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    H_glathida::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    S::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    B::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    V::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    Vx::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    Vy::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    A::F = 0.0,
    C::F = 0.0,
    n::F = 0.0,
    p::F = 0.0,
    q::F = 0.0,
    slope::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    dist_border::Matrix{F} = Matrix{Sleipnir.Float}([;;]),
    mask::BitMatrix = BitMatrix([;;]),
    Coords::Dict{String, Vector{Float64}} = Dict{String, Vector{Float64}}(&quot;lon&quot; =&gt; [], &quot;lat&quot; =&gt; []),
    Δx::F = 0.0,
    Δy::F = 0.0,
    nx::I = 0,
    ny::I = 0,
    cenlon::F = NaN,
    cenlat::F = NaN,
    params_projection::Dict{String, Float64} = Dict{String, Float64}(),
    thicknessData::THICKDATA = nothing,
    velocityData::SURFVELDATA = nothing,
) where {
    F &lt;: AbstractFloat,
    I &lt;: Integer,
    THICKDATA &lt;: Union{&lt;: ThicknessData, Nothing},
    SURFVELDATA &lt;: Union{&lt;: SurfaceVelocityData, Nothing},
}</code></pre><p>Constructs a <code>Glacier2D</code> object with the given parameters, including default ones.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI identifier for the glacier.</li><li><code>name::String</code>: The name of the glacier if available.</li><li><code>climate::Climate2D</code>: The climate data associated with the glacier.</li><li><code>H₀::Matrix{F}</code>: Initial ice thickness matrix.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness matrix from GLATHIDA.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix.</li><li><code>B::Matrix{F}</code>: Bed elevation matrix.</li><li><code>V::Matrix{F}</code>: Ice velocity magnitude matrix.</li><li><code>Vx::Matrix{F}</code>: Ice velocity in the x-direction matrix.</li><li><code>Vy::Matrix{F}</code>: Ice velocity in the y-direction matrix.</li><li><code>A::F</code>: Flow law parameter.</li><li><code>C::F</code>: Sliding law parameter.</li><li><code>n::F</code>: Flow law exponent.</li><li><code>p::F</code>: Power law exponent associated to Weertman sliding law (Power associated to basal drag).</li><li><code>q::F</code>: Power law exponent associated to Weertman sliding law (Power associated to normal pressure).</li><li><code>slope::Matrix{F}</code>: Slope matrix.</li><li><code>dist_border::Matrix{F}</code>: Distance to border matrix.</li><li><code>mask::BitMatrix</code>: Boolean matrix representing the glacier mask, where true values indicate regions constrained by the mask (i.e., no-ice zones)</li><li><code>Coords::Dict{String, Vector{Float64}}</code>: Coordinates dictionary with keys &quot;lon&quot; and &quot;lat&quot;.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>cenlon::F</code>: Central longitude of the glacier.</li><li><code>cenlat::F</code>: Central latitude of the glacier.</li><li><code>params_projection::Dict{String, Float64}</code>: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.</li><li><code>thicknessData::THICKDATA</code>: Thickness data structure that is used to store the reference values.</li><li><code>velocityData::SURFVELDATA</code>: Surface velocity data structure that is used to store the reference values.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Glacier2D</code> object with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/Glacier2D.jl#L86-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Glacier2D-api"><a class="docstring-binding" href="#Sleipnir.Glacier2D-api"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A mutable struct representing a 2D glacier. Notice that all fields can be empty by providing <code>nothing</code> as the default value.</p><p>/!\ WARNING /!\ <code>Glacier</code> objects should not be constructed manually, but rather through the <code>initialize_glaciers</code> function.</p><p><code>Glacier2D{F &lt;: AbstractFloat, I &lt;: Integer, CLIM &lt;: Climate2D, THICKDATA &lt;: Union{&lt;: ThicknessData, Nothing}, SURFVELDATA &lt;: Union{&lt;: SurfaceVelocityData, Nothing}}</code></p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) identifier for the glacier.</li><li><code>name::String</code>: The name of the glacier if available.</li><li><code>climate::CLIM</code>: The climate data associated with the glacier.</li><li><code>H₀::Matrix{F}</code>: Initial ice thickness matrix.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness matrix from the GLATHIDA dataset.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix.</li><li><code>B::Matrix{F}</code>: Bedrock elevation matrix.</li><li><code>V::Matrix{F}</code>: Ice velocity magnitude matrix.</li><li><code>Vx::Matrix{F}</code>: Ice velocity in the x-direction matrix.</li><li><code>Vy::Matrix{F}</code>: Ice velocity in the y-direction matrix.</li><li><code>A::F</code>: Flow law parameter.</li><li><code>C::F</code>: Sliding law parameter.</li><li><code>n::F</code>: Flow law exponent.</li><li><code>p::F</code>: Power law exponent associated to Weertman sliding law (Power associated to basal drag).</li><li><code>q::F</code>: Power law exponent associated to Weertman sliding law (Power associated to normal pressure).</li><li><code>slope::Matrix{F}</code>: Surface slope matrix.</li><li><code>dist_border::Matrix{F}</code>: Distance to the glacier border matrix.</li><li><code>mask::BitMatrix</code>: Boolean matrix representing the glacier mask, where true values indicate regions constrained by the mask (i.e., no-ice zones)</li><li><code>Coords::Dict{String, Vector{Float64}}</code>: Coordinates dictionary with keys as coordinate names and values as vectors of coordinates.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>cenlon::F</code>: Longitude of the glacier center.</li><li><code>cenlat::F</code>: Latitude of the glacier center.</li><li><code>params_projection::Dict{String, Float64}</code>: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.</li><li><code>thicknessData::THICKDATA</code>: Thickness data structure that is used to store the reference values.</li><li><code>velocityData::SURFVELDATA</code>: Surface velocity data structure that is used to store the reference values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/Glacier2D.jl#L13-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.IntegratedTrajectoryMapping-api"><a class="docstring-binding" href="#Sleipnir.IntegratedTrajectoryMapping-api"><code>Sleipnir.IntegratedTrajectoryMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntegratedTrajectoryMapping &lt;: VelocityMapping</code></pre><p>Integrated trajectory mapping. This mapping is closer to reality as it consists in integrating over time the instantaneous ice surface velocities along ice flow trajectories in a Lagrangian way. This integrated velocity is then compared to the velocity of the datacube. It has not been implemented yet but its computational cost will likely be expensive.</p><p><strong>Fields</strong></p><ul><li><code>spatialInterp::Symbol</code>: The spatial interpolation to use to map the ice surface velocity grid to the glacier grid. For the moment only <code>:nearest</code> is supported.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityMapping.jl#L31-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Law-api"><a class="docstring-binding" href="#Sleipnir.Law-api"><code>Sleipnir.Law</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Law{T}(;
    inputs = nothing,
    f!, f_VJP_input! = nothing, f_VJP_θ! = nothing,
    init_cache, callback_freq = nothing,
    p_VJP! = nothing,
    max_value = NaN, min_value = NaN, name = :unknown,
) where{T}</code></pre><p>Defines a physical or empirical law applied to a glacier model that mutates an internal state <code>T</code> at each simulation time step.</p><div class="admonition is-warning" id="Warning-6ead737348fdf7b1"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6ead737348fdf7b1" title="Permalink"></a></header><div class="admonition-body"><p>The type <code>T</code> must be <em>mutable</em>, since <code>f!</code> is expected to update <code>cache::T</code> in-place. Using an immutable type (like <code>Float64</code>) will silently fail or raise an error.</p></div></div><pre><code class="nohighlight hljs"># ❌ Will not work: Float64 is immutable, so cache .= ... has no effect
Law{Float64}(;
    f! = (cache, _, _, t, θ) -&gt; cache = θ.scale * sin(2π * t + θ.shift),
    init_cache = (_, _, _) -&gt; 0.0,
)

# ✅ Correct: using a 0-dimensional array allows in-place mutation
Law{Array{Float64, 0}}(;
    f! = (cache, _, _, t, θ) -&gt; cache .= θ.scale * sin(2π * t + θ.shift) + θ.bias,
    init_cache = (_, _, _) -&gt; zeros(),
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>f!::Function</code>: A function with signature <code>f!(cache::T, simulation, glacier_idx, t, θ)</code> that updates the internal state. If <code>inputs</code> are provided, the function instead takes the form <code>f!(cache::T, inputs, θ)</code>.</li><li><code>init_cache::Function</code>: A function <code>init_cache(simulation, glacier_idx, θ)::T</code> that initializes the internal state for a given glacier.</li><li><code>callback_freq::Union{Nothing, Real, Period, Month}</code>: Optional. If provided, the law is treated as a callback law and is only applied every <code>callback_freq</code> time units. If <code>callback_freq</code> is set to zero, then the law is applied only once at the beginning of the simulation. If <code>callback_freq</code> is set to <code>nothing</code> (default), then the law is applied at every iteration. If <code>callback_freq</code> is provided as a <code>Period</code> or <code>Month</code>, it is converted to a float value in a yearly basis.</li><li><code>f_VJP_input!</code>: A function with signature <code>(cache::T, simulation, glacier_idx, t, θ)</code> that updates <code>cache.vjp_inp</code> which is the VJP with respect to the inputs.</li><li><code>f_VJP_θ!</code>: A function with signature <code>(cache::T, simulation, glacier_idx, t, θ)</code> that updates <code>cache.vjp_θ</code> which is the VJP with respect to the parameters θ.</li><li><code>p_VJP!</code>: A function with signature <code>(cache::T, vjpsPrepLaw, simulation, glacier_idx, t, θ)</code> that performs the precomputation of the VJPs.</li><li><code>inputs::Union{Nothing, Tuple{&lt;:AbstractInput}}</code>: Optional. Provides automatically generated inputs passed to <code>f!</code> at runtime.</li><li><code>max_value::Float64</code>: Optional. The maximum value that the law can take, used for plotting and capping the function output.</li><li><code>min_value::Float64</code>: Optional. The minimum value that the law can take, used for plotting and capping the function output.</li><li><code>name::Symbol</code>: A name for the law, used for identification and plotting.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: The type of the internal state. Must be specified manually and should match the return type of <code>init_cache</code>.</li></ul><p><strong>Notes</strong></p><ul><li>Refer to the tutorials in the documentation for a complete description of the VJP options.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs"># A law applied at every timestep, storing a scalar value
Law{Array{Float64, 0}}(;
    f! = (cache, _, _, t, θ) -&gt; cache .= θ.scale * sin(2π * t + θ.shift) + θ.bias,
    init_cache = (_, _, _) -&gt; zeros(),
)

# A callback law applied once per month (assuming time in years)
Law{Array{Float64, 0}}(;
    f! = (cache, _, _, t, θ) -&gt; cache .= θ.scale * sin(2π * t + θ.shift) + θ.bias,
    init_cache = (_, _, _) -&gt; zeros(),
    callback_freq = 1 / 12,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Law.jl#L8-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.MatrixCache-api"><a class="docstring-binding" href="#Sleipnir.MatrixCache-api"><code>Sleipnir.MatrixCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MatrixCache &lt;: Cache</code></pre><p>A cache structure for storing a two-dimensional array of <code>Float64</code> values along with their associated vector-Jacobian products (VJP). This is typically used for spatially varying laws. Fields:</p><ul><li><code>value::Array{Float64, 2}</code>: The cached matrix.</li><li><code>vjp_inp::Array{Float64, 2}</code>: VJP with respect to inputs.</li><li><code>vjp_θ::Vector{Float64}</code>: VJP with respect to parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Cache.jl#L60-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.MatrixCacheNoVJP-api"><a class="docstring-binding" href="#Sleipnir.MatrixCacheNoVJP-api"><code>Sleipnir.MatrixCacheNoVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MatrixCacheNoVJP &lt;: Cache</code></pre><p>A mutable cache structure for storing a two-dimensional array of <code>Float64</code> values. This is typically used for spatially varying laws. This struct is intended for use cases where the law is not differentiated, and hence the vector-Jacobian products (VJP) are not required. Fields:</p><ul><li><code>value::Array{Float64, 2}</code>: The cached matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Cache.jl#L25-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.MeanDateVelocityMapping-api"><a class="docstring-binding" href="#Sleipnir.MeanDateVelocityMapping-api"><code>Sleipnir.MeanDateVelocityMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MeanDateVelocityMapping &lt;: VelocityMapping</code></pre><p>Mean date velocity mapping. It is the most simple mapping one can build and it consists in taking the 2D vector field of ice velocity associated to a given mean date and compare it to the instantaneous ice surface velocity obtained from the ice flow model. It is valid only for ice surface velocities estimated from short time windows since the velocity can vary within this time window.</p><p><strong>Fields</strong></p><ul><li><code>spatialInterp::Symbol</code>: The spatial interpolation to use to map the ice surface velocity grid to the glacier grid. For the moment only <code>:nearest</code> is supported.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityMapping.jl#L13-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Model-api"><a class="docstring-binding" href="#Sleipnir.Model-api"><code>Sleipnir.Model</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Model{IFM &lt;: AbstractEmptyModel, MBM &lt;: AbstractEmptyModel, TC &lt;: AbstractEmptyModel}</code></pre><p>A mutable struct that represents a model with three components: iceflow, mass balance, and machine learning.</p><pre><code class="nohighlight hljs">Model(
    iceflow::IFM,
    mass_balance::MBM,
    trainable_components::TC,
) where {IFM &lt;: AbstractEmptyModel, MBM &lt;: AbstractEmptyModel, TC &lt;: AbstractEmptyModel}

Model(;iceflow, mass_balance) = Model(iceflow, mass_balance, nothing)</code></pre><p>Initialize Model (no machine learning model).</p><p><strong>Keyword arguments</strong></p><ul><li><code>iceflow::IFM}</code>: Represents the iceflow component, which is an instance of <code>IFM</code>.</li><li><code>mass_balance::Union{MBM, Vector{MBM}}</code>: Represents the mass balance component, which is an instance of <code>MBM</code>.</li><li><code>trainable_components::TC</code>: Represents the trainable components, which is an instance of <code>TC</code>.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>IFM</code>: A subtype of <code>AbstractEmptyModel</code> representing the type of the iceflow model.</li><li><code>MBM</code>: A subtype of <code>AbstractEmptyModel</code> representing the type of the mass balance model.</li><li><code>TC</code>: A subtype of <code>AbstractEmptyModel</code> representing the type of the trainable components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/models/Model.jl#L13-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ModelCache-api"><a class="docstring-binding" href="#Sleipnir.ModelCache-api"><code>Sleipnir.ModelCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModelCache{IFC, MBC}</code></pre><p>Cache struct that holds the internal state or memory buffers for the components of a <code>Model</code>.</p><p>Typically used to store per-glacier preallocated buffers or intermediate results that persist across time steps during simulation.</p><p><strong>Fields</strong></p><ul><li><code>iceflow::IFC</code>: Cache associated with the iceflow model.</li><li><code>mass_balance::MBC</code>: Cache associated with the mass balance model.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>IFC</code>: Cache type for the iceflow model.</li><li><code>MBC</code>: Cache type for the mass balance model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/models/Model.jl#L58-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.NullLaw-api"><a class="docstring-binding" href="#Sleipnir.NullLaw-api"><code>Sleipnir.NullLaw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NullLaw &lt;: AbstractLaw</code></pre><p>This struct represents a law that is not used in the iceflow model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Law.jl#L393-L397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Parameters-Tuple{}-api"><a class="docstring-binding" href="#Sleipnir.Parameters-Tuple{}-api"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Parameters(; physical::PhysicalParameters = PhysicalParameters(), simulation::SimulationParameters = SimulationParameters())</code></pre><p>Constructs a <code>Parameters</code> object with the given physical and simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: An instance of <code>PhysicalParameters</code> (default: <code>PhysicalParameters()</code>).</li><li><code>simulation::SimulationParameters</code>: An instance of <code>SimulationParameters</code> (default: <code>SimulationParameters()</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Parameters</code> object initialized with the provided physical and simulation parameters.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>simulation.multiprocessing</code> is enabled, multiprocessing is configured with the specified number of workers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/Parameters.jl#L57-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Parameters-api"><a class="docstring-binding" href="#Sleipnir.Parameters-api"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Parameters{PPHY &lt;: AbstractEmptyParams, PSIM &lt;: AbstractEmptyParams, PHY &lt;: AbstractEmptyParams,
    PSOL &lt;: AbstractEmptyParams, PUDE &lt;: AbstractEmptyParams, PINV &lt;: AbstractEmptyParams}</code></pre><p>A mutable struct that holds various parameter sets for different aspects of a simulation or model.</p><p><strong>Fields</strong></p><ul><li><code>physical::PPHY</code>: Physical parameters.</li><li><code>simulation::PSIM</code>: Simulation parameters.</li><li><code>hyper::PHY</code>: Hyperparameters.</li><li><code>solver::PSOL</code>: Solver parameters.</li><li><code>UDE::PUDE</code>: Universal Differential Equation (UDE) parameters.</li><li><code>inversion::PINV</code>: Inversion parameters.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>PPHY</code>: Type of the physical parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PSIM</code>: Type of the simulation parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PHY</code>: Type of the hyperparameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PSOL</code>: Type of the solver parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PUDE</code>: Type of the UDE parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PINV</code>: Type of the inversion parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/Parameters.jl#L19-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Initialize the physical parameters of a model.</p><pre><code class="nohighlight hljs">PhysicalParameters(;
    ρ::Float64 = 900.0,
    g::Float64 = 9.81,
    ϵ::Float64 = 1e-10,
    η₀::F = 1.0,
    maxA::Float64 = 8e-17,
    minA::Float64 = 8.5e-20,
    maxC::Float64 = 8e-17, # TODO: to be revised
    minC::Float64 = 8.5e-20,
    maxTlaw::Float64 = 1.0,
    minTlaw::Float64 = -25.0,
    noise_A_magnitude::Float64 = 5e-18
    )</code></pre><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `ρ`: Ice density
- `g`: Gravitational acceleration.
- `ϵ`: Regularization used in the square root of norms for AD numerical stability.
- `η₀`: Factor to cap surface elevation differences with the upstream ice thickness to impose boundary condition in the iceflow equation
- `maxA`: Maximum value for `A` (Glen&#39;s coefficient)
- `minA`: Minimum value for `A` (Glen&#39;s coefficient)
- `maxC`: Maximum value of sliding coefficient `C`
- `minC`: Minimum value of sliding coefficient `C`
- `maxTlaw`: Maximum value of Temperature used in simulations on fake law
- `minTlaw`: Minimum value of Temperature used in simulations on fake law
- `noise_A_magnitude`: Magnitude of noise added to A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/PhysicalParameters.jl#L35-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.PhysicalParameters-api"><a class="docstring-binding" href="#Sleipnir.PhysicalParameters-api"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A structure representing physical parameters used in simulations.</p><pre><code class="nohighlight hljs">PhysicalParameters{F &lt;: AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>ρ::F</code>: Density of ice.</li><li><code>g::F</code>: Gravitational acceleration.</li><li><code>ϵ::F</code>: Regularization used in the square root of norms for AD numerical stability.</li><li><code>η₀::F</code>: Initial viscosity.</li><li><code>maxA::F</code>: Maximum A.</li><li><code>minA::F</code>: Minimum A.</li><li><code>maxC::F</code>: Maximum C.</li><li><code>minC::F</code>: Minimum C.</li><li><code>maxTlaw::F</code>: Maximum temperature according to some law.</li><li><code>minTlaw::F</code>: Minimum temperature according to some law.</li><li><code>noise_A_magnitude::F</code>: Magnitude of noise in A.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/PhysicalParameters.jl#L2-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Integer}-api"><a class="docstring-binding" href="#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Integer}-api"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Results(glacier::G, ifm::IF;
    rgi_id::String = glacier.rgi_id,
    H::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    H_glathida::Matrix{F} = glacier.H_glathida,
    H_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    S::Matrix{F} = zeros(Sleipnir.Float, size(ifm.S)),
    B::Matrix{F} = zeros(Sleipnir.Float, size(glacier.B)),
    V::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    Vx::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    Vy::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    V_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    Vx_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    Vy_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),
    date_Vref::Vector{F} = Vector{Sleipnir.Float}([]),
    date1_Vref::Vector{F} = Vector{Sleipnir.Float}([]),
    date2_Vref::Vector{F} = Vector{Sleipnir.Float}([]),
    Δx::F = glacier.Δx,
    Δy::F = glacier.Δy,
    lon::F = glacier.cenlon,
    lat::F = glacier.cenlat,
    nx::I = glacier.nx,
    ny::I = glacier.ny,
    t::Vector{F} = Vector{Sleipnir.Float}([]),
    tspan::Tuple{F, F} = (NaN, NaN),
) where {G &lt;: AbstractGlacier, F &lt;: AbstractFloat, IF &lt;: AbstractModel, I &lt;: Integer}</code></pre><p>Construct a <code>Results</code> object for a glacier simulation.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::G</code>: The glacier object, subtype of <code>AbstractGlacier</code>.</li><li><code>ifm::IF</code>: The model object, subtype of <code>AbstractModel</code>.</li><li><code>rgi_id::String</code>: The RGI identifier for the glacier. Defaults to <code>glacier.rgi_id</code>.</li><li><code>H::Vector{Matrix{F}}</code>: Ice thickness matrices. Defaults to an empty vector.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness from GlaThiDa. Defaults to <code>glacier.H_glathida</code>.</li><li><code>H_ref::Vector{Matrix{F}}</code>: Reference ice thickness. Defaults to an empty vector.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix. Defaults to a zero matrix of the same size as <code>ifm.S</code>.</li><li><code>B::Matrix{F}</code>: Bed elevation matrix. Defaults to a zero matrix of the same size as <code>glacier.B</code>.</li><li><code>V::Vector{Matrix{F}}</code>: Velocity magnitude matrix. Defaults to an empty vector.</li><li><code>Vx::Vector{Matrix{F}}</code>: Velocity in the x-direction matrix. Defaults to an empty vector.</li><li><code>Vy::Vector{Matrix{F}}</code>: Velocity in the y-direction matrix. Defaults to an empty vector.</li><li><code>V_ref::Vector{Matrix{F}}</code>: Reference velocity magnitude matrix. Defaults to an empty vector.</li><li><code>Vx_ref::Vector{Matrix{F}}</code>: Reference velocity in the x-direction matrix. Defaults to an empty vector.</li><li><code>Vy_ref::Vector{Matrix{F}}</code>: Reference velocity in the y-direction matrix. Defaults to an empty vector.</li><li><code>date_Vref::Vector{F}</code>: Date of velocity observation (mean of <code>date1</code> and <code>date2</code>). Defaults to an empty vector.</li><li><code>date1_Vref::Vector{F}</code>: First date of velocity acquisition. Defaults to an empty vector.</li><li><code>date2_Vref::Vector{F}</code>: Second date of velocity acquisition. Defaults to an empty vector.</li><li><code>Δx::F</code>: Grid spacing in the x-direction. Defaults to <code>glacier.Δx</code>.</li><li><code>Δy::F</code>: Grid spacing in the y-direction. Defaults to <code>glacier.Δy</code>.</li><li><code>lon::F</code>: Longitude of the glacier grid center. Defaults to <code>glacier.cenlon</code>.</li><li><code>lat::F</code>: Latitude of the glacier grid center. Defaults to <code>glacier.cenlat</code>.</li><li><code>nx::I</code>: Number of grid points in the x-direction. Defaults to <code>glacier.nx</code>.</li><li><code>ny::I</code>: Number of grid points in the y-direction. Defaults to <code>glacier.ny</code>.</li><li><code>tspan::Tuple(F, F)</code>: Timespan of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Model parameters. Defaults to <code>nothing</code>.</li><li><code>loss::Union{Nothing, Vector{F}}</code>: Loss values. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Results</code>: A <code>Results</code> object containing the simulation results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/Results.jl#L75-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Results-api"><a class="docstring-binding" href="#Sleipnir.Results-api"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Results{F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>A mutable struct to store the results of simulations.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: Identifier for the RGI (Randolph Glacier Inventory).</li><li><code>H::Vector{Matrix{F}}</code>: Vector of matrices representing glacier ice thickness <code>H</code> over time.</li><li><code>H_glathida::Matrix{F}</code>: Optional matrix for Glathida ice thicknesses.</li><li><code>H_ref::Vector{Matrix{F}}</code>: Reference data for ice thickness.</li><li><code>S::Matrix{F}</code>: Glacier surface altimetry.</li><li><code>B::Matrix{F}</code>: Glacier bedrock.</li><li><code>V::Matrix{F}</code>: Glacier ice surface velocities.</li><li><code>Vx::Matrix{F}</code>: x-component of the glacier ice surface velocity <code>V</code>.</li><li><code>Vy::Matrix{F}</code>: y-component of the glacier ice surface velocity <code>V</code>.</li><li><code>V_ref::Matrix{F}</code>: Reference data for glacier ice surface velocities <code>V</code>.</li><li><code>Vx_ref::Matrix{F}</code>: Reference data for the x-component of the glacier ice surface velocity <code>Vx</code>.</li><li><code>Vy_ref::Matrix{F}</code>: Reference data for the y-component of the glacier ice surface velocity <code>Vy</code>.</li><li><code>date_Vref::Vector{F}</code>: Date of velocity observation (mean of <code>date1</code> and <code>date2</code>).</li><li><code>date1_Vref::Vector{F}</code>: First date of velocity acquisition.</li><li><code>date2_Vref::Vector{F}</code>: Second date of velocity acquisition.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::F</code>: Longitude of the glacier grid center.</li><li><code>lat::F</code>: Latitude of the glacier grid center.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>tspan::Vector{F}</code>: Time span of the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/Results.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ScalarCache-api"><a class="docstring-binding" href="#Sleipnir.ScalarCache-api"><code>Sleipnir.ScalarCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ScalarCache &lt;: Cache</code></pre><p>A cache structure for storing a scalar value as a zero-dimensional array of <code>Float64</code> along with their associated vector-Jacobian products (VJP). This is typically used for constant per glacier laws. Fields:</p><ul><li><code>value::Array{Float64, 0}</code>: The cached scalar value.</li><li><code>vjp_inp::Array{Float64, 0}</code>: VJP with respect to inputs.</li><li><code>vjp_θ::Vector{Float64}</code>: VJP with respect to parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Cache.jl#L78-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ScalarCacheNoVJP-api"><a class="docstring-binding" href="#Sleipnir.ScalarCacheNoVJP-api"><code>Sleipnir.ScalarCacheNoVJP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ScalarCacheNoVJP &lt;: Cache</code></pre><p>A mutable cache structure for storing a scalar value as a zero-dimensional array of <code>Float64</code>. This is typically used for constant per glacier laws. This struct is intended for use cases where the law is not differentiated, and hence the vector-Jacobian products (VJP) are not required. Fields:</p><ul><li><code>value::Array{Float64, 0}</code>: The cached scalar value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/Cache.jl#L39-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.Simulation-api"><a class="docstring-binding" href="#Sleipnir.Simulation-api"><code>Sleipnir.Simulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Simulation</code></pre><p>An abstract type representing a generic simulation. This type is intended to be subclassed by specific simulation types to provide a common interface and shared functionality for all simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/Simulation.jl#L4-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{VM}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping}-api"><a class="docstring-binding" href="#Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{VM}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping}-api"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Constructor for <code>SimulationParameters</code> type, including default values.</p><pre><code class="nohighlight hljs">SimulationParameters(;
    use_MB::Bool = true,
    use_iceflow::Bool = true,
    plots::Bool = true,
    use_velocities::Bool = true,
    f_surface_velocity_factor::F = 1.0,
    overwrite_climate::Bool = false,
    use_glathida_data::Bool = false,
    tspan::Tuple{F, F} = (2010.0, 2015.0),
    step_MB::F = 1/12,
    multiprocessing::Bool = true,
    workers::I = 4,
    working_dir::String = &quot;&quot;,
    test_mode::Bool = false,
    rgi_paths::Dict{String, String} = Dict{String, String}(),
    ice_thickness_source::String = &quot;Farinotti19&quot;,
    mapping::VM = MeanDateVelocityMapping(),
    gridScalingFactor::I = 1,
) where {I &lt;: Integer, F &lt;: AbstractFloat, VM &lt;: VelocityMapping}</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>use_MB::Bool</code>: Whether to use mass balance (default: <code>true</code>).</li><li><code>use_iceflow::Bool</code>: Whether to use ice flow (default: <code>true</code>).</li><li><code>plots::Bool</code>: Whether to generate plots (default: <code>true</code>).</li><li><code>use_velocities::Bool</code>: Whether to calculate velocities (default: <code>true</code>).</li><li><code>f_surface_velocity_factor::F</code>: Numerical factor representing the ratio between depth integrated ice velocity and surface velocity (default: <code>1.0</code>).</li><li><code>overwrite_climate::Bool</code>: Whether to overwrite climate data (default: <code>false</code>).</li><li><code>use_glathida_data::Bool</code>: Whether to use GLATHIDA data (default: <code>false</code>).</li><li><code>float_type::DataType</code>: Data type for floating point numbers (default: <code>Float64</code>).</li><li><code>int_type::DataType</code>: Data type for integers (default: <code>Int64</code>).</li><li><code>tspan::Tuple{F, F}</code>: Time span for the simulation (default: <code>(2010.0, 2015.0)</code>).</li><li><code>step_MB::F</code>: Time step for the MB simulation (default: <code>1/12</code>).</li><li><code>multiprocessing::Bool</code>: Whether to use multiprocessing (default: <code>true</code>).</li><li><code>workers::I</code>: Number of workers for multiprocessing (default: <code>4</code>).</li><li><code>working_dir::String</code>: Working directory for the simulation (default: <code>&quot;&quot;</code>).</li><li><code>test_mode::Bool</code>: Whether to run in test mode (default: <code>false</code>).</li><li><code>rgi_paths::Dict{String, String}</code>: Dictionary of RGI paths (default: <code>Dict{String, String}()</code>).</li><li><code>ice_thickness_source::String</code>: Source of ice thickness data, either <code>&quot;Millan22&quot;</code> or <code>&quot;Farinotti19&quot;</code> (default: <code>&quot;Farinotti19&quot;</code>).</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of the velocity product datacube to the glacier grid.</li><li><code>gridScalingFactor::I</code>: Grid downscaling factor, used to speed-up the tests. Default value is 1 which means no downscaling is applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>simulation_parameters</code>: A new <code>SimulationParameters</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If <code>ice_thickness_source</code> is not <code>&quot;Millan22&quot;</code> or <code>&quot;Farinotti19&quot;</code>.</li></ul><p><strong>Notes</strong></p><ul><li>If the global variable <code>ODINN_OVERWRITE_MULTI</code> is set to true, multiprocessing is is enabled in any case and the number of workers specified in the simulation parameters must correspond to the number of processes with which Julia has been started. This is to allow the documentation to build successfully in ODINN as we cannot change the number of process in the CI.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/SimulationParameters.jl#L50-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.SimulationParameters-api"><a class="docstring-binding" href="#Sleipnir.SimulationParameters-api"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A structure to hold simulation parameters for a simulation in ODINN.</p><pre><code class="nohighlight hljs">struct SimulationParameters{I &lt;: Integer, F &lt;: AbstractFloat, VM &lt;: VelocityMapping} &lt;: AbstractParameters</code></pre><p><strong>Fields</strong></p><ul><li><code>use_MB::Bool</code>: Flag to indicate whether mass balance should be used.</li><li><code>use_iceflow::Bool</code>: Flag to indicate whether ice flow should be used.</li><li><code>plots::Bool</code>: Flag to indicate whether plots should be generated.</li><li><code>use_velocities::Bool</code>: Flag to indicate whether velocities should be calculated.</li><li><code>f_surface_velocity_factor::F</code>: Numerical factor representing the ratio between depth integrated ice velocity and surface velocity.</li><li><code>overwrite_climate::Bool</code>: Flag to indicate whether to overwrite climate data.</li><li><code>use_glathida_data::Bool</code>: Flag to indicate whether to use GLATHIDA data.</li><li><code>tspan::Tuple{F, F}</code>: Time span for the simulation.</li><li><code>step_MB::F</code>: Time step for the MB simulation.</li><li><code>multiprocessing::Bool</code>: Flag to indicate whether multiprocessing should be used.</li><li><code>workers::I</code>: Number of workers for multiprocessing.</li><li><code>working_dir::String</code>: Directory for working files.</li><li><code>test_mode::Bool</code>: Flag to indicate whether to run in test mode.</li><li><code>rgi_paths::Dict{String, String}</code>: Dictionary of RGI paths.</li><li><code>ice_thickness_source::String</code>: Source of ice thickness data.</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of the velocity product datacube to the glacier grid.</li><li><code>gridScalingFactor::I</code>: Grid downscaling factor, used to speed-up the tests. Default value is 1 which means no downscaling is applied.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/parameters/SimulationParameters.jl#L2-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.SurfaceVelocityData</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Constructs <code>SurfaceVelocityData</code> using data from Rabatel et. al (2023) with the given parameters, including default ones.</p><p>function SurfaceVelocityData(; x::Union{Vector{F}, Nothing} = nothing, y::Union{Vector{F}, Nothing} = nothing, lat::Union{Vector{F}, Nothing} = nothing, lon::Union{Vector{F}, Nothing} = nothing, vx::Union{Vector{Matrix{F}}, Nothing} = nothing, vy::Union{Vector{Matrix{F}}, Nothing} = nothing, vabs::Union{Vector{Matrix{F}}, Nothing} = nothing, vx<em>error::Union{Vector{F}, Nothing} = nothing, vy</em>error::Union{Vector{F}, Nothing} = nothing, vabs<em>error::Union{Vector{F}, Nothing} = nothing, date::Union{Vector{DateTime}, Nothing} = nothing, date1::Union{Vector{DateTime}, Nothing} = nothing, date2::Union{Vector{DateTime}, Nothing} = nothing, date</em>error::Union{Vector{Day}, Vector{Millisecond}, Nothing} = nothing, flag::Union{BitMatrix, Nothing} = nothing, isGridGlacierAligned::Bool = false, ) where {F &lt;: AbstractFloat}</p><p>Constructor for ice surface velocity data based on Rabatel et. al (2023).</p><p>Important remarks:</p><ul><li>Velocities values are reported in m/yr. Positive velocities correspond to the direction of increasing index of the glacier. When the glacier is oriented in east-west and south-north (see latitude and coordinate ordering), positive velocities of the ice surface velocity correspond to positive east-west and south-north velocity component.</li><li>The error in velocity is unique per timestamp, rather than being pixel distributed.</li><li>The error in the absolute velocities <code>vabs_error</code> is overestimated.</li></ul><p>References:</p><ul><li>Rabatel, A., Ducasse, E., Millan, R. &amp; Mouginot, J. Satellite-Derived Annual Glacier Surface Flow Velocity Products for the European Alps, 2015–2021. Data 8, 66 (2023).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData.jl#L47-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.SurfaceVelocityData-api"><a class="docstring-binding" href="#Sleipnir.SurfaceVelocityData-api"><code>Sleipnir.SurfaceVelocityData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A mutable struct representing a surface velocity data. Notice that all fields can be empty by providing <code>nothing</code> as the default value.</p><p><code>SurfaceVelocityData{F &lt;: AbstractFloat} &lt;: AbstractData</code></p><p><strong>Fields</strong></p><ul><li><code>x::Union{Vector{F}, Nothing}</code>: Easting of observation.</li><li><code>y::Union{Vector{F}, Nothing}</code>: Northing of observation.</li><li><code>lat::Union{Vector{F}, Nothing}</code>: Latitude of observation.</li><li><code>lon::Union{Vector{F}, Nothing}</code>: Longitude of observation.</li><li><code>vx::Union{Vector{Matrix{F}}, Nothing}</code>: x / longitudinal component of surface velocity. Positive velocities correspond to the direction of increasing index of the glacier x-coordinate.</li><li><code>vy::Union{Vector{Matrix{F}}, Nothing}</code>: y / latitudinal component of surface velocity. Positive velocities correspond to the direction of increasing index of the glacier y-coordinate.</li><li><code>vabs::Union{Vector{Matrix{F}}, Nothing}</code>: Absolute ice surface velocity.</li><li><code>vx_error::Union{Vector{F}, Nothing}</code>: Error in <code>vx</code></li><li><code>vy_error::Union{Vector{F}, Nothing}</code>: Error in <code>vy</code></li><li><code>vabs_error::Union{Vector{F}, Nothing}</code>: Error in <code>vabs</code>.</li><li><code>date::Union{Vector{DateTime}, Nothing}</code>: Date of observation (mean of <code>date1</code> and <code>date2</code>)</li><li><code>date1::Union{Vector{DateTime}, Nothing}</code>: First date of acquisition.</li><li><code>date2::Union{Vector{DateTime}, Nothing}</code>: Second date of acquisition.</li><li><code>date_error::Union{Vector{Day}, Vector{Millisecond}, Nothing}</code>: Error in <code>date</code>.</li><li><code>flag::Union{BitMatrix, Nothing}</code>: Flag indicating whether a pixel is considered as reliable or not.</li><li><code>isGridGlacierAligned::Bool</code>: Whether the data have been gridded to the glacier grid or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData.jl#L3-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ThicknessData-api"><a class="docstring-binding" href="#Sleipnir.ThicknessData-api"><code>Sleipnir.ThicknessData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Simple time series of ice thickness data to test transient inversion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/ThicknessData.jl#L3-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.VJPType-api"><a class="docstring-binding" href="#Sleipnir.VJPType-api"><code>Sleipnir.VJPType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VJPType</code></pre><p>Abstract type representing the mode of Vector-Jacobian Product (VJP) computation used in a law. Subtypes of <code>VJPType</code> define how the VJP is evaluated (e.g., custom or using DifferentiationInterface.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.VelocityMapping-api"><a class="docstring-binding" href="#Sleipnir.VelocityMapping-api"><code>Sleipnir.VelocityMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelocityMapping</code></pre><p>Abstract type representing the mapping to use in order to map the ice velocity products onto the glacier grid. It contains all needed information to build both the spatial projection, and how to interpolate the data in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityMapping.jl#L3-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.DummyClimate2D-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.DummyClimate2D-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.DummyClimate2D</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DummyClimate2D(;
    longterm_temps::Vector{F} = []
) where {F &lt;: AbstractFloat}</code></pre><p>Dummy climate initialization for very specific use cases where we don&#39;t have climate data and we need to build a minimalistic climate with only a few data. For the moment it supports only the initialization of the long term temperatures. It returns a minimalistic Climate2D instance.</p><p>Arguments:</p><ul><li><code>longterm_temps::Vector{F}</code>: Long term temperatures.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/Climate2D.jl#L225-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ReverseUTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.ReverseUTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.ReverseUTMercator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ReverseUTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0, zone::Union{Nothing, Int}=nothing, hemisphere=nothing) where {F &lt;: AbstractFloat}</code></pre><p>Transverse Mercator Projection. This function reprojects latitude/longitude into northing/easting coordinates.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `k`: scale factor of the projection
- `cenlon`: Central longitude used in the projection
- `cenlat`: Central latitude used in the projection
- `x0`: Shift in easting
- `y0`: Shift in northing
- `zone` : Zone of the projection
- `hemisphere`: Either :north or :south</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L671-L686">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.UTMercator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0, zone::Union{Nothing, Int}=nothing, hemisphere=nothing) where {F &lt;: AbstractFloat}</code></pre><p>Transverse Mercator Projection. This function reprojects northing/easting coordinates into latitude/longitude.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `k`: scale factor of the projection
- `cenlon`: Central longitude used in the projection
- `cenlat`: Central latitude used in the projection
- `x0`: Shift in easting
- `y0`: Shift in northing
- `zone` : Zone of the projection
- `hemisphere`: Either :north or :south</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L634-L649">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.apply_all_callback_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api"><a class="docstring-binding" href="#Sleipnir.apply_all_callback_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api"><code>Sleipnir.apply_all_callback_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_all_callback_laws!(model::AbstractModel, cache, simulation, glacier_idx, t, θ)</code></pre><p>This function is a placeholder and must be implemented for your custom model type.</p><p>It is intended to apply all callback laws in the simulation to update the model cache for a given glacier at time <code>t</code> with parameters <code>θ</code>. By default, calling this function will throw an error to indicate that the user should provide their own implementation tailored to their model.</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractModel</code>: The model instance.</li><li><code>cache</code>: The cache object storing state variables.</li><li><code>simulation</code>: The simulation context.</li><li><code>glacier_idx</code>: Index identifying the glacier.</li><li><code>t</code>: The current simulation time.</li><li><code>θ</code>: The parameter vector.</li></ul><p><strong>Throws</strong></p><ul><li>Always throws an error: <code>&quot;This function should not be called. Implement apply_all_callback_laws! for your own model.&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L134-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.apply_all_non_callback_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api"><a class="docstring-binding" href="#Sleipnir.apply_all_non_callback_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api"><code>Sleipnir.apply_all_non_callback_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_all_non_callback_laws!(model::AbstractModel, cache, simulation, glacier_idx, t, θ)</code></pre><p>This function is a placeholder and must be implemented for your custom model type.</p><p>It is intended to apply all non-callback laws in the simulation to update the model cache for a given glacier at time <code>t</code> with parameters <code>θ</code>. By default, calling this function will throw an error to indicate that the user should provide their own implementation tailored to their model.</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractModel</code>: The model instance.</li><li><code>cache</code>: The cache object storing state variables.</li><li><code>simulation</code>: The simulation context.</li><li><code>glacier_idx</code>: Index identifying the glacier.</li><li><code>t</code>: The current simulation time.</li><li><code>θ</code>: The parameter vector.</li></ul><p><strong>Throws</strong></p><ul><li>Always throws an error: <code>&quot;This function should not be called. Implement apply_all_non_callback_laws! for your own model.&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L84-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.apply_t_cumul_grad!-Union{Tuple{F}, Tuple{Climate2Dstep, Matrix{F}}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.apply_t_cumul_grad!-Union{Tuple{F}, Tuple{Climate2Dstep, Matrix{F}}} where F&lt;:AbstractFloat-api"><code>Sleipnir.apply_t_cumul_grad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_t_cumul_grad!(climate_2D_step::Climate2Dstep, S::Matrix{F}) where {F &lt;: AbstractFloat}</code></pre><p>Apply temperature and precipitation gradients based on the positive degree day (PDD) and on the elevation matrix <code>S</code> to the climate data in <code>climate_2D_step</code>.</p><p><strong>Arguments</strong></p><ul><li><code>climate_2D_step::Climate2Dstep</code>: The climate data structure containing temperature, PDD, gradients, and reference height.</li><li><code>S::Matrix{F}</code>: A matrix of elevations.</li></ul><p><strong>Description</strong></p><p>This function updates the temperature and PDD fields in <code>climate_2D_step</code> by applying the respective gradients based on the difference between the elevation matrix <code>S</code> and the reference height. Negative PDD values are cropped to zero. Additionally, the function adjusts the rain and snow fractions based on the updated temperature values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L195-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}-api"><a class="docstring-binding" href="#Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}-api"><code>Sleipnir.apply_t_grad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_t_grad!(climate::RasterStack, dem::Raster)</code></pre><p>Apply temperature gradients to the climate data based on the digital elevation model (DEM).</p><p><strong>Arguments</strong></p><ul><li><code>climate::RasterStack</code>: A <code>RasterStack</code> object containing climate data, including temperature and gradient information.</li><li><code>dem::Raster</code>: A <code>Raster</code> object representing the digital elevation model (DEM) data.</li></ul><p><strong>Description</strong></p><p>This function adjusts the temperature data in the <code>climate</code> object by applying the temperature gradients. The adjustment is based on the difference between the mean elevation from the DEM data and a reference height specified in the metadata of the <code>climate</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L223-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.block_average-Union{Tuple{F}, Tuple{Matrix{F}, Int64}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.block_average-Union{Tuple{F}, Tuple{Matrix{F}, Int64}} where F&lt;:AbstractFloat-api"><code>Sleipnir.block_average</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">block_average(mat::Matrix{F}, n::Int) where {F &lt;: AbstractFloat}</code></pre><p>Downsamples a matrix by averaging non-overlapping <code>n x n</code> blocks. Returns a matrix of the block-averaged values with size <code>(div(X, n), div(Y, n))</code> where <code>(X, Y) = size(mat)</code>.</p><p>Arguments</p><ul><li><code>mat::Matrix{F}</code>: Input 2D matrix.</li><li><code>n::Int</code>: Block size for downsampling. Both matrix dimensions must be divisible by <code>n</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L830-L841">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.block_average_pad_edge-Union{Tuple{F}, Tuple{Matrix{F}, Int64}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.block_average_pad_edge-Union{Tuple{F}, Tuple{Matrix{F}, Int64}} where F&lt;:AbstractFloat-api"><code>Sleipnir.block_average_pad_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">block_average_pad_edge(mat::Matrix{F}, n::Int) where {F &lt;: AbstractFloat}</code></pre><p>Downsamples a matrix by averaging <code>n x n</code> blocks, using edge-replication padding when the matrix dimensions are not divisible by <code>n</code>. Edge padding replicates the last row/column values to expand the matrix so that both dimensions are divisible by <code>n</code>. Returns a matrix of averaged values with size <code>(ceil(Int, X/n), ceil(Int, Y/n))</code>.</p><p>Arguments</p><ul><li><code>mat::Matrix{F}</code>: Input 2D matrix.</li><li><code>n::Int</code>: Block size for downsampling.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L779-L792">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.build_affect-Tuple{AbstractLaw, Any, Any, Any}-api"><a class="docstring-binding" href="#Sleipnir.build_affect-Tuple{AbstractLaw, Any, Any, Any}-api"><code>Sleipnir.build_affect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_affect(law::AbstractLaw, cache, glacier_idx, θ)</code></pre><p>Return a <code>!</code>-style function suitable for use in a callback, which applies the given <code>law</code> to update the <code>cache</code> for a specific glacier and parameters <code>θ</code>, using the simulation time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/AbstractLaw.jl#L88-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.combine_velocity_data-Tuple{Any}-api"><a class="docstring-binding" href="#Sleipnir.combine_velocity_data-Tuple{Any}-api"><code>Sleipnir.combine_velocity_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">combine_velocity_data(refVelocities; merge=false)</code></pre><p>Combine multiple ice surface velocity datasets into a single <code>SurfaceVelocityData</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>refVelocities::Vector{SurfaceVelocityData}</code>: A vector of ice surface velocity datasets to combine. Each element must have the same grid alignment (<code>isGridGlacierAligned</code> must be <code>true</code> for all).</li><li><code>merge::Bool=false</code>: If <code>true</code>, velocities with the same <code>date</code> are averaged, and corresponding date ranges (<code>date1</code>, <code>date2</code>) are reduced to their min/max. If <code>false</code>, data are simply concatenated.</li></ul><p><strong>Returns</strong></p><ul><li><code>SurfaceVelocityData</code>: A single object containing the combined velocity data, including <code>vx</code>, <code>vy</code>, <code>vabs</code> and their associated errors, as well as coordinate (<code>x</code>, <code>y</code>, <code>lat</code>, <code>lon</code>) and date information. The <code>isGridGlacierAligned</code> field reflects whether all input datasets were aligned.</li></ul><p><strong>Notes</strong></p><ul><li>The function asserts that all input datasets are aligned on the same grid.</li><li>When <code>merge=true</code>, velocities and errors are averaged over datasets sharing the same <code>date</code>.</li><li>Uses <code>nanmean</code> for averaging to handle missing data.</li><li><code>date_error</code> is set to <code>nothing</code> when merging.    # Check all surfaces are on the same grid as the glacier</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L492-L512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.create_results-Union{Tuple{F}, Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any, Vector{F}}} where {SIM&lt;:Simulation, I&lt;:Integer, F&lt;:AbstractFloat}-api"><a class="docstring-binding" href="#Sleipnir.create_results-Union{Tuple{F}, Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any, Vector{F}}} where {SIM&lt;:Simulation, I&lt;:Integer, F&lt;:AbstractFloat}-api"><code>Sleipnir.create_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_results(
    simulation::SIM,
    glacier_idx::I,
    solution,
    tstops::Vector{F};
    processVelocity::Union{Nothing, Function} = nothing,
) where {SIM &lt;: Simulation, I &lt;: Integer}</code></pre><p>Create a <code>Results</code> object from a given simulation and solution.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: The simulation object of type <code>Simulation</code>.</li><li><code>glacier_idx::I</code>: The index of the glacier within the simulation.</li><li><code>solution</code>: The solution object containing all the steps including intermediate ones.</li><li><code>tstops::Vector{F}</code>: The list of time steps to use to construct the results.</li><li><code>processVelocity::Union{Nothing, Function}=nothing</code>: Post processing function to map the ice thickness to the surface velocity. It is called before creating the results. It takes as inputs simulation, ice thickness (matrix) and the associated time and returns 3 variables Vx, Vy, V which are all matrix. Defaults is nothing which means no post processing is applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>results</code>: A <code>Results</code> object containing the processed simulation data.</li></ul><p><strong>Details</strong></p><p>The function processes the solution to select the last value for each time step. It then constructs a <code>Results</code> object containing various attributes from the simulation and the iceflow model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_utils.jl#L23-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}-api"><a class="docstring-binding" href="#Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}-api"><code>Sleipnir.downscale_2D_climate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">downscale_2D_climate!(glacier::Glacier2D)</code></pre><p>Update the 2D climate structure for a given glacier by downscaling climate data.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::Glacier2D</code>: The glacier object containing the climate data to be downscaled.</li></ul><p><strong>Description</strong></p><p>This function updates the 2D climate structure of the given glacier by:</p><ol><li>Updating the temperature, PDD (Positive Degree Days), snow, and rain fields in the 2D climate step with the corresponding values from the climate step.</li><li>Updating the gradients and average gradients in the 2D climate step.</li><li>Applying temperature gradients and computing the snow/rain fraction for the selected period by reprojecting the current <code>S</code> with the <code>RasterStack</code> structure.</li></ol><p><strong>Notes</strong></p><pre><code class="nohighlight hljs"># Update 2D climate structure</code></pre><ul><li>The function modifies the <code>glacier</code> object in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L263-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.downscale_2D_climate-Tuple{Sleipnir.ClimateStep, Matrix{&lt;:AbstractFloat}, Dict}-api"><a class="docstring-binding" href="#Sleipnir.downscale_2D_climate-Tuple{Sleipnir.ClimateStep, Matrix{&lt;:AbstractFloat}, Dict}-api"><code>Sleipnir.downscale_2D_climate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">downscale_2D_climate(climate_step::ClimateStep, S::Matrix{&lt;: AbstractFloat}, Coords::Dict)</code></pre><p>Downscales climate data to a 2D grid based on the provided matrix of surface elevation and coordinates.</p><p><strong>Arguments</strong></p><ul><li><p><code>climate_step::ClimateStep</code>: A struct containing climate data for a specific time step. Expected fields are:</p><ul><li><code>&quot;avg_temp&quot;</code>: Average temperature.</li><li><code>&quot;temp&quot;</code>: Temperature.</li><li><code>&quot;prcp&quot;</code>: Precipitation.</li><li><code>&quot;gradient&quot;</code>: Temperature gradient.</li><li><code>&quot;avg_gradient&quot;</code>: Average temperature gradient.</li><li><code>&quot;ref_hgt&quot;</code>: Reference height.</li></ul></li><li><p><code>S::Matrix{&lt;: AbstractFloat}</code>: Surface elevation data.</p></li><li><p><code>Coords::Dict</code>: A dictionary with keys <code>&quot;lon&quot;</code> and <code>&quot;lat&quot;</code> for longitude and latitude coordinates.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Climate2Dstep</code>: A <code>Climate2Dstep</code> object containing the downscaled climate data with fields:</p><ul><li><code>temp</code>: 2D array of temperature.</li><li><code>PDD</code>: 2D array of positive degree days.</li><li><code>snow</code>: 2D array of snow precipitation.</li><li><code>rain</code>: 2D array of rain precipitation.</li><li><code>gradient</code>: Temperature gradient.</li><li><code>avg_gradient</code>: Average temperature gradient.</li><li><code>x</code>: Longitude coordinates.</li><li><code>y</code>: Latitude coordinates.</li><li><code>ref_hgt</code>: Reference height.</li></ul></li></ul><p><strong>Description    # Create dummy 2D arrays to have a base to apply gradients afterwards</strong></p><p>This function creates dummy 2D arrays based on the provided surface elevation data and applies the climate step data to these arrays. It then constructs a <code>Climate2Dstep</code> object with the downscaled climate data and applies temperature gradients to compute the snow/rain fraction for the selected period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L301-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.emptyPrepVJP-NTuple{6, Any}-api"><a class="docstring-binding" href="#Sleipnir.emptyPrepVJP-NTuple{6, Any}-api"><code>Sleipnir.emptyPrepVJP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emptyPrepVJP(cache, vjpPrep, simulation, glacier_idx, t, θ)
emptyPrepVJPWithInputs(cache, vjpPrep, inputs, θ)</code></pre><p>Function that defines an empty <code>!</code>-style function for the preparation of the VJPs. The two methods define the two possible signatures for the function that updates the cache in-place. Trying to apply this function will yield an error. It is for internal use only and it isn&#39;t exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L16-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.emptyVJP-NTuple{5, Any}-api"><a class="docstring-binding" href="#Sleipnir.emptyVJP-NTuple{5, Any}-api"><code>Sleipnir.emptyVJP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emptyVJP(cache, simulation, glacier_idx, t, θ)
emptyVJPWithInputs(cache, inputs, θ)</code></pre><p>Function that defines an empty <code>!</code>-style function for the VJPs. The two methods define the two possible signatures for the function that updates the cache in-place. It is for internal use only and it isn&#39;t exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L5-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.fake_interpolated_datacube-Tuple{}-api"><a class="docstring-binding" href="#Sleipnir.fake_interpolated_datacube-Tuple{}-api"><code>Sleipnir.fake_interpolated_datacube</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fake_interpolated_datacube()</code></pre><p>Create a fake datacube of ice surface velocity time series. It corresponds to the interpolated data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/data/surface_velocity.jl#L2-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.fake_multi_datacube-Tuple{}-api"><a class="docstring-binding" href="#Sleipnir.fake_multi_datacube-Tuple{}-api"><code>Sleipnir.fake_multi_datacube</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fake_multi_datacube()</code></pre><p>Create a fake datacube of ice surface velocity time series. It corresponds to the filtered multi source data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/data/surface_velocity.jl#L75-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.fillNaN!-api"><a class="docstring-binding" href="#Sleipnir.fillNaN!-api"><code>Sleipnir.fillNaN!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fillNaN!(A::AbstractArray, fill::Number=zero(eltype(A)))</code></pre><p>Replace all <code>NaN</code> values in the array <code>A</code> with the specified <code>fill</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The array in which <code>NaN</code> values will be replaced.</li><li><code>fill::Number</code>: The value to replace <code>NaN</code> with. Defaults to <code>zero(eltype(A))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L547-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.fillNaN-api"><a class="docstring-binding" href="#Sleipnir.fillNaN-api"><code>Sleipnir.fillNaN</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fillNaN(A::AbstractArray, fill::Number=zero(eltype(A)))</code></pre><p>Replace all NaN values in the array <code>A</code> with the specified <code>fill</code> value. If no <code>fill</code> value is provided, it defaults to the zero value of the element type of <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The input array that may contain NaN values.</li><li><code>fill::Number</code>: The value to replace NaNs with. Defaults to <code>zero(eltype(A))</code>.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type and shape as <code>A</code>, with all NaN values replaced by <code>fill</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L563-L577">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.fillZeros!-api"><a class="docstring-binding" href="#Sleipnir.fillZeros!-api"><code>Sleipnir.fillZeros!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fillZeros!(A::AbstractArray, fill::Number=NaN)</code></pre><p>Replace all zero elements in the array <code>A</code> with the specified <code>fill</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The array in which to replace zero elements.</li><li><code>fill::Number</code>: The value to replace zero elements with. Defaults to <code>NaN</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L582-L591">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.fillZeros-api"><a class="docstring-binding" href="#Sleipnir.fillZeros-api"><code>Sleipnir.fillZeros</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fillZeros(A::AbstractArray, fill::Number=NaN) -&gt; AbstractArray</code></pre><p>Replace all zero elements in the array <code>A</code> with the specified <code>fill</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The input array in which zero elements are to be replaced.</li><li><code>fill::Number</code>: The value to replace zero elements with. Defaults to <code>NaN</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray</code>: A new array with zero elements replaced by the <code>fill</code> value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L598-L611">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.filter_missing_glaciers!-Tuple{Vector{String}, Sleipnir.Parameters}-api"><a class="docstring-binding" href="#Sleipnir.filter_missing_glaciers!-Tuple{Vector{String}, Sleipnir.Parameters}-api"><code>Sleipnir.filter_missing_glaciers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter_missing_glaciers!(rgi_ids::Vector{String}, params::Parameters)</code></pre><p>Filter out glaciers that cannot be processed from the given list of RGI IDs.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_ids::Vector{String}</code>: A vector of RGI IDs representing glaciers.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li></ul><p><strong>Description</strong></p><p>This function filters out glaciers from the provided <code>rgi_ids</code> list based on two criteria:</p><ol><li>Glaciers that are marked as level 2 in the RGI statistics CSV file.</li><li>Glaciers listed in the <code>missing_glaciers.jld2</code> file located in the <code>params.simulation.working_dir</code> directory.</li></ol><p><strong>Notes</strong></p><p><strong>TODO: see if this is necessary, otherwise remove</strong></p><ul><li>The RGI statistics CSV file is downloaded from a remote server.</li><li>If the <code>missing_glaciers.jld2</code> file is not available, a warning is logged and the function skips this filtering step.    # Check which glaciers we can actually process # TODO: see if this is necessary, otherwise remove</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L468-L491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.generate_raw_climate_files-Tuple{String, SimulationParameters}-api"><a class="docstring-binding" href="#Sleipnir.generate_raw_climate_files-Tuple{String, SimulationParameters}-api"><code>Sleipnir.generate_raw_climate_files</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_raw_climate_files(rgi_id::String, simparams::SimulationParameters)</code></pre><p>Generate raw climate files for a given RGI (Randolph Glacier Inventory) ID and simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI ID for which to generate raw climate files.</li><li><code>simparams::SimulationParameters</code>: The simulation parameters containing the time span and RGI paths.</li></ul><p><strong>Description</strong></p><p>This function generates raw climate files for a specified RGI ID if they do not already exist. It retrieves raw climate data, ensures the desired period is covered, crops the data to the desired time period, and saves the raw climate data to disk.</p><p><strong>Details</strong></p><ol><li><p>Constructs the path to the RGI directory using the provided <code>rgi_id</code> and <code>simparams</code>.</p></li><li><p>Checks if the raw climate file for the specified time span already exists.</p></li><li><p>If the file does not exist:</p><ul><li>Retrieves the raw climate data.</li><li>Ensures the desired period is covered by the climate data.</li><li>Crops the climate data to the desired time period.</li><li>Saves the cropped climate data to disk. # Initialize RGI path to be accessible outside the try block</li><li>Triggers garbage collection to free up memory.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L10-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_cumulative_climate!-api"><a class="docstring-binding" href="#Sleipnir.get_cumulative_climate!-api"><code>Sleipnir.get_cumulative_climate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_cumulative_climate!(climate, t::AbstractFloat, step::AbstractFloat, gradient_bounds=[-0.009, -0.003])
get_cumulative_climate!(climate, period::StepRange{Date, Day}, gradient_bounds=[-0.009, -0.003])</code></pre><p>Calculate and update the cumulative climate data for a given period. The user can choose between providing a specific time <code>t</code> and a time step <code>step</code>, or a time period defined by <code>period</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>climate::Climate</code>: The climate object containing raw climate data.</li><li><code>gradient_bounds::Vector{Float64}</code>: Optional. The bounds within which to clamp the gradient values. Default is <code>[-0.009, -0.003]</code>. Optional parameters to specify the time period:</li><li><code>t::AbstractFloat</code>: Time at which the cumulative climate data should be computed.</li><li><code>step::AbstractFloat</code>: Time step used to compute the cumulative climate data. Together with <code>t</code> they define a time period. or</li><li><code>period::StepRange{Date, Day}</code>: The time period for which to compute the cumulative climate data.</li></ul><p><strong>Updates</strong></p><ul><li><code>climate.climate_raw_step</code>: The raw climate data for the given period.</li><li><code>climate.avg_temps</code>: The average temperature for the given period.</li><li><code>climate.avg_gradients</code>: The average gradient for the given period.</li><li><code>climate.climate_step.prcp</code>: The cumulative precipitation for the given period.</li><li><code>climate.climate_step.temp</code>: The cumulative temperature for the given period.</li><li><code>climate.climate_step.gradient</code>: The cumulative gradient for the given period.</li><li><code>climate.climate_step.avg_temp</code>: The average temperature for the given period.</li><li><code>climate.climate_step.avg_gradient</code>: The average gradient for the given period.</li><li><code>climate.climate_step.ref_hgt</code>: The reference height from the raw climate data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L68-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_cumulative_climate-api"><a class="docstring-binding" href="#Sleipnir.get_cumulative_climate-api"><code>Sleipnir.get_cumulative_climate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_cumulative_climate(
    climate::RasterStack,
    gradient_bounds::Vector{Float64}=[-0.009, -0.003],
)</code></pre><p>Calculate cumulative climate statistics from the given climate data.</p><p><strong>Keyword arguments</strong></p><ul><li><code>climate::RasterStack</code>: A <code>RasterStack</code> object containing temperature, precipitation, and gradient data.</li><li><code>gradient_bounds::Vector{Float64}</code>: A two-element vector specifying the lower and upper bounds for the gradient values. Defaults to <code>[-0.009, -0.003]</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p><code>climate_sum::ClimateStep</code>: A struct containing the following fields:</p><ul><li><code>&quot;temp&quot;</code>: The sum of positive degree days (PDDs) from the temperature data.</li><li><code>&quot;prcp&quot;</code>: The sum of precipitation data.</li><li><code>&quot;gradient&quot;</code>: The sum of gradient data, clipped within the specified bounds.</li><li><code>&quot;avg_temp&quot;</code>: The average temperature.</li><li><code>&quot;avg_gradient&quot;</code>: The average gradient.</li><li><code>&quot;ref_hgt&quot;</code>: The reference height from the climate metadata.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The temperature data is modified to only include positive degree-day values (PDDs).</li><li>The gradient data is clipped within the specified bounds to ensure plausible values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L123-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_glathida!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters}} where G&lt;:Glacier2D-api"><a class="docstring-binding" href="#Sleipnir.get_glathida!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters}} where G&lt;:Glacier2D-api"><code>Sleipnir.get_glathida!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_glathida!(glaciers::Vector{G}, params::Parameters; force=false) where {G &lt;: Glacier2D}</code></pre><p>Retrieve and process glacier thickness data for a vector of <code>Glacier2D</code> objects.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{Glacier2D}</code>: A vector of <code>Glacier2D</code> objects for which the glacier thickness data is to be retrieved.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li><li><code>force::Bool=false</code>: A boolean flag indicating whether to force the retrieval of glacier thickness data.</li></ul><p><strong>Returns</strong></p><ul><li><code>gtd_grids::Vector</code>: A vector of glacier thickness data grids.</li><li><code>glaciers::Vector{Glacier2D}</code>: The updated vector of <code>Glacier2D</code> objects after removing glaciers with no data.</li></ul><p><strong>Description</strong></p><p>This function retrieves glacier thickness data for each glacier in the input vector using parallel processing. It updates a list of missing glaciers if any glacier has all data points equal to zero. The function then removes glaciers with no data from both the <code>gtd_grids</code> and <code>glaciers</code> vectors and returns the updated vectors.</p><p><strong>Notes</strong></p><ul><li>The function uses <code>pmap</code> for parallel processing of glaciers.</li><li>The list of missing glaciers is stored in a JLD2 file located at <code>params.simulation.working_dir/data/missing_glaciers.jld2</code>.</li><li>Glaciers with no data are identified and removed based on the condition that all data points in their thickness grid are zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L371-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_glathida_glacier-Tuple{Glacier2D, Sleipnir.Parameters, Any}-api"><a class="docstring-binding" href="#Sleipnir.get_glathida_glacier-Tuple{Glacier2D, Sleipnir.Parameters, Any}-api"><code>Sleipnir.get_glathida_glacier</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_glathida_glacier(glacier::Glacier2D, params::Parameters, force)</code></pre><p>Retrieve or generate the glathida glacier grid for a given glacier.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::Glacier2D</code>: The glacier object for which the glathida grid is to be retrieved or generated.</li><li><code>params::Parameters</code>: The parameters object containing simulation settings.</li><li><code>force</code>: A boolean flag indicating whether to force regeneration of the glathida grid even if it already exists.</li></ul><p><strong>Returns</strong></p><ul><li><code>gtd_grid</code>: A 2D array representing the glathida glacier grid.</li></ul><p><strong>Description</strong></p><p>This function checks if the glathida glacier grid file (<code>glathida.h5</code>) exists in the specified path. If the file exists and <code>force</code> is <code>false</code>, it reads the grid from the file. Otherwise, it reads the glacier thickness data from a CSV file (<code>glathida_data.csv</code>), computes the average thickness for each grid cell, and saves the resulting grid to an HDF5 file (<code>glathida.h5</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L422-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters, Rasters.RasterStack, Matrix{&lt;:AbstractFloat}}-api"><a class="docstring-binding" href="#Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters, Rasters.RasterStack, Matrix{&lt;:AbstractFloat}}-api"><code>Sleipnir.get_longterm_temps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_longterm_temps(rgi_id::String, params::Parameters, climate::RasterStack) -&gt; Array{Float64}</code></pre><p>Calculate the long-term average temperatures for a given glacier.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) identifier for the glacier.</li><li><code>params::Parameters</code>: A struct containing simulation parameters, including paths to RGI data.</li><li><code>climate::RasterStack</code>: A <code>RasterStack</code> object containing climate data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64}</code>: An array of long-term average temperatures.</li></ul><p><strong>Description</strong></p><p>This function retrieves the gridded data for the specified glacier using its RGI identifier. It then applies a temperature gradient to the climate data based on the glacier&#39;s topography. Finally, it calculates the long-term average temperatures by grouping the temperature data by year and computing the mean for each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L437-L455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_raw_climate_data-Tuple{String}-api"><a class="docstring-binding" href="#Sleipnir.get_raw_climate_data-Tuple{String}-api"><code>Sleipnir.get_raw_climate_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_raw_climate_data(rgi_path::String) -&gt; RasterStack</code></pre><p>Load raw climate data from a specified path.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_path::String</code>: The file path to the directory containing the climate data file.</li></ul><p><strong>Returns</strong></p><ul><li><code>RasterStack</code>: A <code>RasterStack</code> object containing the climate data from the specified file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L173-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.get_result_id_from_rgi-Union{Tuple{SIM}, Tuple{I}, Tuple{I, SIM}} where {I&lt;:Integer, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#Sleipnir.get_result_id_from_rgi-Union{Tuple{SIM}, Tuple{I}, Tuple{I, SIM}} where {I&lt;:Integer, SIM&lt;:Simulation}-api"><code>Sleipnir.get_result_id_from_rgi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_result_id_from_rgi(glacier_id::I, simulation::SIM) where {I &lt;: Integer, SIM &lt;: Simulation}</code></pre><p>Extract results of specific simulation from the <code>Simulation</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>glacier_id::I</code>: Numerical ID of glacier used to generate simulation.</li><li><code>simulation::SIM</code>`: The simulation object containing the parameters and results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_utils.jl#L181-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.glacierName-Tuple{String}-api"><a class="docstring-binding" href="#Sleipnir.glacierName-Tuple{String}-api"><code>Sleipnir.glacierName</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">glacierName(rgi_id::String)
glacierName(rgi_ids::Vector{String})</code></pre><p>Returns the name(s) of one or multiple glaciers based the given RGI ID(s). It uses the <code>rgi62_stats.csv</code> file from OGGM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L520-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.grid-Union{Tuple{FileArray}, Tuple{VM}, Tuple{F}, Tuple{G}, Tuple{G, Vector{F}, Vector{F}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Nothing, BitMatrix}, VM}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping, FileArray&lt;:Rasters.FileArray}-api"><a class="docstring-binding" href="#Sleipnir.grid-Union{Tuple{FileArray}, Tuple{VM}, Tuple{F}, Tuple{G}, Tuple{G, Vector{F}, Vector{F}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Nothing, BitMatrix}, VM}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping, FileArray&lt;:Rasters.FileArray}-api"><code>Sleipnir.grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grid(
    glacier::G,
    latitudes::Vector{F},
    longitudes::Vector{F},
    vx::Union{FileArray, Array{Union{Missing, F}, 3}},
    vy::Union{FileArray, Array{Union{Missing, F}, 3}},
    mapping::VM
) where {
    G &lt;: AbstractGlacier,
    F &lt;: AbstractFloat,
    VM &lt;: VelocityMapping,
    FileArray &lt;: Rasters.FileArray
}</code></pre><p>Grid velocity data onto the glacier grid following the prescribed mapping. This function maps the 3 dimensional surface velocities (x, y and t) to the glacier grid. The provided surface velocities can be a <code>Rasters.FileArray</code> which happens when the <code>RasterStack</code> is instantiated in lazy mode. In this situation, only the smallest cube that contains all the needed data to construct the mapping is read from disk. The returned velocity variables have shape <code>(nTimes, nx, ny)</code> where <code>nTimes</code> is the number of time steps and <code>(nx, ny)</code> is the size of the glacier grid.</p><p>Arguments:</p><ul><li><code>glacier::G</code>: Glacier instance which determines the glacier on which the velocities are projected onto.</li><li><code>latitudes::Vector{F}</code>: Vector of latitude values of the original surface velocity grid.</li><li><code>longitudes::Vector{F}</code>: Vector of longitude values of the original surface velocity grid.</li><li><code>vx::Union{FileArray, Array{Union{Missing, F}, 3}}</code>: X component of the original surface velocities. It can be either a <code>Rasters.FileArray</code> if the datacube is read in lazy mode, or a plain 3 dimensional array.</li><li><code>vy::Union{FileArray, Array{Union{Missing, F}, 3}}</code>: Y component of the original surface velocities. It can be either a <code>Rasters.FileArray</code> if the datacube is read in lazy mode, or a plain 3 dimensional array.</li><li><code>mapping::VM</code>: Mapping to use.</li></ul><p>Returns:</p><ul><li><code>xG</code>: A vector that gives the x coordinates of the glacier grid.</li><li><code>yG</code>: A vector that gives the y coordinates of the glacier grid.</li><li><code>vxG</code>: A 3 dimensional array of the x component of the velocity gridded onto the glacier grid.</li><li><code>vyG</code>: A 3 dimensional array of the y component of the velocity gridded onto the glacier grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L288-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}-api"><a class="docstring-binding" href="#Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}-api"><code>Sleipnir.initialize_glacier</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_glacier(rgi_id::String, parameters::Parameters; smoothing=false)</code></pre><p>Initialize a glacier with the given RGI ID and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) ID of the glacier.</li><li><code>parameters::Parameters</code>: A struct containing various parameters required for initialization.</li><li><code>smoothing::Bool</code>: Optional. If <code>true</code>, apply smoothing to the initial topography. Default is <code>false</code>.</li><li><code>masking::Union{Int, Nothing, Matrix}</code>: Type of mask applied to the glacier to determine regions with no ice.</li><li><code>velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}</code>: A dictionary that provides for each RGI ID either the path to the datacube or the <code>RasterStack</code> with velocity data.</li></ul><p><strong>Returns</strong></p><ul><li><code>glacier</code>: An initialized glacier object containing the initial topography and climate data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L126-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}-api"><a class="docstring-binding" href="#Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}-api"><code>Sleipnir.initialize_glaciers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_glaciers(
    rgi_ids::Vector{String},
    params::Parameters;
    velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}=Dict(),
)</code></pre><p>Initialize glaciers based on provided RGI IDs and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_ids::Vector{String}</code>: A vector of RGI IDs representing the glaciers to be initialized.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li><li><code>velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}</code>: A dictionary that provides for each RGI ID either the path to the datacube or the <code>RasterStack</code> with velocity data.</li></ul><p><strong>Returns</strong></p><ul><li><code>glaciers::Vector{Glacier2D}</code>: A vector of initialized <code>Glacier2D</code> objects.</li></ul><p><strong>Description</strong></p><p>This function performs the following steps:</p><ol><li>Generates a file for missing glaciers if it does not already exist.</li><li>Filters out missing glaciers from the provided RGI IDs.</li><li>Generates raw climate data for the glaciers if necessary.</li><li>Initializes the glaciers using the provided RGI IDs and parameters.</li><li>If <code>use_glathida_data</code> is enabled in the simulation parameters, assigns GlaThiDa data to the glaciers.</li></ol><p><strong>Errors</strong></p><ul><li>Throws an error if none of the provided RGI IDs have GlaThiDa data.</li></ul><p><strong>Warnings</strong></p><ul><li>Issues a warning if not all glaciers have GlaThiDa data available.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># We declare a list of glaciers to be initialized with their RGI IDs
rgi_ids = [&quot;RGI60-11.03638&quot;, &quot;RGI60-11.01450&quot;, &quot;RGI60-11.02346&quot;, &quot;RGI60-08.00203&quot;]
# We initialize those glaciers based on the RGI IDs and the parameters we previously specified
glaciers = initialize_glaciers(rgi_ids, params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L9-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.initialize_surfacevelocitydata-Union{Tuple{Union{String, Rasters.RasterStack}}, Tuple{VM}, Tuple{G}} where {G&lt;:AbstractGlacier, VM&lt;:Sleipnir.VelocityMapping}-api"><a class="docstring-binding" href="#Sleipnir.initialize_surfacevelocitydata-Union{Tuple{Union{String, Rasters.RasterStack}}, Tuple{VM}, Tuple{G}} where {G&lt;:AbstractGlacier, VM&lt;:Sleipnir.VelocityMapping}-api"><code>Sleipnir.initialize_surfacevelocitydata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_surfacevelocitydata(
    raster::Union{String, &lt;: RasterStack};
    glacier::Union{G, Nothing}=nothing,
    mapping::VM=MeanDateVelocityMapping(),
    compute_vabs_error::Bool=true,
    flag::Union{String, &lt;: RasterStack, Nothing} = nothing
) where {G &lt;: AbstractGlacier, VM &lt;: VelocityMapping}</code></pre><p>Initialize SurfaceVelocityData from Rabatel et. al (2023).</p><p>Arguments:</p><ul><li><code>raster::Union{String, RasterStack}</code>: RasterStack or path of the netCDF file with surface velocity data.</li><li><code>glacier::Union{G, Nothing}</code>: Glacier associated to the surface velocity datacube. When provided, the surface velocity data are gridded on the glacier grid using the <code>mapping</code>.</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of the velocity product datacube to the glacier grid.</li><li><code>compute_vabs_error::Bool</code>: Whether to compute the absolute error uncertainty.</li><li><code>flag::Union{String, &lt;: RasterStack, Nothing}</code>: Option to provide a <code>RasterStack</code> containing a <code>fmask</code> raster and which provides an indicator of whether each pixel of the ice surface velocity data is considered as reliable or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L3-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.initialize_surfacevelocitydata_mask-api"><a class="docstring-binding" href="#Sleipnir.initialize_surfacevelocitydata_mask-api"><code>Sleipnir.initialize_surfacevelocitydata_mask</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_surfacevelocitydata_mask(data::RasterStack, flag::Union{String, &lt;:RasterStack, Nothing}=nothing)</code></pre><p>Create a mask for a glacier surface velocity dataset by subsetting and aligning a flag raster to the spatial domain of <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::RasterStack</code>: The glacier datacube or surface velocity dataset.</li><li><code>flag::Union{String, RasterStack, Nothing}</code>: Type of flag to be applied</li></ul><p><strong>Description</strong></p><p>This function extracts the portion of the flag raster that spatially overlaps with the glacier domain defined by <code>data</code>. Because the flag raster is centered on pixel centers, its bounding box is shifted by half a grid step when subsetting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L215-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.is_in_glacier-Union{Tuple{F}, Tuple{I}, Tuple{Matrix{F}, I}} where {I&lt;:Integer, F&lt;:AbstractFloat}-api"><a class="docstring-binding" href="#Sleipnir.is_in_glacier-Union{Tuple{F}, Tuple{I}, Tuple{Matrix{F}, I}} where {I&lt;:Integer, F&lt;:AbstractFloat}-api"><code>Sleipnir.is_in_glacier</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_in_glacier(A::Matrix{F}, distance::I) where {I &lt;: Integer, F &lt;: AbstractFloat}</code></pre><p>Return a matrix with booleans indicating if a given pixel is at distance at least <code>distance</code> in the set of non zero values of the matrix. This usually allows discarding the border pixels of a glacier. A positive value of <code>distance</code><code>indicates a measurement from inside the glacier, while a negative</code>distance`` indicates one from outside.</p><p>Arguments:</p><ul><li><code>A::Matrix{F}</code>: Matrix from which to compute the matrix of booleans.</li><li><code>distance::I</code>: Distance to the border, computed as the number of pixels we need to move from within the glacier to find a pixel with value zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L740-L753">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.local_distance-Union{Tuple{F}, Tuple{CoordRefSystems.TransverseMercator, Union{VecOrMat{F}, F}, Union{VecOrMat{F}, F}}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.local_distance-Union{Tuple{F}, Tuple{CoordRefSystems.TransverseMercator, Union{VecOrMat{F}, F}, Union{VecOrMat{F}, F}}} where F&lt;:AbstractFloat-api"><code>Sleipnir.local_distance</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute distance between one point in the format of a <code>TransverseMercator</code> point and a set of points defined through the coordinates <code>x</code> and <code>y</code> in meters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L484-L486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.mapVelocity-Tuple{MeanDateVelocityMapping, SurfaceVelocityData, AbstractFloat}-api"><a class="docstring-binding" href="#Sleipnir.mapVelocity-Tuple{MeanDateVelocityMapping, SurfaceVelocityData, AbstractFloat}-api"><code>Sleipnir.mapVelocity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mapVelocity(
    velocityMapping::MeanDateVelocityMapping,
    velocityData::SurfaceVelocityData,
    t::AbstractFloat,
)</code></pre><p>Retrieve the reference ice surface velocity for a given time step. This mapping uses the nearest snap shot available within a time window whose length is controlled by <code>velocityMapping.thresDate</code>. If no snapshot is found in the time window of length 2*velocityMapping.thresDate, the returned ice velocity components are empty matrices and the returned boolean flag <code>useVel</code> is set to false.</p><p><strong>Arguments:</strong></p><ul><li><code>velocityMapping::MeanDateVelocityMapping</code>: Mapping to map the reference ice velocity to a target time step <code>t</code>.</li><li><code>velocityData::SurfaceVelocityData</code>: Surface velocity data. This is usually an attribute of a glacier.</li><li><code>t::AbstractFloat</code>: Current time step.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vx_ref</code>: Matrix of the x-component of the ice surface velocity.</li><li><code>Vy_ref</code>: Matrix of the y-component of the ice surface velocity.</li><li><code>V_ref</code>: Matrix of the ice surface velocity magnitude.</li><li><code>useVel</code>: Boolean indicating whether the returned ice surface velocity can be used or not. The value of this boolean depends on the success of the ice surface velocity mapping at the current time step <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityMapping_utils.jl#L3-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.max_or_empty-Tuple{Array}-api"><a class="docstring-binding" href="#Sleipnir.max_or_empty-Tuple{Array}-api"><code>Sleipnir.max_or_empty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_or_empty(A::Array)</code></pre><p>Return maximum value for non-empty arrays. This is just required to compute the error in the absolute velocity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L278-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.parse_proj-Tuple{String}-api"><a class="docstring-binding" href="#Sleipnir.parse_proj-Tuple{String}-api"><code>Sleipnir.parse_proj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_proj(proj::String)</code></pre><p>Parses the string containing the information of the projection to filter for important information &quot;+proj=tmerc +lat<em>0=0 +lon</em>0=6.985 +k=0.9996 +x<em>0=0 +y</em>0=0 +datum=WGS84 +units=m +no_defs&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L616-L621">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.partial_year-Tuple{Any}-api"><a class="docstring-binding" href="#Sleipnir.partial_year-Tuple{Any}-api"><code>Sleipnir.partial_year</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">partial_year(float::Float64) -&gt; Float64</code></pre><p>Calculate the partial year value based on the given floating-point number.</p><p><strong>Arguments</strong></p><ul><li><code>float::Float64</code>: A floating-point number representing the fraction of the year.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The calculated partial year value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L422-L434">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.partial_year-Tuple{Type{&lt;:Dates.Period}, AbstractFloat}-api"><a class="docstring-binding" href="#Sleipnir.partial_year-Tuple{Type{&lt;:Dates.Period}, AbstractFloat}-api"><code>Sleipnir.partial_year</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">partial_year(period::Type{&lt;:Period}, float)</code></pre><p>Calculate a partial year date based on a floating-point year value.</p><p><strong>Arguments</strong></p><ul><li><code>period::Type{&lt;:Period}</code>: The type of period to use (e.g., <code>Month</code>, <code>Day</code>).</li><li><code>float::Float64</code>: The floating-point year value.</li></ul><p><strong>Returns</strong></p><ul><li><code>Date</code>: The calculated date corresponding to the partial year.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L397-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_bias-Tuple{Any, Any}-api"><a class="docstring-binding" href="#Sleipnir.plot_bias-Tuple{Any, Any}-api"><code>Sleipnir.plot_bias</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_bias(
    results,
    variables;
    treshold = [0, 0],
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
)</code></pre><p>Plot the bias of the glacier integrated volume over the specified time span.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variables to be plotted.</li><li><code>title_mapping::Dict{Symbol, String}</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan::Tuple{Float64, Float64}</code>: A tuple representing the start and end time for the simulation.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier integrated volume bias.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L680-L701">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier-Tuple{Sleipnir.Results, String, Vector{Symbol}}-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier-Tuple{Sleipnir.Results, String, Vector{Symbol}}-api"><code>Sleipnir.plot_glacier</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -&gt; Figure</code></pre><p>Generate various types of plots for glacier data.</p><p><strong>Arguments</strong></p><ul><li><p><code>results::Results</code>: The results object containing the data to be plotted.</p></li><li><p><code>plot_type::String</code>: Type of plot to generate. Options are:</p><ul><li>&quot;heatmaps&quot;: Heatmaps for glacier variables like <code>:H</code>, <code>:H₀</code>, <code>:S</code>, <code>:B</code>, <code>:V</code>, <code>:Vx</code>, <code>:Vy</code>, <code>:V_ref</code>.</li><li>&quot;evolution difference&quot;: Temporal difference metrics (between start and end) for a variable, with optional metrics like &quot;hist&quot; (histogram) and &quot;difference&quot;.</li><li>&quot;evolution statistics&quot;: Temporal statistical metrics for a variable, with optional metrics like &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;.</li><li>&quot;integrated volume&quot;: Temporal evolution of the integrated ice volume for a variable.</li><li>&quot;bias&quot;: Scatter plot to visualize the bias between two variables.</li></ul></li><li><p><code>variables::Vector{Symbol}</code>: Variables to be plotted, e.g., <code>:H</code>.</p></li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics</code>: Metrics to visualize, e.g., <code>[&quot;average&quot;]</code> for statistics, <code>[&quot;difference&quot;]</code> for difference.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size for heatmaps.</li><li><code>threshold::Vector{F}</code>: Threshold values for filtering data in bias plots.</li><li><code>figsize::Tuple{Int64, Int64}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Figure</code> object containing the desired visualization.</li></ul><p><strong>Notes</strong></p><ul><li>Ensure the <code>variables</code> and <code>kwargs</code> match the requirements of the specified <code>plot_type</code>.</li><li>The function routes requests to specific plotting functions based on <code>plot_type</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L761-L795">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Sleipnir.Results, Vector{Symbol}, Any}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Sleipnir.Results, Vector{Symbol}, Any}} where F&lt;:AbstractFloat-api"><code>Sleipnir.plot_glacier_difference_evolution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier_difference_evolution(
    results::Results,
    variables::Vector{Symbol},
    title_mapping;
    tspan::Tuple{F,F}=results.tspan,
    metrics::Vector{String}=&quot;difference&quot;,
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
) where {F&lt;:AbstractFloat}</code></pre><p>Plot the evolution of the difference in a glacier variable over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The simulation results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variable to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan::Tuple{F,F}</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics::Vector{String}</code>: Metrics to visualize, e.g., <code>[&quot;difference&quot;]</code>.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier difference evolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L345-L369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier_heatmaps-Tuple{Sleipnir.Results, Vector{Symbol}, Dict}-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier_heatmaps-Tuple{Sleipnir.Results, Vector{Symbol}, Dict}-api"><code>Sleipnir.plot_glacier_heatmaps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier_heatmaps(
    results::Results,
    variables::Vector{Symbol},
    title_mapping::Dict;
    scale_text_size::Union{Nothing,Float64}=nothing,
    timeIdx::Union{Nothing,Int64}=nothing,
    figsize::Union{Nothing, Tuple{Int64, Int64}} = nothing,
    plotContour::Bool=false,
) -&gt; Figure</code></pre><p>Plot heatmaps for glacier variables.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping::Dict</code>: A dictionary mapping variable names to their titles and colormaps.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size.</li><li><code>timeIdx::Union{Nothing,Int64}</code>:: Optional argument to select the index at which data should be plotted when dealing with vector of matrix. Default is nothing which selects the last element available.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li><li><code>plotContour::Bool</code>: Whether to add a contour plot representing the glacier borders at the beginning of the simulation on top of each of the figures. Default is false.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier heatmaps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L45-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}-api"><code>Sleipnir.plot_glacier_integrated_volume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier_integrated_volume(
    results,
    variables,
    title_mapping;
    tspan,
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
)</code></pre><p>Plot the integrated volume of a glacier variable over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variable to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier integrated volume.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L608-L630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier_quivers-Tuple{Sleipnir.Results, Vector{Symbol}, Dict}-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier_quivers-Tuple{Sleipnir.Results, Vector{Symbol}, Dict}-api"><code>Sleipnir.plot_glacier_quivers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier_quivers(
    results::Results,
    variables::Vector{Symbol},
    title_mapping::Dict;
    timeIdx::Union{Nothing,Int64} = nothing,
    figsize::Union{Nothing, Tuple{Int64, Int64}} = nothing,
    lengthscale::Float64 = 0.00001,
    tiplength::Float64 = 0.5,
) -&gt; Figure</code></pre><p>Plot quivers for glacier variables.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping::Dict</code>: A dictionary mapping variable names to their titles and colormaps.</li><li><code>timeIdx::Union{Nothing,Int64}</code>:: Optional argument to select the index at which data should be plotted when dealing with vector of matrix. Default is nothing which selects the last element available.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li><li><code>lengthscale::Float64</code>: Lengthscale of the arrows in the quiver plot.</li><li><code>tiplength::Float64</code>: Length of the arrow in the quiver plot.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier quivers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L236-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier_statistics_evolution-Tuple{Sleipnir.Results, Vector{Symbol}, Any}-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier_statistics_evolution-Tuple{Sleipnir.Results, Vector{Symbol}, Any}-api"><code>Sleipnir.plot_glacier_statistics_evolution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier_statistics_evolution(
    results::Results,
    variables::Vector{Symbol},
    title_mapping;
    metrics=&quot;median&quot;,
    tspan,
    threshold=0.5,
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
)</code></pre><p>Plot the evolution of statistics for multiple glacier variables over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The simulation results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>metrics</code>: Metrics to visualize, e.g., &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;. Default is &quot;median&quot;.</li><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>threshold</code>: A threshold value to filter the data. Default is 0.5.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier statistics evolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L498-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_glacier_vid-Tuple{String, Sleipnir.Results, Glacier2D, Any, Any, String}-api"><a class="docstring-binding" href="#Sleipnir.plot_glacier_vid-Tuple{String, Sleipnir.Results, Glacier2D, Any, Any, String}-api"><code>Sleipnir.plot_glacier_vid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_glacier_vid(
    plot_type::String,
    results::Results,
    glacier::Glacier2D,
    tspan,
    step,
    pathVideo::String;
    framerate::Int=24,
    baseTitle::String=&quot;&quot;
)</code></pre><p>Generate various types of videos for glacier data. For now only the evolution of the glacier ice thickness is supported. More types of visualizations will be added in the future.</p><p><strong>Arguments</strong></p><ul><li><p><code>plot_type</code>: Type of plot to generate. Options are:</p><ul><li>&quot;thickness&quot;: Heatmap of the glacier thickness.</li></ul></li><li><p><code>results</code>: A result object containing the simulation results including ice thickness over time.</p></li><li><p><code>glacier</code>: A glacier instance.</p></li><li><p><code>tspan</code>: The simulation time span.</p></li><li><p><code>step</code>: Time step to use to retrieve the results and generate the video.</p></li><li><p><code>pathVideo</code>: Path of the mp4 file to generate.</p></li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>framerate</code>: The framerate to use for the video generation.</li><li><code>baseTitle</code>: The prefix to use in the title of the frames. In each frame it is concatenated with the value of the year in the form &quot; (t=XXXX)&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_video_utils.jl#L72-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.plot_gridded_data-Union{Tuple{F}, Tuple{Union{Array{Matrix{F}, 1}, Matrix{F}}, Sleipnir.Results}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.plot_gridded_data-Union{Tuple{F}, Tuple{Union{Array{Matrix{F}, 1}, Matrix{F}}, Sleipnir.Results}} where F&lt;:AbstractFloat-api"><code>Sleipnir.plot_gridded_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_gridded_data(
    gridded_data::Union{Vector{Matrix{F}}, Matrix{F}},
    results::Results;
    scale_text_size::Union{Nothing,Float64}=nothing,
    timeIdx::Union{Nothing,Int64}=nothing,
    figsize::Union{Nothing, Tuple{Int64, Int64}} = nothing,
    plotContour::Bool=false,
    colormap = :cool,
    logPlot = false,
) where {F &lt;: AbstractFloat}</code></pre><p>Plot a gridded matrix (or a time series of matrices) as a heatmap using metadata from results.</p><p><strong>Arguments</strong></p><ul><li><code>gridded_data::Union{Vector{Matrix{F}}, Matrix{F}}</code>: Single snapshot or time series (defaults to last timestep).</li><li><code>results::Results</code>: Supplies lon, lat, x, y, rgi_id, Δx and H (mask).</li><li><code>scale_text_size</code>, <code>figsize</code>, <code>colormap</code>: Optional plotting params.</li><li><code>timeIdx::Union{Nothing,Int64}</code>: Select timestep when <code>gridded_data</code> is a vector.</li><li><code>plotContour::Bool</code>: overlay glacier-mask contour from results.H.</li><li><code>logPlot::Bool</code>: Use log10 colorscale (positive non-NaN values determine range).</li></ul><p><strong>Behavior</strong></p><ul><li>Masks out cells where <code>results.H[begin] .&lt;= 0</code> (set to NaN).</li><li>Adds colorbar, central lon/lat tick, and a Δx-based scale bar in km.</li><li>If <code>plotContour</code>, draws mask boundary lines.</li><li>Returns a <code>CairoMakie.Figure</code>.</li></ul><p><strong>Errors</strong></p><ul><li>Asserts gridded_data is non-empty and timeIdx (if provided) is in range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L834-L867">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.precompute_all_VJPs_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api"><a class="docstring-binding" href="#Sleipnir.precompute_all_VJPs_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api"><code>Sleipnir.precompute_all_VJPs_laws!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">precompute_all_VJPs_laws!(model::AbstractModel, cache, simulation, glacier_idx, t, θ)</code></pre><p>This function is a placeholder and must be implemented for your custom model type.</p><p>It is intended to precompute the VJPs for all the laws that are used in a model. By default, calling this function will throw an error to indicate that the user should provide their own implementation tailored to their model.</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractModel</code>: The model instance.</li><li><code>cache</code>: The cache object storing state variables.</li><li><code>simulation</code>: The simulation context.</li><li><code>glacier_idx</code>: Index identifying the glacier.</li><li><code>t</code>: The current simulation time.</li><li><code>θ</code>: The parameter vector.</li></ul><p><strong>Throws</strong></p><ul><li>Always throws an error: <code>&quot;This function should not be called. Implement precompute_all_VJPs_laws! for your own model.&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L109-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.prepare_vjp_law-Tuple{Any, AbstractLaw, Any, Any, Any}-api"><a class="docstring-binding" href="#Sleipnir.prepare_vjp_law-Tuple{Any, AbstractLaw, Any, Any, Any}-api"><code>Sleipnir.prepare_vjp_law</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prepare_vjp_law(simulation, law::AbstractLaw, law_cache, θ, glacier_idx)</code></pre><p>Function used to prepare the VJPs at the initialization of the model cache. It is used for example to compile VJPs of the laws to be differentiated using DifferentiationInterface.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.random_spatially_coherent_mask-Tuple{Integer, Integer}-api"><a class="docstring-binding" href="#Sleipnir.random_spatially_coherent_mask-Tuple{Integer, Integer}-api"><code>Sleipnir.random_spatially_coherent_mask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_spatially_coherent_mask(h::Integer, w::Integer; sigma::Real=1.0, threshold::Real=0.0) -&gt; BitMatrix
random_spatially_coherent_mask(mask::BitMatrix; sigma::Real=1.0, threshold::Real=0.0) -&gt; BitMatrix</code></pre><p>Generate a random binary mask with <strong>spatially correlated patches</strong> rather than pixel-wise independent noise. This is done by drawing white noise, applying a Gaussian low-pass filter in the frequency domain, and thresholding the result.</p><p><strong>Arguments</strong></p><ul><li><code>h::Integer</code>, <code>w::Integer</code>: Height and width of the mask.</li><li><code>mask::BitMatrix</code>: An existing binary mask. The generated spatially coherent mask will be applied elementwise (<code>.&amp;</code>) to this mask.</li><li><code>sigma::Real=1.0</code>: Controls the spatial correlation length. Larger values produce smoother, larger patches.</li><li><code>threshold::Real=0.0</code>: Threshold applied to the filtered noise. Higher values result in sparser masks. Statistically, setting the threshold to zero results in a mask with half pixels to true.</li></ul><p><strong>Returns</strong></p><p>A <code>BitMatrix</code> of size <code>(h, w)</code> containing <code>true</code> in patchy regions and <code>false</code> elsewhere.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Generate a new 256×256 patchy mask
mask = random_spatially_coherent_mask(256, 256; sigma = 8.0, threshold = 0.0)

# Apply patchy masking to an existing mask
base = trues(128, 128)
patchy = random_spatially_coherent_mask(base; sigma = 5.0, threshold = 0.3)    # 1) white noise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L416-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.ratio_max-Tuple{Any, Any}-api"><a class="docstring-binding" href="#Sleipnir.ratio_max-Tuple{Any, Any}-api"><code>Sleipnir.ratio_max</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ratio_max(v, vabs)</code></pre><p>Compute the maximum ratio between v and vabs at points where the value of vabs is not a NaN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/SurfaceVelocityData_utils.jl#L267-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.retrieve_simulation-Tuple{Any}-api"><a class="docstring-binding" href="#Sleipnir.retrieve_simulation-Tuple{Any}-api"><code>Sleipnir.retrieve_simulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">retrieve_simulation(p)
retrieve_simulation(p::Container)</code></pre><p>Function that retrieves the <code>simulation</code> object from <code>integrator.p</code> when called from a callback. If <code>p</code> is a subtype of <code>Container</code>, then <code>p.simulation</code> is returned, otherwise it returns <code>p</code>. It is for internal use only and it isn&#39;t exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/AbstractLaw.jl#L77-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.reverseForHeatmap-Union{Tuple{F}, Tuple{Matrix{F}, Vector{F}, Vector{F}}} where F&lt;:AbstractFloat-api"><a class="docstring-binding" href="#Sleipnir.reverseForHeatmap-Union{Tuple{F}, Tuple{Matrix{F}, Vector{F}, Vector{F}}} where F&lt;:AbstractFloat-api"><code>Sleipnir.reverseForHeatmap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reverseForHeatmap(
    inp::Matrix{F},
    x::Vector{F},
    y::Vector{F}
) where {F &lt;: AbstractFloat}</code></pre><p>Out-of-place reverse of a matrix based on the values of the x and y axes. This function corrects the orientation so that the heatmap is displayed correctly.</p><p><strong>Arguments</strong></p><ul><li><code>inp::Matrix{F}</code>: The matrix to reverse.</li><li><code>x::Vector{F}</code>: Values of the x axis.</li><li><code>y::Vector{F}</code>: Values of the y axis.</li></ul><p><strong>Returns</strong></p><ul><li>Out-of-place copy of inp that has been reversed if needed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_plotting_utils.jl#L8-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Sleipnir.Results{F, I}, 1}, SIM}} where {F&lt;:AbstractFloat, I&lt;:Integer, SIM&lt;:Simulation}-api"><a class="docstring-binding" href="#Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Sleipnir.Results{F, I}, 1}, SIM}} where {F&lt;:AbstractFloat, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>Sleipnir.save_results_file!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_results_file!(results_list::Vector{Results{F, I}}, simulation::SIM; path::Union{String,Nothing}=nothing) where {F &lt;: AbstractFloat, I &lt;: Integer, SIM &lt;: Simulation}</code></pre><p>Save the results of a simulation to a file.</p><p><strong>Arguments</strong></p><ul><li><code>results_list::Vector{Results{F, I}}</code>: A vector containing the results of the simulation.</li><li><code>simulation::SIM</code>: The simulation object containing the parameters and results.</li><li><code>path::Union{String,Nothing}</code>: Optional. The path where the results file will be saved. If not provided, a default path will be used.</li></ul><p><strong>Description</strong></p><p>This function saves the results of a simulation to a file in JLD2 format. If the <code>path</code> argument is not provided, the function will create a default path based on the current project directory. The results are saved in a file named <code>prediction_&lt;nglaciers&gt;glaciers_&lt;tspan&gt;.jld2</code>, where <code>&lt;nglaciers&gt;</code> is the number of glaciers in the simulation and <code>&lt;tspan&gt;</code> is the simulation time span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/results/results_utils.jl#L143-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.smooth!-Tuple{Any}-api"><a class="docstring-binding" href="#Sleipnir.smooth!-Tuple{Any}-api"><code>Sleipnir.smooth!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smooth!(A)</code></pre><p>Smooths the interior of a 2D array <code>A</code> using a simple averaging method. The function modifies the array <code>A</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>: A 2D array to be smoothed.</li></ul><p><strong>Details</strong></p><p>The function updates the interior elements of <code>A</code> (excluding the boundary elements) by adding a weighted average of the second differences along both dimensions. The boundary elements are then set to the values of their nearest interior neighbors to maintain the boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/glacier/glacier2D_utils.jl#L709-L721">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.stop_condition_tstops-Tuple{Any, AbstractFloat, Any, Vector{&lt;:AbstractFloat}}-api"><a class="docstring-binding" href="#Sleipnir.stop_condition_tstops-Tuple{Any, AbstractFloat, Any, Vector{&lt;:AbstractFloat}}-api"><code>Sleipnir.stop_condition_tstops</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stop_condition_tstops(u, t, integrator, tstops)</code></pre><p>Check if the current time <code>t</code> is in the list of stop times <code>tstops</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: The current state of the system (not used in this function).</li><li><code>t::AbstractFloat</code>: The current time.</li><li><code>integrator</code>: The integrator object (not used in this function).</li><li><code>tstops::Vector{&lt;: AbstractFloat}</code>: A collection of times at which the integration should stop.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if <code>t</code> is in <code>tstops</code>, otherwise <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/simulations/simulation_utils.jl#L2-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.tdata-Tuple{Nothing}-api"><a class="docstring-binding" href="#Sleipnir.tdata-Tuple{Nothing}-api"><code>Sleipnir.tdata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tdata(data::Nothing)
tdata(data::ThicknessData)
tdata(data::Nothing, mapping::MeanDateVelocityMapping)
tdata(data::SurfaceVelocityData, mapping::MeanDateVelocityMapping)</code></pre><p>Retrieve the time steps at which data is available for ice thickness and surface velocity data. If the provided data is <code>nothing</code>, returns an empty vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/data/Data.jl#L14-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.trim_period-Tuple{Any, Any}-api"><a class="docstring-binding" href="#Sleipnir.trim_period-Tuple{Any, Any}-api"><code>Sleipnir.trim_period</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trim_period(period, climate)</code></pre><p>Adjusts the given <code>period</code> to fit within the bounds of the <code>climate</code> data, ensuring it aligns with hydrological years.</p><p><strong>Arguments</strong></p><ul><li><code>period::UnitRange{Date}</code>: The initial date range to be trimmed.</li><li><code>climate::AbstractArray</code>: The climate data array, which should have a time dimension <code>Ti</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>UnitRange{Date}</code>: The adjusted date range that fits within the climate data&#39;s time bounds.</li></ul><p><strong>Details</strong></p><ul><li>If the start of the climate data is later than the start of the period, the period is adjusted to start from October 1st of the year of the climate data&#39;s start.</li><li>If the end of the climate data is earlier than the end of the period, the period is adjusted to end on September 30th of the year of the climate data&#39;s end.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/glaciers/climate/climate2D_utils.jl#L365-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.∂law∂inp!-Tuple{}-api"><a class="docstring-binding" href="#Sleipnir.∂law∂inp!-Tuple{}-api"><code>Sleipnir.∂law∂inp!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂law∂inp!()</code></pre><p>This function serves as a placeholder and should be replaced by other implementations in ODINN. This implementation throws an error. It is for internal use only and is not exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L41-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Sleipnir.∂law∂θ!-Tuple{}-api"><a class="docstring-binding" href="#Sleipnir.∂law∂θ!-Tuple{}-api"><code>Sleipnir.∂law∂θ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∂law∂θ!()</code></pre><p>This function serves as a placeholder and should be replaced by other implementations in ODINN. This implementation throws an error. It is for internal use only and is not exposed to the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.12.6/src/laws/VJP.jl#L32-L38">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../results_plotting/">« Results and plotting</a><a class="docs-footer-nextpage" href="../inversions/">Inversion types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 3 December 2025 12:01">Wednesday 3 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
