<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functional inversion · ODINN.jl</title><meta name="title" content="Functional inversion · ODINN.jl"/><meta property="og:title" content="Functional inversion · ODINN.jl"/><meta property="twitter:title" content="Functional inversion · ODINN.jl"/><meta name="description" content="Documentation for ODINN.jl."/><meta property="og:description" content="Documentation for ODINN.jl."/><meta property="twitter:description" content="Documentation for ODINN.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../forward_simulation/">Forward simulation</a></li><li><a class="tocitem" href="../classical_inversion/">Classical inversion</a></li><li class="is-active"><a class="tocitem" href>Functional inversion</a><ul class="internal"><li><a class="tocitem" href="#Running-the-whole-code"><span>Running the whole code</span></a></li><li><a class="tocitem" href="#Step-by-step-explanation-of-the-tutorial"><span>Step-by-step explanation of the tutorial</span></a></li></ul></li><li><a class="tocitem" href="../laws/">Laws</a></li><li><a class="tocitem" href="../input_laws/">Laws inputs</a></li><li><a class="tocitem" href="../vjp_laws/">Laws VJP customization</a></li></ul></li><li><span class="tocitem">How to use ODINN</span><ul><li><a class="tocitem" href="../parameters/">Parameters</a></li><li><a class="tocitem" href="../glaciers/">Glaciers</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../results_plotting/">Results and plotting</a></li><li><a class="tocitem" href="../api/">API</a></li></ul></li><li><span class="tocitem">Inversions</span><ul><li><a class="tocitem" href="../inversions/">Inversion types</a></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity analysis</a></li></ul></li><li><span class="tocitem">Community</span><ul><li><a class="tocitem" href="../contribute/">How to contribute</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of conduct</a></li></ul></li><li><a class="tocitem" href="../changes_plans/">Ongoing changes and future plans</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Functional inversion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functional inversion</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/functional_inversion.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functional-inversion-tutorial"><a class="docs-heading-anchor" href="#Functional-inversion-tutorial">Functional inversion tutorial</a><a id="Functional-inversion-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-inversion-tutorial" title="Permalink"></a></h1><p>This tutorial provides a simple example on how to perform a functional inversion using Universal Differential Equations (UDEs) in ODINN.jl. For this, we will generate a synthetic dataset using a forward simulation, and then we will use this dataset to perform the functional inversion. The goal of this functional inversion will be to learn a synthetic law that maps <code>A</code>, i.e. the ice rigidity, to long-term changes in atmospheric surface temperature.</p><p>For more details on the functional inversion concept, please refer to the <a href="../inversions/#Functional-inversions">Functional Inversion section in the Inversion types page</a>.</p><h2 id="Running-the-whole-code"><a class="docs-heading-anchor" href="#Running-the-whole-code">Running the whole code</a><a id="Running-the-whole-code-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-whole-code" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ODINN

# Define the working directory
working_dir = joinpath(ODINN.root_dir, &quot;demos&quot;)

# We fetch the paths with the files for the available glaciers on disk
rgi_paths = get_rgi_paths()

# Ensure the working directory exists
mkpath(working_dir)

# Define the time step for the simulation output, in this case, a month.
δt = 1/12

# Define which glacier RGI IDs we want to work with
rgi_ids = [&quot;RGI60-11.03638&quot;, &quot;RGI60-11.01450&quot;, &quot;RGI60-11.02346&quot;, &quot;RGI60-07.00065&quot;]

params = Parameters(
    simulation = SimulationParameters(
        working_dir = working_dir,
        use_MB = false,
        use_velocities = true,
        tspan = (2010.0, 2015.0),
        multiprocessing = true,
        workers = 4,
        test_mode = false,
        rgi_paths = rgi_paths,
        gridScalingFactor = 4, # Downscale the glacier grid to speed-up this example
        ),
    hyper = Hyperparameters(
        batch_size = length(rgi_ids), # Set batch size equals size of the dataset
        epochs = [15,10],
        optimizer = [
            ODINN.ADAM(0.01),
            ODINN.LBFGS(
                linesearch = ODINN.LineSearches.BackTracking(iterations = 5)
            )
        ]),
    physical = PhysicalParameters(
        minA = 8e-21,
        maxA = 8e-17
        ),
    UDE = UDEparameters(
        optim_autoAD = ODINN.NoAD(),
        grad = ContinuousAdjoint(),
        optimization_method = &quot;AD+AD&quot;,
        empirical_loss_function = LossH() # Loss function based on ice thickness
        ),
    solver = Huginn.SolverParameters(
        step = 1 / 12, # Define the time step for the simulation output and for the adjoint
        progress = true
        )
)

# We define a synthetic law to generate the synthetic dataset.
# For this, we use some tabular data from Cuffey and Paterson (2010).
A_law = CuffeyPaterson(scalar = true)

model = Model(
    iceflow = SIA2Dmodel(params; A = A_law),
    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),
)

# We initialize the glaciers with all the necessary data
glaciers = initialize_glaciers(rgi_ids, params)

# Time snapshots for transient inversion
tstops = collect(2010:δt:2015)

# We generate the synthetic dataset using the forward simulation.
# This will generate a dataset with the ice thickness and surface velocities for each
# glacier at each time step. The dataset will be used to train the machine learning model.
glaciers = generate_ground_truth(glaciers, params, model, tstops)

# After this forward simulation, we restart the iceflow model to be ready for the inversions
nn_model = NeuralNetwork(params)
A_law = LawA(nn_model, params)
model = Model(
    iceflow = SIA2Dmodel(params; A = A_law),
    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),
    regressors = (; A = nn_model)
)

# We specify the type of simulation we want to perform
functional_inversion = Inversion(model, glaciers, params)

# And finally, we just run the simulation
run!(functional_inversion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">      From worker 4:	Getting raw climate data for: RGI60-07.00065
[ Info: Running forward in-place PDE ice flow model
      From worker 4:	Processing glacier RGI60-11.03638 for PDE forward simulation
      From worker 2:	Processing glacier RGI60-11.01450 for PDE forward simulation
      From worker 3:	Processing glacier RGI60-11.02346 for PDE forward simulation
      From worker 4:	Processing glacier RGI60-07.00065 for PDE forward simulation
Progress:  50%|████████████████████▌                    |  ETA: 0:00:03Progress:  75%|██████████████████████████████▊          |  ETA: 0:00:01Progress: 100%|█████████████████████████████████████████| Time: 0:00:03
[ Info: Optimizing with ADAM
[ Info: Optimizing with custom ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP} method
Iteration: [    1 /    25]     Loss:7.90137e+01
Iteration: [    2 /    25]     Loss:6.52403e+01     Improvement: -17.43 %
Iteration: [    3 /    25]     Loss:5.40509e+01     Improvement: -17.15 %
Iteration: [    4 /    25]     Loss:4.57279e+01     Improvement: -15.40 %
Iteration: [    5 /    25]     Loss:3.89663e+01     Improvement: -14.79 %
Iteration: [    6 /    25]     Loss:3.35554e+01     Improvement: -13.89 %
Iteration: [    7 /    25]     Loss:2.91507e+01     Improvement: -13.13 %
Iteration: [    8 /    25]     Loss:2.55161e+01     Improvement: -12.47 %
Iteration: [    9 /    25]     Loss:2.21683e+01     Improvement: -13.12 %
Iteration: [   10 /    25]     Loss:1.99518e+01     Improvement: -10.00 %
Iteration: [   11 /    25]     Loss:1.75260e+01     Improvement: -12.16 %
Iteration: [   12 /    25]     Loss:1.59671e+01     Improvement: -8.89 %
Iteration: [   13 /    25]     Loss:1.44823e+01     Improvement: -9.30 %
Iteration: [   14 /    25]     Loss:1.31806e+01     Improvement: -8.99 %
Iteration: [   15 /    25]     Loss:1.20103e+01     Improvement: -8.88 %
Iteration: [   16 /    25]     Loss:1.20103e+01     Improvement: 0.00 %
[ Info: Optimizing with BFGS
[ Info: Optimizing with custom ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP} method
Iteration: [   17 /    25]     Loss:1.20103e+01     Improvement: 0.00 %
Iteration: [   18 /    25]     Loss:1.08576e+01     Improvement: -9.60 %</code></pre><h2 id="Step-by-step-explanation-of-the-tutorial"><a class="docs-heading-anchor" href="#Step-by-step-explanation-of-the-tutorial">Step-by-step explanation of the tutorial</a><a id="Step-by-step-explanation-of-the-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Step-by-step-explanation-of-the-tutorial" title="Permalink"></a></h2><p>Here we will cover in detail each one of the steps that lead us to run the <code>Inversion</code> from the previous example. The goal of this simple example is to learn a mapping of a law for <code>A</code>, the creep coefficient of ice. Mathematically, we make <code>A</code> depends on the long term air temperature <code>T</code> through a neural network <code>A=NN(T, θ)</code> and we optimize <code>θ</code> so that the generated solution matches some ice thickness reference. This reference is generated using the relation of the book from Cuffey and Paterson (2010) [<a href="../references/#cuffey_physics_2010">2</a>].</p><h3 id="Step-1:-Parameter-and-glacier-initialization"><a class="docs-heading-anchor" href="#Step-1:-Parameter-and-glacier-initialization">Step 1: Parameter and glacier initialization</a><a id="Step-1:-Parameter-and-glacier-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Parameter-and-glacier-initialization" title="Permalink"></a></h3><p>First we need to specify a list of RGI IDs of the glacier we want to work with. From these RGI IDs, we will look for the necessary files inside the workspace.</p><pre><code class="language-julia hljs">rgi_ids = [&quot;RGI60-11.03638&quot;, &quot;RGI60-11.01450&quot;, &quot;RGI60-11.02346&quot;, &quot;RGI60-07.00065&quot;]
rgi_paths = get_rgi_paths()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 56 entries:
  &quot;RGI60-11.00897&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.00/RGI60-11.00897&quot;
  &quot;RGI60-08.00213&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00213&quot;
  &quot;RGI60-08.00147&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00147&quot;
  &quot;RGI60-11.01270&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.01/RGI60-11.01270&quot;
  &quot;RGI60-11.03646&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03646&quot;
  &quot;RGI60-11.03232&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03232&quot;
  &quot;RGI60-01.22174&quot; =&gt; &quot;per_glacier/RGI60-01/RGI60-01.22/RGI60-01.22174&quot;
  &quot;RGI60-07.00274&quot; =&gt; &quot;per_glacier/RGI60-07/RGI60-07.00/RGI60-07.00274&quot;
  &quot;RGI60-03.04207&quot; =&gt; &quot;per_glacier/RGI60-03/RGI60-03.04/RGI60-03.04207&quot;
  &quot;RGI60-04.04351&quot; =&gt; &quot;per_glacier/RGI60-04/RGI60-04.04/RGI60-04.04351&quot;
  &quot;RGI60-07.00065&quot; =&gt; &quot;per_glacier/RGI60-07/RGI60-07.00/RGI60-07.00065&quot;
  &quot;RGI60-11.02346&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.02/RGI60-11.02346&quot;
  &quot;RGI60-01.00570&quot; =&gt; &quot;per_glacier/RGI60-01/RGI60-01.00/RGI60-01.00570&quot;
  &quot;RGI60-11.01238&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.01/RGI60-11.01238&quot;
  &quot;RGI60-11.03005&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03005&quot;
  &quot;RGI60-08.00087&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00087&quot;
  &quot;RGI60-11.00787&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.00/RGI60-11.00787&quot;
  &quot;RGI60-08.00203&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00203&quot;
  &quot;RGI60-07.01193&quot; =&gt; &quot;per_glacier/RGI60-07/RGI60-07.01/RGI60-07.01193&quot;
  ⋮                =&gt; ⋮</code></pre><p>Then we need to define the parameters of the simulation we want to perform. The arguments are very similar to the ones used in the <a href="../forward_simulation/">forward simulation tutorial</a> and for a complete explanation, the reader should refer to this tutorial. The main difference with the forward simulation tutorial here is that we need to specify the parameters for the functional inversion through the <code>Hyperparameters</code> and the <code>UDEparameters</code>. The <code>Hyperparameters</code> structure contains information about the optimization algorithm. The <code>UDEparameters</code> define how the Universal Differential Equation (UDE) is solved and how its gradient is computed.</p><pre><code class="language-julia hljs">params = Parameters(
    simulation = SimulationParameters(
        working_dir = working_dir,
        use_MB = false,
        use_velocities = true,
        tspan = (2010.0, 2015.0),
        multiprocessing = true,
        workers = 4,
        test_mode = false,
        rgi_paths = rgi_paths,
        gridScalingFactor = 4, # Downscale the glacier grid to speed-up this example
        ),
    hyper = Hyperparameters(
        batch_size = length(rgi_ids), # Set batch size equals size of the dataset
        epochs = [15,10],
        optimizer = [
            ODINN.ADAM(0.01),
            ODINN.LBFGS(
                linesearch = ODINN.LineSearches.BackTracking(iterations = 5)
            )
        ]),
    physical = PhysicalParameters(
        minA = 8e-21,
        maxA = 8e-17
        ),
    UDE = UDEparameters(
        optim_autoAD = ODINN.NoAD(),
        grad = ContinuousAdjoint(),
        optimization_method = &quot;AD+AD&quot;,
        empirical_loss_function = LossH() # Loss function based on ice thickness
        ),
    solver = Huginn.SolverParameters(
        step = 1 / 12, # Define the time step for the simulation output and for the adjoint
        progress = true
        )
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Sleipnir.Parameters{PhysicalParameters{Float64}, SimulationParameters{Int64, Float64, MeanDateVelocityMapping}, Hyperparameters{Float64, Int64}, SolverParameters{Float64, Int64}, UDEparameters{ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}}, InversionParameters{Float64}}(PhysicalParameters{Float64}(900.0, 9.81, 1.0e-10, 1.0, 8.0e-17, 8.0e-21, 8.0e-17, 8.5e-20, 1.0, -25.0, 5.0e-18), SimulationParameters{Int64, Float64, MeanDateVelocityMapping}(false, true, true, true, 1.0, false, false, (2010.0, 2015.0), 0.08333333333333333, true, 4, &quot;/home/runner/work/ODINN.jl/ODINN.jl/demos&quot;, false, Dict(&quot;RGI60-11.00897&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.00/RGI60-11.00897&quot;, &quot;RGI60-08.00213&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00213&quot;, &quot;RGI60-08.00147&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00147&quot;, &quot;RGI60-11.01270&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.01/RGI60-11.01270&quot;, &quot;RGI60-11.03646&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03646&quot;, &quot;RGI60-11.03232&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03232&quot;, &quot;RGI60-01.22174&quot; =&gt; &quot;per_glacier/RGI60-01/RGI60-01.22/RGI60-01.22174&quot;, &quot;RGI60-07.00274&quot; =&gt; &quot;per_glacier/RGI60-07/RGI60-07.00/RGI60-07.00274&quot;, &quot;RGI60-03.04207&quot; =&gt; &quot;per_glacier/RGI60-03/RGI60-03.04/RGI60-03.04207&quot;, &quot;RGI60-04.04351&quot; =&gt; &quot;per_glacier/RGI60-04/RGI60-04.04/RGI60-04.04351&quot;…), &quot;Farinotti19&quot;, MeanDateVelocityMapping(:nearest), 4), Hyperparameters{Float64, Int64}(1, 1, Float64[], Any[Optimisers.Adam(eta=0.01, beta=(0.9, 0.999), epsilon=1.0e-8), Optim.LBFGS{Nothing, LineSearches.InitialStatic{Float64}, LineSearches.BackTracking{Float64, Int64}, Returns{Nothing}}(10, LineSearches.InitialStatic{Float64}(1.0, false), LineSearches.BackTracking{Float64, Int64}(0.0001, 0.5, 0.1, 5, 3, Inf, nothing), nothing, Returns{Nothing}(nothing), Optim.Flat(), true)], 0.0, [15, 10], 4), SolverParameters{Float64, Int64}(OrdinaryDiffEqLowStorageRK.RDPK3Sp35{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), 1.0e-12, 0.08333333333333333, Float64[], false, true, 10, 100000), UDEparameters{ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}}(SciMLSensitivity.GaussAdjoint{0, true, Val{:central}, SciMLSensitivity.EnzymeVJP}(SciMLSensitivity.EnzymeVJP(0), false), SciMLBase.NoAD(), ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}(DiscreteVJP{ADTypes.AutoMooncake{Nothing}}(ADTypes.AutoMooncake()), OrdinaryDiffEqLowStorageRK.RDPK3Sp35{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), 1.0e-8, 1.0e-8, 0.08333333333333333, :Linear, 200, EnzymeVJP()), &quot;AD+AD&quot;, LossH{L2Sum{Int64}}(L2Sum{Int64}(3)), :A, :identity), InversionParameters{Float64}([1.0], [0.0], [Inf], [1, 1], 0.001, 0.001, Optim.BFGS{LineSearches.InitialStatic{Float64}, LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}, Nothing, Nothing, Optim.Flat}(LineSearches.InitialStatic{Float64}(1.0, false), LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}(0.1, 0.9, Inf, 5.0, 1.0e-6, 0.66, 50, 0.1, 0, Base.RefValue{Bool}(false), nothing, false), nothing, nothing, Optim.Flat())))</code></pre><p>Then, we initialize those glaciers based on those RGI IDs and the parameters we previously specified.</p><pre><code class="language-julia hljs">glaciers = initialize_glaciers(rgi_ids, params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Glacier2D} distributed over regions 07 (x1), 11 (x3)
RGI60-11.03638 RGI60-11.01450 RGI60-11.02346 RGI60-07.00065
</code></pre><h3 id="Step-2:-Generate-synthetic-ground-truth-data-with-a-forward-simulation"><a class="docs-heading-anchor" href="#Step-2:-Generate-synthetic-ground-truth-data-with-a-forward-simulation">Step 2: Generate synthetic ground truth data with a forward simulation</a><a id="Step-2:-Generate-synthetic-ground-truth-data-with-a-forward-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Generate-synthetic-ground-truth-data-with-a-forward-simulation" title="Permalink"></a></h3><p>The next step is to generate a synthetic dataset using a forward simulation. This will generate a dataset with the ice thickness and surface velocities for each glacier at each time step. The dataset will be used to train the machine learning model. We define a synthetic law to generate the synthetic dataset. For this, we use some tabular data from Cuffey and Paterson (2010) [<a href="../references/#cuffey_physics_2010">2</a>]. The REPL shows that it maps the long term air temperature <code>T</code> to the creep coefficient <code>A</code>.</p><pre><code class="language-julia hljs">A_law = CuffeyPaterson(scalar = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:T,) -&gt; Array{Float64, 0}   (↧@start  )
</code></pre><p>The model is initialized using the <code>Model</code> constructor:</p><pre><code class="language-julia hljs">model = Model(
    iceflow = SIA2Dmodel(params; A = A_law),
    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">**** Model ****

SIA2D iceflow equation  = ∇(<span class="sgr32">D</span> ∇S)  with <span class="sgr32">D</span> = <span class="sgr31">U</span> H̄
  and <span class="sgr31">U</span> = <span class="sgr35">C</span> (ρg)^(<span class="sgr33">pq</span>) H̄^(<span class="sgr33">pq</span>+1) ∇S^(<span class="sgr33">p</span>-1) + <span class="sgr36">Γ</span> H̄^(<span class="sgr33">n</span>+2) ∇S^(<span class="sgr33">n</span>-1)
<span class="sgr36">      Γ</span> = 2<span class="sgr34">A</span> (ρg)^<span class="sgr33">n</span> /(<span class="sgr33">n</span>+2)
<span class="sgr34">      A: </span>(:T,) -&gt; Array{Float64, 0}   (↧@start  )
<span class="sgr35">      C: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      n: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      p: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      q: </span>ConstantLaw -&gt; Array{Float64, 0}
  where
      T =&gt; averaged_long_term_temperature

Temperature index mass balance model TImodel1
   DDF = 0.006
   acc_factor = 0.0012
No learnable components
***************</code></pre><p>We define the time snapshots for transient inversion, i.e. the time steps at which we want to save the results, which will be used to compute the adjoint in reverse mode.</p><pre><code class="language-julia hljs">tstops = collect(2010:δt:2015)

prediction = Prediction(model, glaciers, params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Prediction{Sleipnir.ModelCache{SIA2DCache{Float64, Int64, ScalarCacheNoVJP, ScalarCacheNoVJP, ScalarCacheNoVJP, ScalarCacheNoVJP, ScalarCacheNoVJP, Array{Float64, 0}, Array{Float64, 0}, ScalarCacheNoVJP, ScalarCacheNoVJP}, Nothing}}(Sleipnir.Model{SIA2Dmodel{Float64, Law{ScalarCacheNoVJP, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, Huginn.var&quot;#32#36&quot;{Polynomials.Polynomial{Float64, :x}}}, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyVJPWithInputs)}, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyVJPWithInputs)}, Huginn.var&quot;#33#37&quot;, Int64, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyPrepVJPWithInputs)}, DIVJP}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#9#10&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#11#12&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#13#14&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#15#16&quot;}, NullLaw, NullLaw}, TImodel1{Float64}, Nothing}(SIA2D iceflow equation  = ∇(<span class="sgr32">D</span> ∇S)  with <span class="sgr32">D</span> = <span class="sgr31">U</span> H̄
  and <span class="sgr31">U</span> = <span class="sgr35">C</span> (ρg)^(<span class="sgr33">pq</span>) H̄^(<span class="sgr33">pq</span>+1) ∇S^(<span class="sgr33">p</span>-1) + <span class="sgr36">Γ</span> H̄^(<span class="sgr33">n</span>+2) ∇S^(<span class="sgr33">n</span>-1)
<span class="sgr36">      Γ</span> = 2<span class="sgr34">A</span> (ρg)^<span class="sgr33">n</span> /(<span class="sgr33">n</span>+2)
<span class="sgr34">      A: </span>(:T,) -&gt; Array{Float64, 0}   (↧@start  )
<span class="sgr35">      C: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      n: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      p: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      q: </span>ConstantLaw -&gt; Array{Float64, 0}
  where
      T =&gt; averaged_long_term_temperature
, Temperature index mass balance model TImodel1
   DDF = 0.006
   acc_factor = 0.0012, nothing), nothing, 4-element Vector{AbstractGlacier} distributed over regions 07 (x1), 11 (x3)
RGI60-11.03638 RGI60-11.01450 RGI60-11.02346 RGI60-07.00065
, Sleipnir.Parameters{PhysicalParameters{Float64}, SimulationParameters{Int64, Float64, MeanDateVelocityMapping}, Hyperparameters{Float64, Int64}, SolverParameters{Float64, Int64}, UDEparameters{ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}}, InversionParameters{Float64}}(PhysicalParameters{Float64}(900.0, 9.81, 1.0e-10, 1.0, 8.0e-17, 8.0e-21, 8.0e-17, 8.5e-20, 1.0, -25.0, 5.0e-18), SimulationParameters{Int64, Float64, MeanDateVelocityMapping}(false, true, true, true, 1.0, false, false, (2010.0, 2015.0), 0.08333333333333333, true, 4, &quot;/home/runner/work/ODINN.jl/ODINN.jl/demos&quot;, false, Dict(&quot;RGI60-11.00897&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.00/RGI60-11.00897&quot;, &quot;RGI60-08.00213&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00213&quot;, &quot;RGI60-08.00147&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00147&quot;, &quot;RGI60-11.01270&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.01/RGI60-11.01270&quot;, &quot;RGI60-11.03646&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03646&quot;, &quot;RGI60-11.03232&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03232&quot;, &quot;RGI60-01.22174&quot; =&gt; &quot;per_glacier/RGI60-01/RGI60-01.22/RGI60-01.22174&quot;, &quot;RGI60-07.00274&quot; =&gt; &quot;per_glacier/RGI60-07/RGI60-07.00/RGI60-07.00274&quot;, &quot;RGI60-03.04207&quot; =&gt; &quot;per_glacier/RGI60-03/RGI60-03.04/RGI60-03.04207&quot;, &quot;RGI60-04.04351&quot; =&gt; &quot;per_glacier/RGI60-04/RGI60-04.04/RGI60-04.04351&quot;…), &quot;Farinotti19&quot;, MeanDateVelocityMapping(:nearest), 4), Hyperparameters{Float64, Int64}(1, 1, Float64[], Any[Optimisers.Adam(eta=0.01, beta=(0.9, 0.999), epsilon=1.0e-8), Optim.LBFGS{Nothing, LineSearches.InitialStatic{Float64}, LineSearches.BackTracking{Float64, Int64}, Returns{Nothing}}(10, LineSearches.InitialStatic{Float64}(1.0, false), LineSearches.BackTracking{Float64, Int64}(0.0001, 0.5, 0.1, 5, 3, Inf, nothing), nothing, Returns{Nothing}(nothing), Optim.Flat(), true)], 0.0, [15, 10], 4), SolverParameters{Float64, Int64}(OrdinaryDiffEqLowStorageRK.RDPK3Sp35{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), 1.0e-12, 0.08333333333333333, Float64[], false, true, 10, 100000), UDEparameters{ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}}(SciMLSensitivity.GaussAdjoint{0, true, Val{:central}, SciMLSensitivity.EnzymeVJP}(SciMLSensitivity.EnzymeVJP(0), false), SciMLBase.NoAD(), ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}(DiscreteVJP{ADTypes.AutoMooncake{Nothing}}(ADTypes.AutoMooncake()), OrdinaryDiffEqLowStorageRK.RDPK3Sp35{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), 1.0e-8, 1.0e-8, 0.08333333333333333, :Linear, 200, EnzymeVJP()), &quot;AD+AD&quot;, LossH{L2Sum{Int64}}(L2Sum{Int64}(3)), :A, :identity), InversionParameters{Float64}([1.0], [0.0], [Inf], [1, 1], 0.001, 0.001, Optim.BFGS{LineSearches.InitialStatic{Float64}, LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}, Nothing, Nothing, Optim.Flat}(LineSearches.InitialStatic{Float64}(1.0, false), LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}(0.1, 0.9, Inf, 5.0, 1.0e-6, 0.66, 50, 0.1, 0, Base.RefValue{Bool}(false), nothing, false), nothing, nothing, Optim.Flat()))), Sleipnir.Results[])</code></pre><p>We generate the synthetic dataset using the forward simulation. This will generate a dataset with the ice thickness and surface velocities for each glacier at each time step. The dataset will be used to train the machine learning model. This will run under the hood a <code>Prediction</code> using <a href="https://github.com/ODINN-SciML/Huginn.jl/"><code>Huginn.jl</code></a>.</p><pre><code class="language-julia hljs">glaciers = generate_ground_truth(glaciers, params, model, tstops)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Glacier2D} distributed over regions 07 (x1), 11 (x3)
RGI60-11.03638 RGI60-11.01450 RGI60-11.02346 RGI60-07.00065
</code></pre><p>The results of this simulation are stored in the <code>thicknessData</code> field of each glacier, which we can inspect:</p><pre><code class="language-julia hljs">glaciers[1].thicknessData</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ThicknessData{Float64}([2010.0, 2010.0833333333333, 2010.1666666666667, 2010.25, 2010.3333333333333, 2010.4166666666667, 2010.5, 2010.5833333333333, 2010.6666666666667, 2010.75  …  2014.25, 2014.3333333333333, 2014.4166666666667, 2014.5, 2014.5833333333333, 2014.6666666666667, 2014.75, 2014.8333333333333, 2014.9166666666667, 2015.0], [[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]  …  [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]])</code></pre><h3 id="Step-3:-Model-specification-to-perform-a-functional-inversion"><a class="docs-heading-anchor" href="#Step-3:-Model-specification-to-perform-a-functional-inversion">Step 3: Model specification to perform a functional inversion</a><a id="Step-3:-Model-specification-to-perform-a-functional-inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Model-specification-to-perform-a-functional-inversion" title="Permalink"></a></h3><p>After this forward simulation, we define a new iceflow model to be ready for the inversions. The first step is to define a simple neural network that takes as input a scalar and returns a scalar.</p><pre><code class="language-julia hljs">nn_model = NeuralNetwork(params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">--- NeuralNetwork ---
    architecture:
      Chain(
          layer_1 = Dense(1 =&gt; 3, #101),                # 6 parameters
          layer_2 = Dense(3 =&gt; 10, #102),               # 40 parameters
          layer_3 = Dense(10 =&gt; 3, #103),               # 33 parameters
          layer_4 = Dense(3 =&gt; 1, σ),                   # 4 parameters
      )         # Total: 83 parameters,
                #        plus 0 states.
    θ: ComponentVector of length 83</code></pre><p>Then we define a law that uses this neural network to map the long term air temperature <code>T</code> to the creep coefficient <code>A</code>. ODINN comes with a set of already defined laws. Only a few of them support functional inversion as the computation of the gradient needs to be carefully handled. More information about these laws can be found in the <a href="../laws/">laws tutorial</a>.</p><pre><code class="language-julia hljs">law_input = (; T = iAvgScalarTemp())
A_law = LawA(nn_model, params, law_input)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:T,) -&gt; Array{Float64, 0}   (↧@start  custom VJP  ✅ precomputed)
</code></pre><p>Then we define an iceflow and ODINN tells us how the law is used in the iceflow equation.</p><pre><code class="language-julia hljs">iceflow = SIA2Dmodel(params; A=A_law)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SIA2D iceflow equation  = ∇(<span class="sgr32">D</span> ∇S)  with <span class="sgr32">D</span> = <span class="sgr31">U</span> H̄
  and <span class="sgr31">U</span> = <span class="sgr35">C</span> (ρg)^(<span class="sgr33">pq</span>) H̄^(<span class="sgr33">pq</span>+1) ∇S^(<span class="sgr33">p</span>-1) + <span class="sgr36">Γ</span> H̄^(<span class="sgr33">n</span>+2) ∇S^(<span class="sgr33">n</span>-1)
<span class="sgr36">      Γ</span> = 2<span class="sgr34">A</span> (ρg)^<span class="sgr33">n</span> /(<span class="sgr33">n</span>+2)
<span class="sgr34">      A: </span>(:T,) -&gt; Array{Float64, 0}   (↧@start  custom VJP  ✅ precomputed)
<span class="sgr35">      C: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      n: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      p: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      q: </span>ConstantLaw -&gt; Array{Float64, 0}
  where
      T =&gt; averaged_long_term_temperature
</code></pre><p>Finally we define the model which needs to know the iceflow and mass balance models, and in comparison to Huginn, there is a third argument <code>regressors</code>. The <code>regressors</code> argument tells how each regressor relates into the SIA. Although we already defined this in the law, this definition is mandatory for technical reasons. This argument will probably disappear in the future once the code becomes more mature. It must match how the laws are defined in the iceflow model.</p><pre><code class="language-julia hljs">model = Model(
    iceflow = iceflow,
    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),
    regressors = (; A = nn_model)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">**** Model ****

SIA2D iceflow equation  = ∇(<span class="sgr32">D</span> ∇S)  with <span class="sgr32">D</span> = <span class="sgr31">U</span> H̄
  and <span class="sgr31">U</span> = <span class="sgr35">C</span> (ρg)^(<span class="sgr33">pq</span>) H̄^(<span class="sgr33">pq</span>+1) ∇S^(<span class="sgr33">p</span>-1) + <span class="sgr36">Γ</span> H̄^(<span class="sgr33">n</span>+2) ∇S^(<span class="sgr33">n</span>-1)
<span class="sgr36">      Γ</span> = 2<span class="sgr34">A</span> (ρg)^<span class="sgr33">n</span> /(<span class="sgr33">n</span>+2)
<span class="sgr34">      A: </span>(:T,) -&gt; Array{Float64, 0}   (↧@start  custom VJP  ✅ precomputed)
<span class="sgr35">      C: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      n: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      p: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      q: </span>ConstantLaw -&gt; Array{Float64, 0}
  where
      T =&gt; averaged_long_term_temperature

Temperature index mass balance model TImodel1
   DDF = 0.006
   acc_factor = 0.0012
Learnable components
  A: --- NeuralNetwork ---
    architecture:
      Chain(
          layer_1 = Dense(1 =&gt; 3, #101),                # 6 parameters
          layer_2 = Dense(3 =&gt; 10, #102),               # 40 parameters
          layer_3 = Dense(10 =&gt; 3, #103),               # 33 parameters
          layer_4 = Dense(3 =&gt; 1, σ),                   # 4 parameters
      )         # Total: 83 parameters,
                #        plus 0 states.
    θ: ComponentVector of length 83

***************</code></pre><h3 id="Step-4:-Train-a-Universal-Differential-Equation-via-a-functional-inversion"><a class="docs-heading-anchor" href="#Step-4:-Train-a-Universal-Differential-Equation-via-a-functional-inversion">Step 4: Train a Universal Differential Equation via a functional inversion</a><a id="Step-4:-Train-a-Universal-Differential-Equation-via-a-functional-inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Train-a-Universal-Differential-Equation-via-a-functional-inversion" title="Permalink"></a></h3><p>The next step is to specify the type of simulation we want to perform. In this case, we will use an <code>Inversion</code> simulation, which will use the synthetic dataset generated in the previous step to train a UDE.</p><pre><code class="language-julia hljs">functional_inversion = Inversion(model, glaciers, params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inversion{Sleipnir.Model{SIA2Dmodel{Float64, Law{ScalarCache, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, ODINN.var&quot;#234#240&quot;{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, Lux.Chain{@NamedTuple{layer_1::Lux.Dense{ODINN.var&quot;#101#105&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_2::Lux.Dense{ODINN.var&quot;#102#106&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_3::Lux.Dense{ODINN.var&quot;#103#107&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_4::Lux.Dense{typeof(NNlib.σ), Int64, Int64, Nothing, Nothing, Static.True}}, Nothing}, Nothing, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}, Float64, Float64}}, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyVJPWithInputs)}, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyVJPWithInputs)}, ODINN.var&quot;#238#244&quot;, Int64, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, ODINN.var&quot;#236#242&quot;{ODINN.var&quot;#234#240&quot;{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, Lux.Chain{@NamedTuple{layer_1::Lux.Dense{ODINN.var&quot;#101#105&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_2::Lux.Dense{ODINN.var&quot;#102#106&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_3::Lux.Dense{ODINN.var&quot;#103#107&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_4::Lux.Dense{typeof(NNlib.σ), Int64, Int64, Nothing, Nothing, Static.True}}, Nothing}, Nothing, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}, Float64, Float64}}}, CustomVJP}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#9#10&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#11#12&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#13#14&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#15#16&quot;}, NullLaw, NullLaw}, TImodel1{Float64}, ODINN.TrainableComponents{NeuralNetwork{Lux.Chain{@NamedTuple{layer_1::Lux.Dense{ODINN.var&quot;#101#105&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_2::Lux.Dense{ODINN.var&quot;#102#106&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_3::Lux.Dense{ODINN.var&quot;#103#107&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_4::Lux.Dense{typeof(NNlib.σ), Int64, Int64, Nothing, Nothing, Static.True}}, Nothing}, ComponentArrays.ComponentVector{Float64, Vector{Float64}, Tuple{ComponentArrays.Axis{(θ = ViewAxis(1:83, Axis(layer_1 = ViewAxis(1:6, Axis(weight = ViewAxis(1:3, ShapedAxis((3, 1))), bias = ViewAxis(4:6, Shaped1DAxis((3,))))), layer_2 = ViewAxis(7:46, Axis(weight = ViewAxis(1:30, ShapedAxis((10, 3))), bias = ViewAxis(31:40, Shaped1DAxis((10,))))), layer_3 = ViewAxis(47:79, Axis(weight = ViewAxis(1:30, ShapedAxis((3, 10))), bias = ViewAxis(31:33, Shaped1DAxis((3,))))), layer_4 = ViewAxis(80:83, Axis(weight = ViewAxis(1:3, ShapedAxis((1, 3))), bias = ViewAxis(4:4, Shaped1DAxis((1,))))))),)}}}, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}, ODINN.emptyTrainableModel, ODINN.emptyTrainableModel, ODINN.emptyTrainableModel, ODINN.emptyTrainableModel, ODINN.emptyIC, SIA2D_A_target, ComponentArrays.ComponentVector{Float64, Vector{Float64}, Tuple{ComponentArrays.Axis{(A = ViewAxis(1:83, Axis(layer_1 = ViewAxis(1:6, Axis(weight = ViewAxis(1:3, ShapedAxis((3, 1))), bias = ViewAxis(4:6, Shaped1DAxis((3,))))), layer_2 = ViewAxis(7:46, Axis(weight = ViewAxis(1:30, ShapedAxis((10, 3))), bias = ViewAxis(31:40, Shaped1DAxis((10,))))), layer_3 = ViewAxis(47:79, Axis(weight = ViewAxis(1:30, ShapedAxis((3, 10))), bias = ViewAxis(31:33, Shaped1DAxis((3,))))), layer_4 = ViewAxis(80:83, Axis(weight = ViewAxis(1:3, ShapedAxis((1, 3))), bias = ViewAxis(4:4, Shaped1DAxis((1,))))))),)}}}}}, Sleipnir.ModelCache{SIA2DCache{Float64, Int64, ScalarCache, ScalarCacheNoVJP, ScalarCacheNoVJP, ScalarCacheNoVJP, ScalarCacheNoVJP, Array{Float64, 0}, Array{Float64, 0}, ScalarCacheNoVJP, ScalarCacheNoVJP}, Nothing}, Glacier2D{Float64, Int64, Climate2D{Rasters.RasterStack{(:prcp, :temp, :gradient), @NamedTuple{prcp::Float64, temp::Float64, gradient::Float64}, 1, @NamedTuple{prcp::Vector{Float64}, temp::Vector{Float64}, gradient::Vector{Float64}}, Tuple{DimensionalData.Dimensions.Ti{DimensionalData.Dimensions.Lookups.Sampled{Dates.DateTime, Vector{Dates.DateTime}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Irregular{Tuple{Nothing, Nothing}}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}}}}, Tuple{}, @NamedTuple{prcp::Tuple{DimensionalData.Dimensions.Ti{Colon}}, temp::Tuple{DimensionalData.Dimensions.Ti{Colon}}, gradient::Tuple{DimensionalData.Dimensions.Ti{Colon}}}, DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}, @NamedTuple{prcp::DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}, temp::DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}, gradient::DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}}, Nothing}, Rasters.RasterStack{(:prcp, :temp, :gradient), @NamedTuple{prcp::Float64, temp::Float64, gradient::Float64}, 1, @NamedTuple{prcp::Vector{Float64}, temp::Vector{Float64}, gradient::Vector{Float64}}, Tuple{DimensionalData.Dimensions.Ti{DimensionalData.Dimensions.Lookups.Sampled{Dates.DateTime, Vector{Dates.DateTime}, DimensionalData.Dimensions.Lookups.ForwardOrdered, DimensionalData.Dimensions.Lookups.Irregular{Tuple{Nothing, Nothing}}, DimensionalData.Dimensions.Lookups.Points, DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}}}}, Tuple{}, @NamedTuple{prcp::Tuple{DimensionalData.Dimensions.Ti{Colon}}, temp::Tuple{DimensionalData.Dimensions.Ti{Colon}}, gradient::Tuple{DimensionalData.Dimensions.Ti{Colon}}}, DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}, @NamedTuple{prcp::DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}, temp::DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}, gradient::DimensionalData.Dimensions.Lookups.Metadata{Rasters.NCDsource, Dict{String, Any}}}, Nothing}, Sleipnir.ClimateStep{Float64}, Climate2Dstep{Float64}, Float64}, ThicknessData{Float64}, SurfaceVelocityData{Float64}}, Results{Sleipnir.Results{Float64, Int64}, TrainingStats{Float64, Int64}}}(Sleipnir.Model{SIA2Dmodel{Float64, Law{ScalarCache, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, ODINN.var&quot;#234#240&quot;{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, Lux.Chain{@NamedTuple{layer_1::Lux.Dense{ODINN.var&quot;#101#105&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_2::Lux.Dense{ODINN.var&quot;#102#106&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_3::Lux.Dense{ODINN.var&quot;#103#107&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_4::Lux.Dense{typeof(NNlib.σ), Int64, Int64, Nothing, Nothing, Static.True}}, Nothing}, Nothing, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}, Float64, Float64}}, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyVJPWithInputs)}, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, typeof(Sleipnir.emptyVJPWithInputs)}, ODINN.var&quot;#238#244&quot;, Int64, Sleipnir.GenInputsAndApply{@NamedTuple{T::iAvgScalarTemp}, ODINN.var&quot;#236#242&quot;{ODINN.var&quot;#234#240&quot;{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, Lux.Chain{@NamedTuple{layer_1::Lux.Dense{ODINN.var&quot;#101#105&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_2::Lux.Dense{ODINN.var&quot;#102#106&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_3::Lux.Dense{ODINN.var&quot;#103#107&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_4::Lux.Dense{typeof(NNlib.σ), Int64, Int64, Nothing, Nothing, Static.True}}, Nothing}, Nothing, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}, Float64, Float64}}}, CustomVJP}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#9#10&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#11#12&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#13#14&quot;}, ConstantLaw{ScalarCacheNoVJP, Huginn.var&quot;#15#16&quot;}, NullLaw, NullLaw}, TImodel1{Float64}, ODINN.TrainableComponents{NeuralNetwork{Lux.Chain{@NamedTuple{layer_1::Lux.Dense{ODINN.var&quot;#101#105&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_2::Lux.Dense{ODINN.var&quot;#102#106&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_3::Lux.Dense{ODINN.var&quot;#103#107&quot;, Int64, Int64, Nothing, Nothing, Static.True}, layer_4::Lux.Dense{typeof(NNlib.σ), Int64, Int64, Nothing, Nothing, Static.True}}, Nothing}, ComponentArrays.ComponentVector{Float64, Vector{Float64}, Tuple{ComponentArrays.Axis{(θ = ViewAxis(1:83, Axis(layer_1 = ViewAxis(1:6, Axis(weight = ViewAxis(1:3, ShapedAxis((3, 1))), bias = ViewAxis(4:6, Shaped1DAxis((3,))))), layer_2 = ViewAxis(7:46, Axis(weight = ViewAxis(1:30, ShapedAxis((10, 3))), bias = ViewAxis(31:40, Shaped1DAxis((10,))))), layer_3 = ViewAxis(47:79, Axis(weight = ViewAxis(1:30, ShapedAxis((3, 10))), bias = ViewAxis(31:33, Shaped1DAxis((3,))))), layer_4 = ViewAxis(80:83, Axis(weight = ViewAxis(1:3, ShapedAxis((1, 3))), bias = ViewAxis(4:4, Shaped1DAxis((1,))))))),)}}}, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}, ODINN.emptyTrainableModel, ODINN.emptyTrainableModel, ODINN.emptyTrainableModel, ODINN.emptyTrainableModel, ODINN.emptyIC, SIA2D_A_target, ComponentArrays.ComponentVector{Float64, Vector{Float64}, Tuple{ComponentArrays.Axis{(A = ViewAxis(1:83, Axis(layer_1 = ViewAxis(1:6, Axis(weight = ViewAxis(1:3, ShapedAxis((3, 1))), bias = ViewAxis(4:6, Shaped1DAxis((3,))))), layer_2 = ViewAxis(7:46, Axis(weight = ViewAxis(1:30, ShapedAxis((10, 3))), bias = ViewAxis(31:40, Shaped1DAxis((10,))))), layer_3 = ViewAxis(47:79, Axis(weight = ViewAxis(1:30, ShapedAxis((3, 10))), bias = ViewAxis(31:33, Shaped1DAxis((3,))))), layer_4 = ViewAxis(80:83, Axis(weight = ViewAxis(1:3, ShapedAxis((1, 3))), bias = ViewAxis(4:4, Shaped1DAxis((1,))))))),)}}}}}(SIA2D iceflow equation  = ∇(<span class="sgr32">D</span> ∇S)  with <span class="sgr32">D</span> = <span class="sgr31">U</span> H̄
  and <span class="sgr31">U</span> = <span class="sgr35">C</span> (ρg)^(<span class="sgr33">pq</span>) H̄^(<span class="sgr33">pq</span>+1) ∇S^(<span class="sgr33">p</span>-1) + <span class="sgr36">Γ</span> H̄^(<span class="sgr33">n</span>+2) ∇S^(<span class="sgr33">n</span>-1)
<span class="sgr36">      Γ</span> = 2<span class="sgr34">A</span> (ρg)^<span class="sgr33">n</span> /(<span class="sgr33">n</span>+2)
<span class="sgr34">      A: </span>(:T,) -&gt; Array{Float64, 0}   (↧@start  custom VJP  ✅ precomputed)
<span class="sgr35">      C: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      n: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      p: </span>ConstantLaw -&gt; Array{Float64, 0}
<span class="sgr33">      q: </span>ConstantLaw -&gt; Array{Float64, 0}
  where
      T =&gt; averaged_long_term_temperature
, Temperature index mass balance model TImodel1
   DDF = 0.006
   acc_factor = 0.0012,   A: --- NeuralNetwork ---
    architecture:
      Chain(
          layer_1 = Dense(1 =&gt; 3, #101),                # 6 parameters
          layer_2 = Dense(3 =&gt; 10, #102),               # 40 parameters
          layer_3 = Dense(10 =&gt; 3, #103),               # 33 parameters
          layer_4 = Dense(3 =&gt; 1, σ),                   # 4 parameters
      )         # Total: 83 parameters,
                #        plus 0 states.
    θ: ComponentVector of length 83
), nothing, 4-element Vector{Glacier2D} distributed over regions 07 (x1), 11 (x3)
RGI60-11.03638 RGI60-11.01450 RGI60-11.02346 RGI60-07.00065
, Sleipnir.Parameters{PhysicalParameters{Float64}, SimulationParameters{Int64, Float64, MeanDateVelocityMapping}, Hyperparameters{Float64, Int64}, SolverParameters{Float64, Int64}, UDEparameters{ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}}, InversionParameters{Float64}}(PhysicalParameters{Float64}(900.0, 9.81, 1.0e-10, 1.0, 8.0e-17, 8.0e-21, 8.0e-17, 8.5e-20, 1.0, -25.0, 5.0e-18), SimulationParameters{Int64, Float64, MeanDateVelocityMapping}(false, true, true, true, 1.0, false, false, (2010.0, 2015.0), 0.08333333333333333, true, 4, &quot;/home/runner/work/ODINN.jl/ODINN.jl/demos&quot;, false, Dict(&quot;RGI60-11.00897&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.00/RGI60-11.00897&quot;, &quot;RGI60-08.00213&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00213&quot;, &quot;RGI60-08.00147&quot; =&gt; &quot;per_glacier/RGI60-08/RGI60-08.00/RGI60-08.00147&quot;, &quot;RGI60-11.01270&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.01/RGI60-11.01270&quot;, &quot;RGI60-11.03646&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03646&quot;, &quot;RGI60-11.03232&quot; =&gt; &quot;per_glacier/RGI60-11/RGI60-11.03/RGI60-11.03232&quot;, &quot;RGI60-01.22174&quot; =&gt; &quot;per_glacier/RGI60-01/RGI60-01.22/RGI60-01.22174&quot;, &quot;RGI60-07.00274&quot; =&gt; &quot;per_glacier/RGI60-07/RGI60-07.00/RGI60-07.00274&quot;, &quot;RGI60-03.04207&quot; =&gt; &quot;per_glacier/RGI60-03/RGI60-03.04/RGI60-03.04207&quot;, &quot;RGI60-04.04351&quot; =&gt; &quot;per_glacier/RGI60-04/RGI60-04.04/RGI60-04.04351&quot;…), &quot;Farinotti19&quot;, MeanDateVelocityMapping(:nearest), 4), Hyperparameters{Float64, Int64}(1, 1, Float64[], Any[Optimisers.Adam(eta=0.01, beta=(0.9, 0.999), epsilon=1.0e-8), Optim.LBFGS{Nothing, LineSearches.InitialStatic{Float64}, LineSearches.BackTracking{Float64, Int64}, Returns{Nothing}}(10, LineSearches.InitialStatic{Float64}(1.0, false), LineSearches.BackTracking{Float64, Int64}(0.0001, 0.5, 0.1, 5, 3, Inf, nothing), nothing, Returns{Nothing}(nothing), Optim.Flat(), true)], 0.0, [15, 10], 4), SolverParameters{Float64, Int64}(OrdinaryDiffEqLowStorageRK.RDPK3Sp35{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), 1.0e-12, 0.08333333333333333, Float64[], false, true, 10, 100000), UDEparameters{ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}}(SciMLSensitivity.GaussAdjoint{0, true, Val{:central}, SciMLSensitivity.EnzymeVJP}(SciMLSensitivity.EnzymeVJP(0), false), SciMLBase.NoAD(), ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP}(DiscreteVJP{ADTypes.AutoMooncake{Nothing}}(ADTypes.AutoMooncake()), OrdinaryDiffEqLowStorageRK.RDPK3Sp35{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), 1.0e-8, 1.0e-8, 0.08333333333333333, :Linear, 200, EnzymeVJP()), &quot;AD+AD&quot;, LossH{L2Sum{Int64}}(L2Sum{Int64}(3)), :A, :identity), InversionParameters{Float64}([1.0], [0.0], [Inf], [1, 1], 0.001, 0.001, Optim.BFGS{LineSearches.InitialStatic{Float64}, LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}, Nothing, Nothing, Optim.Flat}(LineSearches.InitialStatic{Float64}(1.0, false), LineSearches.HagerZhang{Float64, Base.RefValue{Bool}}(0.1, 0.9, Inf, 5.0, 1.0e-6, 0.66, 50, 0.1, 0, Base.RefValue{Bool}(false), nothing, false), nothing, nothing, Optim.Flat()))), Results{Sleipnir.Results{Float64, Int64}, TrainingStats{Float64, Int64}}(Sleipnir.Results{Float64, Int64}[], TrainingStats{Float64, Int64}(nothing, Float64[], 0, nothing, ComponentArrays.ComponentVector[], ComponentArrays.ComponentVector[], nothing, Dates.DateTime(&quot;0000-01-01T00:00:00&quot;))))</code></pre><p>And finally, we just run the simulation. This will run the adjoint method to compute the gradients and then use the ADAM and LBFGS optimizers to train the UDE model.</p><pre><code class="language-julia hljs">run!(functional_inversion)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Optimizing with ADAM
[ Info: Optimizing with custom ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP} method
Iteration: [    1 /    25]     Loss:7.90137e+01
Iteration: [    2 /    25]     Loss:6.52403e+01     Improvement: -17.43 %
Iteration: [    3 /    25]     Loss:5.40509e+01     Improvement: -17.15 %
Iteration: [    4 /    25]     Loss:4.57279e+01     Improvement: -15.40 %
Iteration: [    5 /    25]     Loss:3.89663e+01     Improvement: -14.79 %
Iteration: [    6 /    25]     Loss:3.35554e+01     Improvement: -13.89 %
Iteration: [    7 /    25]     Loss:2.91507e+01     Improvement: -13.13 %
Iteration: [    8 /    25]     Loss:2.55161e+01     Improvement: -12.47 %
Iteration: [    9 /    25]     Loss:2.21683e+01     Improvement: -13.12 %
Iteration: [   10 /    25]     Loss:1.99518e+01     Improvement: -10.00 %
Iteration: [   11 /    25]     Loss:1.75260e+01     Improvement: -12.16 %
Iteration: [   12 /    25]     Loss:1.59671e+01     Improvement: -8.89 %
Iteration: [   13 /    25]     Loss:1.44823e+01     Improvement: -9.30 %
Iteration: [   14 /    25]     Loss:1.31806e+01     Improvement: -8.99 %
Iteration: [   15 /    25]     Loss:1.20103e+01     Improvement: -8.88 %
Iteration: [   16 /    25]     Loss:1.20103e+01     Improvement: 0.00 %
[ Info: Optimizing with BFGS
[ Info: Optimizing with custom ContinuousAdjoint{Float64, Int64, DiscreteVJP{ADTypes.AutoMooncake{Nothing}}, EnzymeVJP} method
Iteration: [   17 /    25]     Loss:1.20103e+01     Improvement: 0.00 %
Iteration: [   18 /    25]     Loss:1.08576e+01     Improvement: -9.60 %</code></pre><p>The optimized parameters can be found in the results:</p><pre><code class="language-julia hljs">θ = functional_inversion.results.stats.θ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(A = (layer_1 = (weight = [-0.48749396236363973; 0.1822564237295926; -4.216018419586753;;], bias = [0.22009221136211582, -0.9744739571788565, 1.6078844344357694]), layer_2 = (weight = [0.19139640162355534 0.9255775813230771 -0.40150476381605765; -1.032044382478948 0.4574518240750211 0.12294049822284348; … ; -0.2660953669459427 0.17449521809941448 1.4954759057503932; -1.048036227504874 -0.6034262911879155 -0.707034681597259], bias = [0.28791695905313996, 0.0058849647404441985, 0.28722115077662963, 0.20606456870486647, -0.9074540885825695, 0.15323115661439612, 0.5171590124894062, 0.22740877779518176, 0.1889457214384642, -0.4445354760865223]), layer_3 = (weight = [-1.0075836895888695 -9.576933495573256 … -7.7458486499863906 0.3079471491727192; -0.948975234120627 -3.9652679236906145 … -3.4520732956999476 -0.22241162793051406; -0.9797673028018032 -3.7613125515219967 … -2.9543508561594884 0.042226220655639836], bias = [-4.458084201509202, -1.475665852101514, -1.6334444886952912]), layer_4 = (weight = [13.703562097634512 2.4872281072743827 2.644821836227029], bias = [26.887072879816547])))</code></pre><p>And then we can visualize the learnt law by plotting the neural network mapping from temperature to A.</p><pre><code class="language-julia hljs">plot_law(functional_inversion.model.iceflow.A, functional_inversion, law_input, θ)</code></pre><img src="data:image/png;base64,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" /><p>And then we compare it to the ground truth law used to generate the synthetic dataset.</p><pre><code class="language-julia hljs">plot_law(prediction.model.iceflow.A, functional_inversion, law_input, nothing)</code></pre><img src="data:image/png;base64,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9Ro2bHjv3r179+45ODiUztvb278m2Ott37699HGTJk2GDh0aGBhYp04dhRtLTyjs0KFDufmOHTuWPkuajEVI9GaPHz92dnZOSEjo2LHjuHHjatWqpaOjIxaLAwMDxWJx6WYtW7a0tLQ8duxYUVGR9LvA3r1716tXz9HRUbpMLJ1UWnJtbe1yR2xKF2GSf7/IfPbsGYCyR7q+s+fPnwOQ7oQsp379+vfu3cvOzi47aWRk9Jpgr3fixIlWrVoBqFmzpo7OG36OvSqYdKZcKtJALEKiN1u1alVCQsLMmTODgoJKJx8+fCj9Wq6USCTq1avX77//HhMTExUVZWRk1LVrVwC9e/deuXJlWlpaZGSklpaW9GvCdyYtjLIFLCX9cf+2TE1NASQnJ79PJKmaNWsCePz48ctPSdd573O2ezkmJialZ6RUMNijR4/KzUtnKjEVVVP8jpDozaT7D0ePHl128sKFCy9vWfo14dGjR7t37y5djfXu3VsikezatevSpUtt27Z91R68CrKwsICiH+vSg2jelvRcOoWfpZSuri6AN155p0GDBqampqmpqQ8fPiw7n5KSkpiYaGRkVO60CqWRHhRz7ty5cvMxMTGlzwLQ1tbW1tZWnQsMkdKwCInerG7dugASEhJKZ4qLi6UnFZQjLcLQ0NCkpKTSXaBubm66urrffvutWCx+/xMnTExM6tSpExcXl5iYWDoZExNT9iSNinN2dm7RosXly5d///33V21jbW0NoOzbKaSlpTVs2LCSkpKlS5eWnf/++++Li4s/+ugjaaEqX9euXa2srM6fP//333+XThYWFi5btgxA6YmSWlpaFhYWjx8/LndQD6k97holkomKipo0aVK5SRMTk0WLFvXs2fOXX36ZPHlyQUFBu3btHjx4sGTJkqdPn778Io0bN7a1tZVeo6RPnz7SyZo1azo7O0tPpS+dfB+jR49evXr14MGD586dW6dOnX/++ee7776ztbUtPamx4kQiUUhISO/evT///POLFy9+9NFH5ubmd+/e3bt3r4ODw7Rp0wA0a9bMzMzsr7/+mjJlir29va6ubvfu3Vu2bPnyq82bN2/Xrl2rV6/W0tL67LPPtLS0fv3115UrV9asWfPbb799/w/+bnR1db///vvPPvts1KhRixYtcnV1TU5OXrRo0bVr17p37172igFOTk67d+8eNmxY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" /><p>Since we have a very limited range of temperature coverage with these 4 glaciers, we have only captured a small portion of the ground truth law, which has an almost linear form. If we wanted to learn the full dynamics of the Cuffey and Paterson synthetic law, we would need to have glaciers that cover a wider range of temperatures.</p><p>Just to have some additional context, here is how the synthetic law looks like for the full range of temperatures:</p><pre><code class="language-julia hljs">plot_law(prediction.model.iceflow.A, functional_inversion, law_input, nothing; plot_full_input_range=true)</code></pre><img src="data:image/png;base64,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IiQiojLg0iU8fgwA9vbo3Fmbr8wiJCKiMkC9X7RfP5iZafOVWYRERFTaKRS62i8KFiEREZV+p08jKgoAKldGu3ZafnEWoYG6ffv2hx9+6O/v36lTpzlz5kRHR5ew8r59+zw9PatXr37z5s3g4GBvb+/q1avvVf/37BWcOXNm4MCBAwcOfP/991euXJmamlrcmjdv3rxz585rfCdEZADUlw8OGgRjbV/3xyI0RMePH2/RooWzs/OqVavmzZtnZGQ0e/bsEtZfvHjxli1bnjx5Ur9+/W+++WbSpElPnjwZMGDAq79jWFjY1atXBwwY0KVLlz///LNTp06KYiZH2rZt2271X3kiIiA/H/v3q8a6mPeCF9QbHLlcPnbs2Dlz5nz66afCkjZt2mRmZgLYtm2br69vkyZNANy5c+fixYtjx45dvHjxv//+u2PHjnPnzrm5uV28eDE9PT0mJmbOnDm2trZBQUGHDh2SSCRDhgzx9/dPT0//4osvFixYYGpqCiAtLW3ZsmULFy4E4ODgIHRn27Zt3d3dQ0NDY2NjDx48GB8fX6NGjY8++sjBweHWrVtnz541MTHJy8urVavWBx98oFQqd+zYcebMGXt7+3HjxlWvXh3A7t27XVxchM3TlStXJicnb9q0KS4uzsXF5cMPP6xZsyaAY8eOHThwwNjYeNCgQc2bNwdw69aty5cve3l5/fzzz05OTtOmTatUqZI4fwZE9DqCghAfDwAeHmjeXPuvzyIU2YIF2LULeXk6fAsHByxahG7dVA/v3LkTGhr64YcfFl7HysoKwP79++VyuVCEDx482LVr19ixY+vXr29qalq7dm1vb297e3s7OzsvL6/GjRubmJh8++23mzdv/uyzz3JzcwcNGvTzzz+3bt365MmTDRo0GDhwIICff/755s2bJiYmhd8rPT0dgKmp6fnz5/38/CpVqvTnn3926NDhypUrDg4OTk5OpqamjRs3dnFxATBhwoTw8PCPPvooIiKidevWwcHB7u7uhw4dOn369OjRo3v16qVQKNq3b//ZZ5917do1LCwsOjq6Zs2aO3funDFjxvLly3Nycnr37v3zzz937tz53r17c+fO7dy5c//+/ffu3Tto0KATJ07o8HMnIi1Rny86ZAgkEu2/PotQTNHRWLhQH280d25BEUZHR1tYWLz6xlDPnj0tLCw6d+7s5+cH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Xr16eXl5fffdd6NHj9Z9KiIigzZmDOLjAcDdHV99JXaa8u41Jid47733rl69+vDhQ92lISKiTZtw6BAASKXYtg329mIHKu9eowhjY2MByIWrOomISAdCQgruPj95Mtq3FzWNYXils0ZlMtmjR4+WLl1aqVIlb29vfWUjIjIsmZkYOBBZWQBQty6++ELsQIbhNc4arV279r59+zTOu0ZERG/vo49w9y4AWFlh925YWIgdyDC80lmjpqamnp6enp6eUk54TkSkG1u2YOtW1fi77+DrK2oaQ/KqZ40SEZHuhIRg0iTVePRojBwpahoD89wWXnp6+vLly0+dOvXiejdu3Fi+fHlUVJSechERGYzChwbr1MG334odyMA8t0W4evXqr7/+WuNEo7Vq1Ro0aNCjR482bdqkr2xERAZh0qSCQ4N79sDSUuxABua5LcJffvll7NixlSpVenE9c3PzTz75ZNeuXcXNQUpERG9g50789JNqvG4dDw2KoKAIs7OzHz58WMLRwdatW2dmZvKCeiIibXn0SDJ+vGo8ahTef1/UNIbquSJUKpWWxW+TW1lZAcgSdmMTEdHbycnB8OGm6ekAUKcO1q4VO5ChKihCOzs7MzOzR8KNkDURtgWdnZ31kYuIqLybPNno1i0JeGhQbAVFaGRk1KZNmw0bNhR3FHDt2rXVq1f38PDQVzYionLrhx+wdavqJ/DatTw0KKbnTpaZPXv29evXBwwYIEwrqpaamjpx4sSDBw9++umn+o1HRFQOnT1bcNXg++/jgw/EDEPPXT4REBCwatWq6dOnV6lSpVmzZl5eXkZGRpGRkRcuXMjKypo8efKYMWPECkpEVD6EhaFfPwiTdzVooPjuO87YJbKiM8tMnTrV399/5cqVx44dO3v2LABLS8vWrVtPmTKlW7duYiQkIio/MjLQuzcSEgDAyQl79+ZZWpqJHcrQaZhizd/ff9++fQDS0tLkcrmDg4PeUxERlUNKJcaMwa1bAGBqih078t3dlWKHomLmGhXY2trqLQcRUbn3v/9hzx7VeN06tG6t5A1eSwPumyYi0odff8WSJarx9On48ENR01AhLEIiIp27cQPvvw+lEgA6d8ayZWIHokJYhEREuhUXh169kJkJAD4+2L0bRkZiZ6JCWIRERDokk2HgQERGAoCDA/74A/b2Ymei57EIiYh0RanE2LE4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" /><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../classical_inversion/">« Classical inversion</a><a class="docs-footer-nextpage" href="../laws/">Laws »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 3 December 2025 12:01">Wednesday 3 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
