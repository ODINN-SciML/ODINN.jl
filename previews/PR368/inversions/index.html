<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inversion types · ODINN.jl</title><meta name="title" content="Inversion types · ODINN.jl"/><meta property="og:title" content="Inversion types · ODINN.jl"/><meta property="twitter:title" content="Inversion types · ODINN.jl"/><meta name="description" content="Documentation for ODINN.jl."/><meta property="og:description" content="Documentation for ODINN.jl."/><meta property="twitter:description" content="Documentation for ODINN.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../forward_simulation/">Forward simulation</a></li><li><a class="tocitem" href="../functional_inversion/">Functional inversion</a></li><li><a class="tocitem" href="../laws/">Laws</a></li></ul></li><li><span class="tocitem">How to use ODINN</span><ul><li><a class="tocitem" href="../parameters/">Parameters</a></li><li><a class="tocitem" href="../glaciers/">Glaciers</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../results_plotting/">Results and plotting</a></li><li><a class="tocitem" href="../api/">API</a></li></ul></li><li><span class="tocitem">Inversions</span><ul><li class="is-active"><a class="tocitem" href>Inversion types</a><ul class="internal"><li><a class="tocitem" href="#Classical-inversions"><span>Classical inversions</span></a></li><li><a class="tocitem" href="#Functional-inversions"><span>Functional inversions</span></a></li><li><a class="tocitem" href="#Logging"><span>Logging</span></a></li></ul></li><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity analysis</a></li></ul></li><li><a class="tocitem" href="../contribute/">How to contribute</a></li><li><a class="tocitem" href="../changes_plans/">Ongoing changes and future plans</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Inversions</a></li><li class="is-active"><a href>Inversion types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inversion types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/inversions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Inversion-types"><a class="docs-heading-anchor" href="#Inversion-types">Inversion types</a><a id="Inversion-types-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion-types" title="Permalink"></a></h1><p>In this section we present the main ideas behind the inversions. In data assimilation, one aims at calibrating a model such that the predictions match the observations. The observations can be either an initial state, a final state or observations over time. The first two are called steady state inversions while the last one corresponds to a transient inversion.</p><p>In the standard setting, inversions are made with respect to some quantity of interest that is involed in the iceflow equation, i.e. the mechanistic model. This can be for example the creep coefficient <span>$A$</span> for the Shallow Ice Approximation (SIA) like in [<a href="../references/#bolibar_universal_2023">2</a>]. This parameter can be constant for one glacier or vary with respect to space, in which case a spatial regularization is added to make the inversion problem well-posed.</p><p>Another way to invert a parameter in an iceflow equation is to parametrize the quantity of interest, let us say <span>$A$</span>, by other quantities which can be in the case of [<a href="../references/#bolibar_universal_2023">2</a>], the long term air temperature <span>$T$</span>. The optimized variable is not <span>$A$</span> but the parameters <span>$\theta$</span> and the mapping <span>$(T,\theta)\mapsto A(\theta,T)$</span> defines a parametrization of the ice rheology. We refer hereafter to this kind of inversion as a <em>functional inversion</em>, where the goal is to optimize the parameters of a regressor specifying a function, rather than directly optimizing parameters or coefficients of a mechanistic model.</p><p>We summarize the main differences between the two kind of inversions hereafter but first let us define the loss functions used in ODINN.</p><h2 id="Classical-inversions"><a class="docs-heading-anchor" href="#Classical-inversions">Classical inversions</a><a id="Classical-inversions-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-inversions" title="Permalink"></a></h2><p>We refer to classical inversions as the inverse problems where the objective is to directly invert the parameters <span>$p$</span> of a mechanistic model itself (e.g. the SIA equation). These type of inversions are handled in ODINN via the <code>Inversion</code> subtype of <code>Simulation</code>.  </p><p>The optimization problem is <span>$\min_p \mathcal{D}\left(\hat S, S \right) + \mathcal{R}\left( \hat S, p \right)$</span> where <span>$p$</span> is the vector of parameters to invert, for example <span>$p=[A]$</span>.</p><div class="admonition is-warning" id="Warning-3bbe39548d8f073c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3bbe39548d8f073c" title="Permalink"></a></header><div class="admonition-body"><p>This workflow is still under construction, since we&#39;re giving priority to functional inversions. We have an <a href="https://github.com/ODINN-SciML/ODINN.jl/pull/317">open issue</a> to track this and we will update the documentation here accordingly once this feature is added. </p></div></div><h2 id="Functional-inversions"><a class="docs-heading-anchor" href="#Functional-inversions">Functional inversions</a><a id="Functional-inversions-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-inversions" title="Permalink"></a></h2><p>We refer to functional inversions as the inverse problems where the objective is to invert the parameter <span>$\theta$</span> of a regressor (e.g. a neural network), in order to learn a function that parametrizes a subpart of a mechanistic model (e.g. the SIA) with respect to one or more input variables (e.g. surface melt, basal slope) [<a href="../references/#bolibar_universal_2023">2</a>]. The methods behind functional inversions are known as <strong>Universal Differential Equations</strong> [<a href="../references/#rackauckas_universal_2020">1</a>].</p><p>We present the concept of a functional inversion for the case where we want to learn a law for the ice rheology <span>$A$</span> in the Shallow Ice Approximation by using a neural network as a parametrization <span>$A=\text{NN}(\theta,T)$</span> with weights <span>$\theta$</span>. <span>$\begin{aligned}&amp; \min_\theta \mathcal{D}\left(\hat S, S \right) + \mathcal{R}\left( \hat S, p \right)\\
&amp; A=\text{NN}(\theta,T) \end{aligned}$</span></p><p><img src="../assets/overview_figure.png" alt="Overview of ODINN.jl’s workflow to perform functional inversions of glacier physical processes using Universal Differential Equations."/></p><blockquote><p><strong>Figure:</strong> Overview of <code>ODINN.jl</code>’s workflow to perform functional inversions of glacier physical processes using Universal Differential Equations. The parameters (<span>$θ$</span>) of a function determining a given physical process (<span>$D_θ$</span>), expressed by a neural network <span>$NN_θ$</span>, are optimized in order to minimize a loss function. In this example, the physical to be inferred law was constrained only by climate data, but any other proxies of interest can be used to design it. The climate data, and therefore the glacier mass balance, are downscaled (i.e. it depends on <span>$S$</span>), with <span>$S$</span> being updated by the solver, thus dynamically updating the state of the simulation for a given timestep.</p></blockquote><h3 id="Understanding-the-Laws-interface"><a class="docs-heading-anchor" href="#Understanding-the-Laws-interface">Understanding the <code>Law</code>s interface</a><a id="Understanding-the-Laws-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-the-Laws-interface" title="Permalink"></a></h3><p>In ODINN, in order to specify functional inversions, we have introduced a <code>Law</code> type which is responsible for linking a given regressor and a set of input variables to a target of a mechanistic model (for now the SIA). Here is a quick example on how this looks like:</p><pre><code class="language-julia hljs">law_inputs = (; CPDD=InpCPDD(), topo_roughness=InpTopoRough())
model = Huginn.Model(
    iceflow = SIA2Dmodel(params; C=SyntheticC(params; inputs=law_inputs)),
    mass_balance = nothing
)</code></pre><p>In this piece of code, we are selecting cumulative positive degree days (CPDDs) and topographical roughness as inputs for a law/parametrization named <code>SyntheticC</code>. Then, when declaring the ice flow model, we associate it to the parameter <code>C</code> of the iceflow model (i.e. the basal sliding). Using this simple interface, we can easily combine all sorts of input variables, with different laws and targets/subparts of mechanistic models.</p><div class="admonition is-warning" id="Warning-a5f41befb637a634"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a5f41befb637a634" title="Permalink"></a></header><div class="admonition-body"><p>It is important to bear in mind that new input types and laws cannot be created on the fly, they need to be specified/added by a user beforehand. For input variables, it is generally a matter of fetching the right data and processing it to the right format for the law/function. For laws, one just needs to specify which function is applied to the different input variables. If the law and input variables involve a regressor, then the new types for the law and inputs must be added to <code>ODINN.jl</code> <a href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/src/laws/Laws.jl">here</a>; if the law doesn&#39;t include any regressors, they can be added directly to <code>Huginn.jl</code> <a href="https://github.com/ODINN-SciML/Huginn.jl/blob/main/src/laws/Laws.jl">here</a>. </p></div></div><p>Here is an example of how the code of an input variable looks like:</p><pre><code class="language-julia hljs"># We first need to declare the type for the input variable, with any fields that might be needed
struct InpCPDD &lt;: AbstractInput
    window::Int
end

# Then we can specify a default name for that input
default_name(::InpCPDD) = :CPDD

# And then, using multiple dispatch, we specify the righ `get_input` function for this type, i.e. how to get it
function get_input(cpdd::InpCPDD, simulation, glacier_idx, t)
    window = cpdd.window
    glacier = simulation.glaciers[glacier_idx]
    # We trim only the time period between `t` and `t - x`, where `x` is the PDD time window defined in the physical parameters.
    period = (partial_year(Day, t) - Day(window)):Day(1):partial_year(Day, t)
    get_cumulative_climate!(glacier.climate, period)
    # Convert climate dataset to 2D based on the glacier&#39;s DEM
    climate_2D_step = downscale_2D_climate(glacier.climate.climate_step, glacier)

    return climate_2D_step.PDD
end</code></pre><p>The logic behind the <code>Law</code>s system is quite similar. Here is a simple example of a synthetic law made following this interface:</p><pre><code class="language-julia hljs">function SyntheticC(params::Sleipnir.Parameters; inputs = (; CPDD=InpCPDD()))
    C_synth_law = Law{Array{Float64, 2}}(;
        name = :SyntheticC,
        inputs = inputs,
        max_value = params.physical.maxC,
        min_value = params.physical.minC,
        f! = function (cache, inp, θ)
            # Nonlinear scaling using a sigmoid transformation
            # C = Cmin + (Cmax - Cmin) * sigmoid(β * (inp.CPDD)))
            # β controls the steepness of the sigmoid, ϵ avoids division by zero
            Cmin = params.physical.minC
            Cmax = params.physical.maxC
            β = 1.0      # Steepness parameter for sigmoid
            sigmoid = @. 1.0 / (1.0 + exp(-β * (inp.CPDD - 1.0)))  # Center sigmoid at x=1 for flexibility
            # If the provided C values are a matrix, reduce matrix size to match operations
            cache .= Cmin .+ (Cmax - Cmin) .* (isa(sigmoid, Matrix) ? inn1(sigmoid) : sigmoid)
        end,
        init_cache = function (simulation, glacier_idx, θ; scalar::Bool = false)
            # Initialize cache as a scalar or vector depending on the required output
            scalar ? zeros() : zeros(size(simulation.glaciers[glacier_idx].S) .- 1)
        end,
        callback_freq = 1/52,  # weekly frequency
    )
    return C_synth_law
end</code></pre><p>Declaring a <code>Law</code> implies creating a function which returns a specific type for that law. That custom type needs to specify (1) any necessary fields to be used (e.g. the <code>inputs</code>, its <code>name</code>...), (2) its associated function <code>f!</code>, i.e. what does the law do, (3) how the cache needs to be initialized for the law to interact with the simulation, and (4) the callback frequency <code>callback_freq</code>, which determines the time frequency on which the law will be called during the simulation (e.g. weekly). </p><p>Functional inversions in ODINN are handled by a <code>FunctionalInversion</code> subtype of <code>Simulation</code>.</p><h3 id="Functional-inversion-tutorial"><a class="docs-heading-anchor" href="#Functional-inversion-tutorial">Functional inversion tutorial</a><a id="Functional-inversion-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-inversion-tutorial" title="Permalink"></a></h3><p>The <a href="../functional_inversion/">functional inversion tutorial</a> gives an example of how such an inversion can be run in practice with <code>ODINN.jl</code>.</p><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><p><code>ODINN.jl</code> provides useful statistics, such as the training loss history or the parameters history in the inversion objects. The training statistics can also be inspected with <a href="https://www.tensorflow.org/tensorboard">TensorBoard</a> through VSCode or a local webserver. You can either use the <a href="https://marketplace.visualstudio.com/items?itemName=ms-toolsai.tensorboard">TensorBoard VSCode extension</a> or simply install TensorBoard in a Python environment and then launch <code>tensorboard --logdir .logs/</code>.</p><p>By default the TensorBoard logs are stored in your ODINN folder in <code>ODINN/.logs/</code> but you may have to adapt the command above if you log in a different folder.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../optimization/">Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 20 August 2025 15:04">Wednesday 20 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
