var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is an exhaustive list of all the types and functions in ODINN.jl, Huginn.jl, Muninn.jl and Sleipnir.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [ODINN, Huginn, Muninn, Sleipnir]\nOrder = [:type, :function]","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"EditURL = \"tutorials.jl\"","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this section, we present some tutorials to showcase the basic use of ODINN.jl","category":"page"},{"location":"tutorials/#Forward-simulation-tutorial","page":"Tutorials","title":"Forward simulation tutorial","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Revise\nusing ODINN\n\n# Define the working directory\nworking_dir = joinpath(homedir(), \"ODINN_simulations\")\n\n# Ensure the working directory exists\nmkpath(working_dir)\n\n# Define which glacier RGI IDs we want to work with\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()\n# Filter out glaciers that are not used to avoid having references that depend on all the glaciers processed in Gungnir\nrgi_paths = Dict(k => rgi_paths[k] for k in rgi_ids)\n\n# Create the necessary parameters\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n\t\tmultiprocessing = false,\n        #workers = 5,\n\t\trgi_paths = rgi_paths\n    )\n)\n\n# Specify a model based on an iceflow model, a mass balance model, and a machine learning model\nmodel = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),\n\tmachine_learning = nothing\n)\n\n# We initialize the glaciers with all the necessary data\nglaciers = initialize_glaciers(rgi_ids, params)\n\n# We specify the type of simulation we want to perform\nprediction = Prediction(model, glaciers, params)\n\n# And finally, we just run the simulation\nHuginn.run!(prediction)\n\n# Then we can visualize the results of the simulation, e.g. the difference in ice thickness between 2010 to 2015 for Argentière glacier\npdiff = plot_glacier(prediction.results[1], \"evolution difference\", [:H]; metrics=[\"difference\"])","category":"page"},{"location":"tutorials/#Step-by-step-explanation-of-the-tutorial","page":"Tutorials","title":"Step-by-step explanation of the tutorial","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here we will cover in detail each one of the steps that lead us to run the Prediction from the previous example (i.e. a forward run). This first tutorial keeps things simple, and since we are not using machine learning models, we will only use the Model type to specify the iceflow and mass balance models. These functionalities are mainly covered by Huginn.jl.","category":"page"},{"location":"tutorials/#Step-1:-Parameter-initialization","page":"Tutorials","title":"Step 1: Parameter initialization","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The first step is to initialize and specify all the necessary parameters. In ODINN.jl we have many different types of parameters, specifying different aspects of the model. All the parameter types come with a default constructor, which will provide default values in case you don't want to tune those. The main types of parameters are:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Simulation parameters: SimulationParameters includes all the parameters related to the                            ODINN.jl simulation, including the number of workers, the timespan                             of the simulation or the working directory.\nHyperparameters: Hyperparameters includes all the necessary hyperparameters for a machine learning model.\nUDEparameters: UDEparameters contains the parameters related to the training of a Universal Differential Equation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"All these sub-types of parameters are held in a Parameters struct, a general parameters structure to be passed to an ODINN simulation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"First we need to specify a list of RGI IDs of the glacier we want to work with. Specifying an RGI region is also possible. From these RGI IDs, we will look for the necessary files inside the workspace.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"rgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Filter out glaciers that are not used to avoid having references that depend on all the glaciers processed in Gungnir","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"rgi_paths = Dict(k => rgi_paths[k] for k in rgi_ids)\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n\t\tmultiprocessing = false,\n        #workers = 5,\n\t\trgi_paths = rgi_paths\n    )\n)","category":"page"},{"location":"tutorials/#Step-2:-Model-specification","page":"Tutorials","title":"Step 2: Model specification","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The next step is to specify which model(s) we want to use for our simulation. In ODINN we have three different types of model, which are encompassed in a Model structure:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Iceflow model: IceflowModel is the ice flow dynamics model that will be used to simulate                     iceflow. It defaults to a 2D Shallow Ice Approximation.\nSurface mass balance model: MassBalanceModel is the mass balance model that will be used for                             simulations. Options here include temperature-index models, or                             machine learning models coming from MassBalanceMachine.\nMachine learning model: MLmodel is the machine learning model (e.g. a neural network) which will                             be used as part of a hybrid model based on a Universal Differential Equation.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Generally, a model can be initialized directly using the Model constructor:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"model = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    machine_learning = nothing\n)","category":"page"},{"location":"tutorials/#Step-3:-Glacier-initialization","page":"Tutorials","title":"Step 3: Glacier initialization","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The third step is to fetch and initialize all the necessary data for our glaciers of interest. This is strongly built on top of OGGM, mostly providing a Julia interface to automatize this. The package Gungnir is used to fetch the necessary data from the RGI and other sources. The data is then stored in servers and fetched and read using Rasters.jl directly by Sleipnir.jl when needed.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Then, we initialize those glaciers based on those RGI IDs and the parameters we previously specified.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"glaciers = initialize_glaciers(rgi_ids, params)","category":"page"},{"location":"tutorials/#Step-4:-Creating-and-running-a-simulation","page":"Tutorials","title":"Step 4: Creating and running a simulation","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The final step of the pipeline, is to create an ODINN simulation based on all the previous steps, and then to run it. There are different types of simulations that we can do with ODINN:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Prediction: This is a forward simulation, where the initial glacier conditions are run forward in                 in time based on specified parameters and climate data.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This is as simple as doing:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"prediction = Prediction(model, glaciers, params)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"And once we have the Prediction object, we can run it using Huginn.run!:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Huginn.run!(prediction)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There we go, we have successfully simulated the evolution of 3 glaciers for 5 years in around 1-2 seconds!","category":"page"},{"location":"tutorials/#Step-5:-Visualizing-the-results","page":"Tutorials","title":"Step 5: Visualizing the results","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"# Finally, we can use the plotting functions of `ODINN.jl` to visualize the results of the simulation. Like the glacier ice thickness evolution\nplot_glacier(prediction.results[1], \"evolution difference\", [:H]; metrics=[\"difference\"])","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Or the initial glacier ice thickness and the resulting ice surface velocities","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"plot_glacier(prediction.results[1], \"heatmaps\", [:H, :V])","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ODINN.jl-documentation","page":"Home","title":"ODINN.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the ODINN.jl documentation, a large-scale scientific machine learning (SciML) glacier model, leveraging differentiable programming in Julia. This documentation provides the necessary information to understand the ecosystem built around `ODINN.jl, its APIs, workflows and some examples of the main usage types of the model(s).","category":"page"},{"location":"#Vision","page":"Home","title":"Vision","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rather than focusing on global-scale simulations and sea-level rise contributions, ODINN.jl has, for now, a regional and catchment-scale focus, aiming to exploit the latest remote sensing and in situ observations to capture missing or subgrid processes of glacier processes. In order to do so, ODINN.jl leverages Universal Differential Equations (UDEs), combining PDEs describing ice flow dynamics with data-driven regressors, such as neural networks. For this, ODINN.jl relies heavily on the SciML Julia ecosytem and the native automatic differentiation (AD) support. Therefore ODINN.jl has a two-fold goal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"To advance the application of scientific machine learning and differentiable programming for large-scale geoscientific modelling.\nTo advance the inference of new parametrizations to characterize key missing or subgrid processes of glaciers to improve large-scale glacier simulations. ","category":"page"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ODINN.jl is a modular model, split into multiple packages, each one handling a specific task:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./assets/ODINN_architecture.png\" alt=\"ODINN ecosystem overview\" width=\"500\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"ODINN.j is the high-level interace to the whole ODINN ecosystem, containing the SciML functionalities related to automatic differentiation and sensitivity of hybrid models, mixing differential equations and data-driver regressors. \nHuginn.jl is the ice flow dynamics module of ODINN. It contains all the information regarding glacier ice flow models, including the numerical methods to solve the PDEs using OrdinaryDiffEq.jl. \nMuninn.jl is the surface mass balance module of ODINN. It  contains all the information regarding glacier interactions with the atmosphere (i.e. surface mass balance processes). For now we support simple temperature-index models, but soon we are planning to incorporate machine learning models coming from the MassBalanceMachine. \nSleipnir.jl is the core package of ODINN, holding all the basic data structures and functions, common to the whole ecosystem. It directly reads the files provided by Gungnir. \nGungnir is a Python package, using OGGM to retrieve all the necessary files (i.e. rasters and climate data) for the initial conditions and simulations in all the ODINN ecosystem. The user has the possibility to either store those files locally, or to use the ones we provide in a server. This is work in progress, so we will progressively cover more and more glaciers and regions in the near future. ","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ODINN.jl is being developed by Jordi Bolibar (CNRS, IGE), Facundo Sapienza (Stanford University) and Alban Gossard (Université Grenoble Alpes, IGE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Past developers include Lucille Gimenes (Université Grenoble Alpes, IGE) and Vivek Gajadhar (TU Delft).","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ODINN.jl for research, teaching or other activities, please use the following citation from our latest paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{bolibar_sapienza_universal_2023,\n\ttitle = {Universal differential equations for glacier ice flow modelling},\n\tauthor = {Bolibar, J. and Sapienza, F. and Maussion, F. and Lguensat, R. and Wouters, B. and P\\'erez, F.},\n\tjournal = {Geoscientific Model Development},\n\tvolume = {16},\n\tyear = {2023},\n\tnumber = {22},\n\tpages = {6671--6687},\n\turl = {https://gmd.copernicus.org/articles/16/6671/2023/},\n\tdoi = {10.5194/gmd-16-6671-2023}\n}","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ODINN project has been funded by an IRGA fellowship from the Multidisciplinary Institute on Artificial Intelligence (Grenoble, France), the Nederlandse Organisatie voor Wetenschappelijk Onderzoek, Stichting voor de Technische Wetenschappen (Vidi grant 016.Vidi.171.063), the National Science Foundation (EarthCube programme under awards 1928406 and 1928374) and a TU Delft Climate Action grant. ","category":"page"},{"location":"funcs_types/#Types-and-functions","page":"Types and functions","title":"Types and functions","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"In this page, we will go through the main types (i.e. structs) used in ODINN.jl's architecture, and the main functions linked to those types.","category":"page"},{"location":"funcs_types/#Parameters","page":"Types and functions","title":"Parameters","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"There are different types of parameters, holding specific information for different modelling aspects. All the types of parameters are wrapped into a Parameter type, which is threaded throughout ODINN.jl. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.Parameters\nODINN.Parameters","category":"page"},{"location":"funcs_types/#Sleipnir.Parameters","page":"Types and functions","title":"Sleipnir.Parameters","text":"    mutable struct Parameters{PPHY <: AbstractEmptyParams, PSIM <: AbstractEmptyParams, PHY <: AbstractEmptyParams,\n                    PSOL <: AbstractEmptyParams, PUDE <: AbstractEmptyParams, PINV <: AbstractEmptyParams}\n\nA mutable struct that holds various parameter sets for different aspects of a simulation or model.\n\nFields\n\nphysical::PPHY: Physical parameters.\nsimulation::PSIM: Simulation parameters.\nhyper::PHY: Hyperparameters.\nsolver::PSOL: Solver parameters.\nUDE::PUDE: Universal Differential Equation (UDE) parameters.\ninversion::PINV: Inversion parameters.\n\nType Parameters\n\nPPHY: Type of the physical parameters, must be a subtype of AbstractEmptyParams.\nPSIM: Type of the simulation parameters, must be a subtype of AbstractEmptyParams.\nPHY: Type of the hyperparameters, must be a subtype of AbstractEmptyParams.\nPSOL: Type of the solver parameters, must be a subtype of AbstractEmptyParams.\nPUDE: Type of the UDE parameters, must be a subtype of AbstractEmptyParams.\nPINV: Type of the inversion parameters, must be a subtype of AbstractEmptyParams.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.Parameters","page":"Types and functions","title":"ODINN.Parameters","text":"Constructor for the Parameters type. Since some of the subtypes of parameters are defined in different packages of the ODINN ecosystem, this constructor will call the constructors of the different subtypes and return a Parameters object with the corresponding subtypes.  The Parameters mutable struct is defined in Sleipnir.jl using abstract types, which are later on defined in the different packages of the ODINN ecosystem.\n\nParameters(;\n        physical::PhysicalParameters = PhysicalParameters(),\n        simulation::SimulationParameters = SimulationParameters(),\n        solver::SolverParameters = SolverParameters(),\n        hyper::Hyperparameters = Hyperparameters(),\n        UDE::UDEparameters = UDEparameters()\n        inversion::InversionParameters = InversionParameters()\n        )\n\nKeyword arguments\n\nphysical::PhysicalParameters: Physical parameters for the simulation.\nsimulation::SimulationParameters: Parameters related to the simulation setup.\nsolver::SolverParameters: Parameters for the solver configuration.\nhyper::Hyperparameters: Hyperparameters for the model.\nUDE::UDEparameters: Parameters specific to the UDE (Universal Differential Equation).\ninversion::InversionParameters: Parameters for inversion processes.\n\n\n\n\n\n","category":"function"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"The main types of parameters are the following ones:","category":"page"},{"location":"funcs_types/#Simulation-parameters","page":"Types and functions","title":"Simulation parameters","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Simulation parameters are used to specify anything related to ODINN simulations, ranging from types, working directories to multiprocessing.","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.SimulationParameters\nSleipnir.SimulationParameters()","category":"page"},{"location":"funcs_types/#Sleipnir.SimulationParameters","page":"Types and functions","title":"Sleipnir.SimulationParameters","text":"A structure to hold simulation parameters for a simulation in ODINN.\n\nstruct SimulationParameters{I <: Integer, F <: AbstractFloat} <: AbstractParameters\n\nFields\n\nuse_MB::Bool: Flag to indicate whether mass balance should be used.\nuse_iceflow::Bool: Flag to indicate whether ice flow should be used.\nplots::Bool: Flag to indicate whether plots should be generated.\nvelocities::Bool: Flag to indicate whether velocities should be calculated.\noverwrite_climate::Bool: Flag to indicate whether to overwrite climate data.\nuse_glathida_data::Bool: Flag to indicate whether to use GLATHIDA data.\nfloat_type::DataType: Data type for floating-point numbers.\nint_type::DataType: Data type for integer numbers.\ntspan::Tuple{F, F}: Time span for the simulation.\nstep::F: Time step for the simulation.\nmultiprocessing::Bool: Flag to indicate whether multiprocessing should be used.\nworkers::I: Number of workers for multiprocessing.\nworking_dir::String: Directory for working files.\ntest_mode::Bool: Flag to indicate whether to run in test mode.\nrgi_paths::Dict{String, String}: Dictionary of RGI paths.\nice_thickness_source::String: Source of ice thickness data.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Sleipnir.SimulationParameters-Tuple{}","page":"Types and functions","title":"Sleipnir.SimulationParameters","text":"Constructor for SimulationParameters type, including default values.\n\nSimulationParameters(; use_MB::Bool = true,\n                      use_iceflow::Bool = true,\n                      plots::Bool = true,\n                      velocities::Bool = true,\n                      overwrite_climate::Bool = false,\n                      use_glathida_data::Bool = false,\n                      float_type::DataType = Float64,\n                      int_type::DataType = Int64,\n                      tspan::Tuple{F, F} = (2010.0, 2015.0),\n                      step::F = 1/12,\n                      multiprocessing::Bool = true,\n                      workers::I = 4,\n                      working_dir::String = \"\",\n                      test_mode::Bool = false,\n                      rgi_paths::Dict{String, String} = Dict{String, String}(),\n                      ice_thickness_source::String = \"Farinotti19\") where {I <: Integer, F <: AbstractFloat}\n\nKeyword arguments\n\nuse_MB::Bool: Whether to use mass balance (default: true).\nuse_iceflow::Bool: Whether to use ice flow (default: true).\nplots::Bool: Whether to generate plots (default: true).\nvelocities::Bool: Whether to calculate velocities (default: true).\noverwrite_climate::Bool: Whether to overwrite climate data (default: false).\nuse_glathida_data::Bool: Whether to use GLATHIDA data (default: false).\nfloat_type::DataType: Data type for floating point numbers (default: Float64).\nint_type::DataType: Data type for integers (default: Int64).\ntspan::Tuple{F, F}: Time span for the simulation (default: (2010.0, 2015.0)).\nstep::F: Time step for the simulation (default: 1/12).\nmultiprocessing::Bool: Whether to use multiprocessing (default: true).\nworkers::I: Number of workers for multiprocessing (default: 4).\nworking_dir::String: Working directory for the simulation (default: \"\").\ntest_mode::Bool: Whether to run in test mode (default: false).\nrgi_paths::Dict{String, String}: Dictionary of RGI paths (default: Dict{String, String}()).\nice_thickness_source::String: Source of ice thickness data, either \"Millan22\" or \"Farinotti19\" (default: \"Farinotti19\").\n\nReturns\n\nsimulation_parameters: A new SimulationParameters object.\n\nThrows\n\nAssertionError: If ice_thickness_source is not \"Millan22\" or \"Farinotti19\".\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Physical-parameters","page":"Types and functions","title":"Physical parameters","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Physical parameters are used to store physical constants used in the physical and machine learning models. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.PhysicalParameters\nSleipnir.PhysicalParameters()","category":"page"},{"location":"funcs_types/#Sleipnir.PhysicalParameters","page":"Types and functions","title":"Sleipnir.PhysicalParameters","text":"A structure representing physical parameters used in simulations.\n\nPhysicalParameters{F <: AbstractFloat}\n\nFields\n\nρ::F: Density of ice.\ng::F: Gravitational acceleration.\nϵ::F: A small parameter, often used for perturbations.\nη₀::F: Initial viscosity.\nmaxA::F: Maximum A.\nminA::F: Minimum A.\nmaxTlaw::F: Maximum temperature according to some law.\nminTlaw::F: Minimum temperature according to some law.\nnoise_A_magnitude::F: Magnitude of noise in A.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Sleipnir.PhysicalParameters-Tuple{}","page":"Types and functions","title":"Sleipnir.PhysicalParameters","text":"Initialize the physical parameters of a model.\n\nPhysicalParameters(;\n    ρ::Float64 = 900.0,\n    g::Float64 = 9.81,\n    ϵ::Float64 = 1e-3,\n    η₀::F = 1.0, \n    maxA::Float64 = 8e-17,\n    minA::Float64 = 8.5e-20,\n    maxTlaw::Float64 = 1.0,\n    minTlaw::Float64 = -25.0,\n    noise_A_magnitude::Float64 = 5e-18\n    )\n\nKeyword arguments\n\n- `ρ`: Ice density\n- `g`: Gravitational constant\n- `ϵ`: Small number\n- `η₀`:  \n- `maxA`: Maximum value for `A` (Glen's coefficient)\n- `minA`: Minimum value for `A` (Glen's coefficient)\n- `maxTlaw`: Maximum value of Temperature used in simulations on fake law\n- `minTlaw`: Minimum value of Temperature used in simulations on fake law\n- `noise_A_magnitude`: Magnitude of noise added to A\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Solver-parameters","page":"Types and functions","title":"Solver parameters","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Solver parameters determine all aspects related to the numerical scheme used to solve the differential equations of glacier ice flow.","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Huginn.SolverParameters\nHuginn.SolverParameters()","category":"page"},{"location":"funcs_types/#Huginn.SolverParameters","page":"Types and functions","title":"Huginn.SolverParameters","text":"A mutable struct that holds parameters for the solver.\n\nSolverParameters{F <: AbstractFloat, I <: Integer}\n\nFields\n\nsolver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm: The algorithm used for solving differential equations.\nreltol::F: The relative tolerance for the solver.\nstep::F: The step size for the solver.\ntstops::Union{Nothing, Vector{F}}: Optional vector of time points where the solver should stop for the callbacks.\nsave_everystep::Bool: Flag indicating whether to save the solution at every step.\nprogress::Bool: Flag indicating whether to show progress during the solving process.\nprogress_steps::I: The number of steps between progress updates.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Huginn.SolverParameters-Tuple{}","page":"Types and functions","title":"Huginn.SolverParameters","text":"Constructs a SolverParameters object with the specified parameters or using default values.\n\nSolverParameters(; solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),\n                  reltol::F = 1e-12,\n                  step::F = 1.0/12.0,\n                  tstops::Union{Nothing,Vector{F}} = nothing,\n                  save_everystep = false,\n                  progress::Bool = true,\n                  progress_steps::I = 10) where {F <: AbstractFloat, I <: Integer}\n\nArguments\n\nsolver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm: The ODE solver algorithm to use. Defaults to RDPK3Sp35().\nreltol::F: The relative tolerance for the solver. Defaults to 1e-12.\nstep::F: The step size for the callbacks. These are mainly used to run the surface mass balance model. Defaults to 1.0/12.0 (i.e. a month).\ntstops::Union{Nothing, Vector{F}}: Optional vector of time points where the solver should stop. Defaults to nothing.\nsave_everystep::Bool: Whether to save the solution at every step. Defaults to false.\nprogress::Bool: Whether to show progress during the solving process. Defaults to true.\nprogress_steps::I: The number of steps between progress updates. Defaults to 10.\n\nReturns\n\nsolver_parameters: A SolverParameters object constructed with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Hyperparameters","page":"Types and functions","title":"Hyperparameters","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Hyperparameters determine different aspects of a given machine learning model. For now, these are focused on neural networks, but we plan to extend them in the future for other types of regressors. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"ODINN.Hyperparameters\nODINN.Hyperparameters()","category":"page"},{"location":"funcs_types/#ODINN.Hyperparameters","page":"Types and functions","title":"ODINN.Hyperparameters","text":"mutable struct Hyperparameters{F <: AbstractFloat, I <: Int} <: AbstractParameters\n\nA mutable struct that holds hyperparameters for training a machine learning model.\n\nKeyword arguments\n\ncurrent_epoch::I: The current epoch number.\ncurrent_minibatch::I: The current minibatch number.\nloss_history::Vector{F}: A vector storing the history of loss values.\noptimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}: The optimizer used for training.\nloss_epoch::F: The loss value for the current epoch.\nepochs::I: The total number of epochs for training.\nbatch_size::I: The size of each minibatch.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.Hyperparameters-Tuple{}","page":"Types and functions","title":"ODINN.Hyperparameters","text":"Hyperparameters(; current_epoch::Int64 = 1, current_minibatch::Int64 = 1, loss_history::Vector{Float64} = Vector{Float64}(), optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule} = BFGS(initial_stepnorm=0.001), loss_epoch::Float64 = 0.0, epochs::Int64 = 50, batch_size::Int64 = 15)\n\nConstructs a Hyperparameters object with the specified parameters.\n\nArguments\n\ncurrent_epoch::Int64: The current epoch number. Defaults to 1.\ncurrent_minibatch::Int64: The current minibatch number. Defaults to 1.\nloss_history::Vector{Float64}: A vector to store the history of loss values. Defaults to an empty vector.\noptimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}: The optimizer to be used. Defaults to BFGS(initial_stepnorm=0.001).\nloss_epoch::Float64: The loss value for the current epoch. Defaults to 0.0.\nepochs::Int64: The total number of epochs. Defaults to 50.\nbatch_size::Int64: The size of each minibatch. Defaults to 15.\n\nReturns\n\nA Hyperparameters object initialized with the provided values.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#UDE-parameters","page":"Types and functions","title":"UDE parameters","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Universal Differential Equation (UDE) parameters are used to determine different modelling choices regarding the use of UDEs, such as wich sensitivity algorithm to use, which target (e.g. SIA parameter to target), or which optimization method to use.","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"ODINN.UDEparameters\nODINN.UDEparameters()","category":"page"},{"location":"funcs_types/#ODINN.UDEparameters","page":"Types and functions","title":"ODINN.UDEparameters","text":"A mutable struct that holds parameters for a UDE (Universal Differential Equation).\n\nUDEparameters{ADJ <: AbstractAdjointMethod} <: AbstractParameters\n\nFields\n\nsensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm: The sensitivity algorithm used for adjoint sensitivity analysis.\noptimization_method::String: The optimization method to be used.\nloss_type::String: The type of loss function to be used.\nscale_loss::Bool: A boolean indicating whether to scale the loss.\ntarget::String: The target variable for the optimization.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.UDEparameters-Tuple{}","page":"Types and functions","title":"ODINN.UDEparameters","text":"UDEparameters(; sensealg, optim_autoAD, grad, optimization_method, loss_type, empirical_loss_function, scale_loss, target) where {ADJ <: AbstractAdjointMethod}\n\nCreate a UDEparameters object for configuring the sensitivity analysis and optimization of a Universal Differential Equation (UDE).\n\nKeyword Arguments\n\nsensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm: The sensitivity algorithm to use for adjoint calculations. Defaults to GaussAdjoint(autojacvec=SciMLSensitivity.EnzymeVJP()).\noptim_autoAD::AbstractADType: The automatic differentiation type for optimization. Defaults to Optimization.AutoEnzyme().\ngrad::ADJ: The adjoint gradient computation method. Defaults to SciMLSensitivityAdjoint().\noptimization_method::String: The optimization method to use. Must be either \"AD+AD\" or \"AD+Diff\". Defaults to \"AD+AD\".\nloss_type::String: The type of loss function to use. Must be either \"V\" (velocity) or \"H\" (thickness). Defaults to \"V\".\nempirical_loss_function::AbstractLoss: The loss function to use for optimization. Defaults to L2Sum().\nscale_loss::Bool: Whether to scale the loss function. Defaults to true.\ntarget::Union{String, Nothing}: The target variable for optimization. Defaults to \"D\".\n\nReturns\n\nA UDEparameters object configured with the specified sensitivity, optimization, and loss settings.\n\nDescription\n\nThis function creates a UDEparameters object that encapsulates the configuration for sensitivity analysis, optimization, and loss computation in a Universal Differential Equation (UDE) framework. It verifies that the provided optimization_method and loss_type are valid and constructs the solver parameters accordingly.\n\nNotes\n\nThe optimization_method must be either \"AD+AD\" (automatic differentiation for both forward and backward passes) or \"AD+Diff\" (automatic differentiation combined with finite differences).\nThe loss_type must be either \"V\" (velocity-based loss) or \"H\" (thickness-based loss).\nThe empirical_loss_function determines how the loss is computed during optimization.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Glaciers","page":"Types and functions","title":"Glaciers","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Glaciers in ODINN.jl are represented by a Glacier type. Each glacier has its related Climate type. Since ODINN.jl supports different types of simulations, we offer the possibility to work on 1D (i.e. flowline), 2D (e.g. SIA) or even 3D (not yet implemented, e.g. Full Stokes).","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.Glacier2D\nSleipnir.Glacier2D()","category":"page"},{"location":"funcs_types/#Sleipnir.Glacier2D","page":"Types and functions","title":"Sleipnir.Glacier2D","text":"A mutable struct representing a 2D glacier. Notice that all fields can be empty by providing nothing as the default value. \n\n/!\\ WARNING /!\\ Glacier objects should not be constructed  manually, but rather through the initialize_glaciers function.\n\nGlacier2D{F <: AbstractFloat, I <: Integer}\n\nFields\n\nrgi_id::Union{String, Nothing}: The RGI (Randolph Glacier Inventory) identifier for the glacier.\nclimate::Union{Climate2D, Nothing}: The climate data associated with the glacier.\nH₀::Union{Matrix{F}, Nothing}: Initial ice thickness matrix.\nH_glathida::Union{Matrix{F}, Nothing}: Ice thickness matrix from the GLATHIDA dataset.\nS::Union{Matrix{F}, Nothing}: Surface elevation matrix.\nB::Union{Matrix{F}, Nothing}: Bedrock elevation matrix.\nV::Union{Matrix{F}, Nothing}: Ice velocity magnitude matrix.\nVx::Union{Matrix{F}, Nothing}: Ice velocity in the x-direction matrix.\nVy::Union{Matrix{F}, Nothing}: Ice velocity in the y-direction matrix.\nA::Union{F, Nothing}: Flow law parameter.\nC::Union{F, Nothing}: Sliding law parameter.\nn::Union{F, Nothing}: Flow law exponent.\nslope::Union{Matrix{F}, Nothing}: Surface slope matrix.\ndist_border::Union{Matrix{F}, Nothing}: Distance to the glacier border matrix.\nCoords::Union{Dict{String, Vector{Float64}}, Nothing}: Coordinates dictionary with keys as coordinate names and values as vectors of coordinates.\nΔx::Union{F, Nothing}: Grid spacing in the x-direction.\nΔy::Union{F, Nothing}: Grid spacing in the y-direction.\nnx::Union{I, Nothing}: Number of grid points in the x-direction.\nny::Union{I, Nothing}: Number of grid points in the y-direction.\ncenlon::Union{F, Nothing}: Longitude of the glacier center.\ncenlat::Union{F, Nothing}: Latitude of the glacier center.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Sleipnir.Glacier2D-Tuple{}","page":"Types and functions","title":"Sleipnir.Glacier2D","text":"Constructs a Glacier2D object with the given parameters, including default ones.\n\nGlacier2D(; rgi_id::Union{String, Nothing} = nothing,\n          climate::Union{Climate2D, Nothing} = nothing,\n          H₀::Union{Matrix{F}, Nothing} = nothing,\n          H_glathida::Union{Matrix{F}, Nothing} = nothing,\n          S::Union{Matrix{F}, Nothing} = nothing,\n          B::Union{Matrix{F}, Nothing} = nothing,\n          V::Union{Matrix{F}, Nothing} = nothing,\n          Vx::Union{Matrix{F}, Nothing} = nothing,\n          Vy::Union{Matrix{F}, Nothing} = nothing,\n          A::Union{F, Nothing} = nothing,\n          C::Union{F, Nothing} = nothing,\n          n::Union{F, Nothing} = nothing,\n          slope::Union{Matrix{F}, Nothing} = nothing,\n          dist_border::Union{Matrix{F}, Nothing} = nothing,\n          Coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,\n          Δx::Union{F, Nothing} = nothing,\n          Δy::Union{F, Nothing} = nothing,\n          nx::Union{I, Nothing} = nothing,\n          ny::Union{I, Nothing} = nothing,\n          cenlon::Union{F, Nothing} = nothing,\n          cenlat::Union{F, Nothing} = nothing) where {F <: AbstractFloat, I <: Integer}\n\nArguments\n\nrgi_id::Union{String, Nothing}: The RGI identifier for the glacier.\nclimate::Union{Climate2D, Nothing}: The climate data associated with the glacier.\nH₀::Union{Matrix{F}, Nothing}: Initial ice thickness matrix.\nH_glathida::Union{Matrix{F}, Nothing}: Ice thickness matrix from GLATHIDA.\nS::Union{Matrix{F}, Nothing}: Surface elevation matrix.\nB::Union{Matrix{F}, Nothing}: Bed elevation matrix.\nV::Union{Matrix{F}, Nothing}: Ice velocity magnitude matrix.\nVx::Union{Matrix{F}, Nothing}: Ice velocity in the x-direction matrix.\nVy::Union{Matrix{F}, Nothing}: Ice velocity in the y-direction matrix.\nA::Union{F, Nothing}: Flow law parameter.\nC::Union{F, Nothing}: Sliding law parameter.\nn::Union{F, Nothing}: Flow law exponent.\nslope::Union{Matrix{F}, Nothing}: Slope matrix.\ndist_border::Union{Matrix{F}, Nothing}: Distance to border matrix.\nCoords::Union{Dict{String, Vector{Float64}}, Nothing}: Coordinates dictionary with keys \"lon\" and \"lat\".\nΔx::Union{F, Nothing}: Grid spacing in the x-direction.\nΔy::Union{F, Nothing}: Grid spacing in the y-direction.\nnx::Union{I, Nothing}: Number of grid points in the x-direction.\nny::Union{I, Nothing}: Number of grid points in the y-direction.\ncenlon::Union{F, Nothing}: Central longitude of the glacier.\ncenlat::Union{F, Nothing}: Central latitude of the glacier.\n\nReturns\n\nA Glacier2D object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Every glacier has its associated climate, following the same spatial representation (e.g. 2D):","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.Climate2D","category":"page"},{"location":"funcs_types/#Sleipnir.Climate2D","page":"Types and functions","title":"Sleipnir.Climate2D","text":"A mutable struct representing a 2D climate for a glacier with various buffers and datasets.\n\nClimate2D{F <: AbstractFloat}\n\nKeyword arguments\n\nraw_climate::RasterStack: Raw climate dataset for the whole simulation.\nclimate_raw_step::RasterStack: Raw climate trimmed for the current step to avoid memory allocations.\nclimate_step::Dict: Climate data for the current step.\nclimate_2D_step::Climate2Dstep: 2D climate data for the current step to feed to the mass balance (MB) model.\nlongterm_temps::Vector{F}: Long-term temperatures for the ice rheology.\navg_temps::F: Intermediate buffer for computing average temperatures.\navg_gradients::F: Intermediate buffer for computing average gradients.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"In order to create Glacier types with information of a given glacier for a simulation, one can initialize a list of glaciers based on RGI (Randolph Glacier Inventory) IDs. Before running this, make sure to have used Gungnir to download all the necessary data for those glaciers, or double check that these glaciers are already available on the ODINN server. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.initialize_glaciers","category":"page"},{"location":"funcs_types/#Sleipnir.initialize_glaciers","page":"Types and functions","title":"Sleipnir.initialize_glaciers","text":"initialize_glaciers(rgi_ids::Vector{String}, params::Parameters)\n\nInitialize glaciers based on provided RGI IDs and parameters.\n\nArguments\n\nrgi_ids::Vector{String}: A vector of RGI IDs representing the glaciers to be initialized.\nparams::Parameters: A Parameters object containing simulation parameters.\ntest::Bool: An optional boolean flag indicating whether to run in test mode. Default is false.\n\nReturns\n\nglaciers::Vector{Glacier2D}: A vector of initialized Glacier2D objects.\n\nDescription\n\nThis function performs the following steps:\n\nGenerates a file for missing glaciers if it does not already exist.\nFilters out missing glaciers from the provided RGI IDs.\nGenerates raw climate data for the glaciers if necessary.\nInitializes the glaciers using the provided RGI IDs and parameters.\nIf use_glathida_data is enabled in the simulation parameters, assigns GlaThiDa data to the glaciers.\n\nErrors\n\nThrows an error if none of the provided RGI IDs have GlaThiDa data.\n\nWarnings\n\nIssues a warning if not all glaciers have GlaThiDa data available.\n\nExample\n\n# We declare a list of glaciers to be initialized with their RGI IDs\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\n# We initialize those glaciers based on the RGI IDs and the parameters we previously specified\nglaciers = initialize_glaciers(rgi_ids, params)\n\n\n\n\n\n","category":"function"},{"location":"funcs_types/#Models","page":"Types and functions","title":"Models","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"There are 3 main types of models in ODINN.jl, iceflow models, mass balance models and machine learning models. These three families are determined by abstract types, with specific types being declared as subtypes of these abstract types to ensure compatibility through the ODINN ecosystem. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"The three main types of models are gathered in a type Model in the following way:","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"ODINN.Model\nODINN.Model()","category":"page"},{"location":"funcs_types/#ODINN.Model","page":"Types and functions","title":"ODINN.Model","text":"Model(; iceflow::Union{IFM, Vector{IFM}, Nothing}, mass_balance::Union{MBM, Vector{MBM}, Nothing}, machine_learning::Union{MLM, Nothing}) where {IFM <: IceflowModel, MBM <: MBmodel, MLM <: MLmodel}\n\nCreates a new model instance using the provided iceflow, mass balance, and machine learning components.\n\nArguments\n\niceflow::Union{IFM, Vector{IFM}, Nothing}: The iceflow model(s) to be used. Can be a single model, a vector of models, or nothing.\nmass_balance::Union{MBM, Vector{MBM}, Nothing}: The mass balance model(s) to be used. Can be a single model, a vector of models, or nothing.\nmachine_learning::Union{MLM, Nothing}: The machine learning model to be used. Can be a single model or nothing.\n\nReturns\n\nmodel: A new instance of Sleipnir.Model initialized with the provided components.\n\n\n\n\n\n","category":"function"},{"location":"funcs_types/#ODINN.Model-Tuple{}","page":"Types and functions","title":"ODINN.Model","text":"Model(; iceflow::Union{IFM, Vector{IFM}, Nothing}, mass_balance::Union{MBM, Vector{MBM}, Nothing}, machine_learning::Union{MLM, Nothing}) where {IFM <: IceflowModel, MBM <: MBmodel, MLM <: MLmodel}\n\nCreates a new model instance using the provided iceflow, mass balance, and machine learning components.\n\nArguments\n\niceflow::Union{IFM, Vector{IFM}, Nothing}: The iceflow model(s) to be used. Can be a single model, a vector of models, or nothing.\nmass_balance::Union{MBM, Vector{MBM}, Nothing}: The mass balance model(s) to be used. Can be a single model, a vector of models, or nothing.\nmachine_learning::Union{MLM, Nothing}: The machine learning model to be used. Can be a single model or nothing.\n\nReturns\n\nmodel: A new instance of Sleipnir.Model initialized with the provided components.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Ice-flow-models","page":"Types and functions","title":"Ice flow models","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Ice flow models are used to solve the PDEs describing the gravitational flow of glaciers. All ice flow models must be a subtype of abstract type IceflowModel. Ice flow models are managed by Huginn.jl. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"The main type of ice flow model used in ODINN.jl right now is a 2D Shallow Ice Approximation (SIA) model (Hutter, 1983). This is declared in the following way:","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Huginn.SIA2Dmodel\nHuginn.SIA2Dmodel(params::Sleipnir.Parameters)","category":"page"},{"location":"funcs_types/#Huginn.SIA2Dmodel","page":"Types and functions","title":"Huginn.SIA2Dmodel","text":"mutable struct SIA2Dmodel{R <: Real, I <: Integer} <: SIAmodel\n\nA mutable struct representing a 2D Shallow Ice Approximation (SIA) model.\n\nFields\n\nA::Union{Ref{R}, Nothing}: Flow rate factor.\nn::Union{Ref{R}, Nothing}: Flow law exponent.\nC::Union{Ref{R}, Matrix{R}, Nothing}: Sliding coefficient.\nH₀::Union{Matrix{R}, Nothing}: Initial ice thickness.\nH::Union{Matrix{R}, Nothing}: Ice thickness.\nH̄::Union{Matrix{R}, Nothing}: Averaged ice thickness.\nS::Union{Matrix{R}, Nothing}: Surface elevation.\ndSdx::Union{Matrix{R}, Nothing}: Surface slope in the x-direction.\ndSdy::Union{Matrix{R}, Nothing}: Surface slope in the y-direction.\nD::Union{Matrix{R}, Nothing}: Diffusivity.\nDx::Union{Matrix{R}, Nothing}: Diffusivity in the x-direction.\nDy::Union{Matrix{R}, Nothing}: Diffusivity in the y-direction.\ndSdx_edges::Union{Matrix{R}, Nothing}: Surface slope at edges in the x-direction.\ndSdy_edges::Union{Matrix{R}, Nothing}: Surface slope at edges in the y-direction.\n∇S::Union{Matrix{R}, Nothing}: Gradient of the surface elevation.\n∇Sy::Union{Matrix{R}, Nothing}: Gradient of the surface elevation in the y-direction.\n∇Sx::Union{Matrix{R}, Nothing}: Gradient of the surface elevation in the x-direction.\nFx::Union{Matrix{R}, Nothing}: Flux in the x-direction.\nFy::Union{Matrix{R}, Nothing}: Flux in the y-direction.\nFxx::Union{Matrix{R}, Nothing}: Second derivative of flux in the x-direction.\nFyy::Union{Matrix{R}, Nothing}: Second derivative of flux in the y-direction.\nV::Union{Matrix{R}, Nothing}: Velocity.\nVx::Union{Matrix{R}, Nothing}: Velocity in the x-direction.\nVy::Union{Matrix{R}, Nothing}: Velocity in the y-direction.\nΓ::Union{Ref{R}, Nothing}: Basal shear stress.\nMB::Union{Matrix{R}, Nothing}: Mass balance.\nMB_mask::Union{AbstractArray{Bool}, Nothing}: Mask for mass balance.\nMB_total::Union{Matrix{R}, Nothing}: Total mass balance.\nglacier_idx::Union{Ref{I}, Nothing}: Index of the glacier.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Huginn.SIA2Dmodel-Tuple{Sleipnir.Parameters}","page":"Types and functions","title":"Huginn.SIA2Dmodel","text":"SIA2Dmodel(params::Sleipnir.Parameters; \n           A::Union{R, Nothing} = nothing,\n           n::Union{R, Nothing} = nothing,\n           C::Union{R, Matrix{R}, Nothing} = nothing,\n           H₀::Union{Matrix{R}, Nothing} = nothing,\n           H::Union{Matrix{R}, Nothing} = nothing,\n           H̄::Union{Matrix{R}, Nothing} = nothing,\n           S::Union{Matrix{R}, Nothing} = nothing,\n           dSdx::Union{Matrix{R}, Nothing} = nothing,\n           dSdy::Union{Matrix{R}, Nothing} = nothing,\n           D::Union{Matrix{R}, Nothing} = nothing,\n           Dx::Union{Matrix{R}, Nothing} = nothing,\n           Dy::Union{Matrix{R}, Nothing} = nothing,\n           dSdx_edges::Union{Matrix{R}, Nothing} = nothing,\n           dSdy_edges::Union{Matrix{R}, Nothing} = nothing,\n           ∇S::Union{Matrix{R}, Nothing} = nothing,\n           ∇Sy::Union{Matrix{R}, Nothing} = nothing,\n           ∇Sx::Union{Matrix{R}, Nothing} = nothing,\n           Fx::Union{Matrix{R}, Nothing} = nothing,\n           Fy::Union{Matrix{R}, Nothing} = nothing,\n           Fxx::Union{Matrix{R}, Nothing} = nothing,\n           Fyy::Union{Matrix{R}, Nothing} = nothing,\n           V::Union{Matrix{R}, Nothing} = nothing,\n           Vx::Union{Matrix{R}, Nothing} = nothing,\n           Vy::Union{Matrix{R}, Nothing} = nothing,\n           Γ::Union{R, Nothing} = nothing,\n           MB::Union{Matrix{R}, Nothing} = nothing,\n           MB_mask::Union{BitMatrix, Nothing} = nothing,\n           MB_total::Union{Matrix{R}, Nothing} = nothing,\n           glacier_idx::Union{I, Nothing} = nothing) where {I <: Integer, R <: Real}\n\nConstructs a new SIA2Dmodel object with the given parameters.\n\nArguments\n\nparams::Sleipnir.Parameters: Simulation parameters.\nA::Union{R, Nothing}: Flow law parameter (default: nothing).\nn::Union{R, Nothing}: Flow law exponent (default: nothing).\nC::Union{R, Matrix{R}, Nothing}: Basal sliding parameter (default: nothing).\nH₀::Union{Matrix{R}, Nothing}: Initial ice thickness (default: nothing).\nH::Union{Matrix{R}, Nothing}: Ice thickness (default: nothing).\nH̄::Union{Matrix{R}, Nothing}: Averaged ice thickness (default: nothing).\nS::Union{Matrix{R}, Nothing}: Surface elevation (default: nothing).\ndSdx::Union{Matrix{R}, Nothing}: Surface slope in x-direction (default: nothing).\ndSdy::Union{Matrix{R}, Nothing}: Surface slope in y-direction (default: nothing).\nD::Union{Matrix{R}, Nothing}: Diffusivity (default: nothing).\nDx::Union{Matrix{R}, Nothing}: Diffusivity in x-direction (default: nothing).\nDy::Union{Matrix{R}, Nothing}: Diffusivity in y-direction (default: nothing).\ndSdx_edges::Union{Matrix{R}, Nothing}: Surface slope at edges in x-direction (default: nothing).\ndSdy_edges::Union{Matrix{R}, Nothing}: Surface slope at edges in y-direction (default: nothing).\n∇S::Union{Matrix{R}, Nothing}: Gradient of surface elevation (default: nothing).\n∇Sy::Union{Matrix{R}, Nothing}: Gradient of surface elevation in y-direction (default: nothing).\n∇Sx::Union{Matrix{R}, Nothing}: Gradient of surface elevation in x-direction (default: nothing).\nFx::Union{Matrix{R}, Nothing}: Flux in x-direction (default: nothing).\nFy::Union{Matrix{R}, Nothing}: Flux in y-direction (default: nothing).\nFxx::Union{Matrix{R}, Nothing}: Second derivative of flux in x-direction (default: nothing).\nFyy::Union{Matrix{R}, Nothing}: Second derivative of flux in y-direction (default: nothing).\nV::Union{Matrix{R}, Nothing}: Velocity (default: nothing).\nVx::Union{Matrix{R}, Nothing}: Velocity in x-direction (default: nothing).\nVy::Union{Matrix{R}, Nothing}: Velocity in y-direction (default: nothing).\nΓ::Union{R, Nothing}: Auxiliary matrix (default: nothing).\nMB::Union{Matrix{R}, Nothing}: Mass balance (default: nothing).\nMB_mask::Union{BitMatrix, Nothing}: Mask for mass balance (default: nothing).\nMB_total::Union{Matrix{R}, Nothing}: Total mass balance (default: nothing).\nglacier_idx::Union{I, Nothing}: Index of the glacier (default: nothing).\n\nReturns\n\nSIA2Dmodel: A new SIA2Dmodel object.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"When a simulation will be run in ODINN.jl using an ice flow model, its related equation will be solved using OrdinaryDiffEq.jl. The related equation to a SIA2Dmodel is declared in its related util functions. Generally, these equations need to exist both in-place (to reduce memory allocations and ensure maximum performance, see example below) or out-of-place (to be more AD-friendly).","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Huginn.SIA2D!","category":"page"},{"location":"funcs_types/#Huginn.SIA2D!","page":"Types and functions","title":"Huginn.SIA2D!","text":"SIA2D!(dH::Matrix{R}, H::Matrix{R}, simulation::SIM, t::R) where {R <:Real, SIM <: Simulation}\n\nSimulates the evolution of ice thickness in a 2D shallow ice approximation (SIA) model. Works in-place.\n\nArguments\n\ndH::Matrix{R}: Matrix to store the rate of change of ice thickness.\nH::Matrix{R}: Matrix representing the ice thickness.\nsimulation::SIM: Simulation object containing model parameters and state.\nt::R: Current simulation time.\n\nDetails\n\nThis function updates the ice thickness H and computes the rate of change dH using the shallow ice approximation in 2D. It retrieves necessary parameters from the simulation object, enforces positive ice thickness values, updates glacier surface altimetry, computes surface gradients, flux components, and flux divergence.\n\nNotes\n\nThe function operates on a staggered grid for computing gradients and fluxes.\nSurface elevation differences are capped using upstream ice thickness to impose boundary conditions.\nThe function modifies the input matrices dH and H in-place.\n\n\n\n\n\n","category":"function"},{"location":"funcs_types/#Mass-balance-models","page":"Types and functions","title":"Mass balance models","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Mass balance models are used to simulate the simplified thermodynamics of the forcing of the atmosphere on glaciers. As per ice flow models, all specific mass balance models needs to be a subtype of the abstract type MBmodel. Mass balance models are managed by Muninn.jl. For now, we have simple temperature-index models, with either one or two degree-day factors (DDFs) (Hock, 2003):","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Muninn.TImodel1\nMuninn.TImodel1(params::Sleipnir.Parameters)","category":"page"},{"location":"funcs_types/#Muninn.TImodel1","page":"Types and functions","title":"Muninn.TImodel1","text":"TImodel1(params::Sleipnir.Parameters;\n    DDF::Float64 = 7.0/1000.0,\n    acc_factor::Float64 = 1.0/1000.0\n    )\n\nTemperature-index model with a single degree-day factor.\n\nKeyword arguments\n\n- `DDF`: Single degree-day factor, for both snow and ice.\n- `acc_factor`: Accumulation factor\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Muninn.TImodel1-Tuple{Sleipnir.Parameters}","page":"Types and functions","title":"Muninn.TImodel1","text":"TImodel1(params::Sleipnir.Parameters;\n    DDF::Float64 = 7.0/1000.0,\n    acc_factor::Float64 = 1.0/1000.0\n    )\n\nTemperature-index model with a single degree-day factor.\n\nKeyword arguments\n\n- `DDF`: Single degree-day factor, for both snow and ice.\n- `acc_factor`: Accumulation factor\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Surface mass balance models are run in DiscreteCallbacks from OrdinaryDiffEq.jl, which enable the safe execution during the solving of a PDE in specificly prescribed time steps determined in the stepsfield in Sleipnir.SimulationParameters.","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"We soon plan to add compatibility with neural networks coming from the MassBalanceMachine, which should become the de facto surface mass balance model in the ODINN.jl ecosystem. ","category":"page"},{"location":"funcs_types/#Machine-Learning-models","page":"Types and functions","title":"Machine Learning models","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Machine learning models are used in the context of Universal Differential Equations (UDEs, Rackauckas et al., 2020) to parametrize or learn specific parts of differential equations. Machine Learning models are manage by ODINN.jl. As per the other types of models, all machine learning models need to be a subtype of the abstract type MLmodel. The default solution here is to use a neural network:","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"ODINN.NN\nODINN.NN(params::Sleipnir.Parameters)","category":"page"},{"location":"funcs_types/#Simulations","page":"Types and functions","title":"Simulations","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"One can run different types of simulations in ODINN.jl. Any specific type of simulation must be a subtype of Simulation. All simulations share the same common interface designed around multiple dispatch. Basically, once a simulation type has been created, one can easily run by calling run!(simulation).","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"The main types of simulations are the following ones:","category":"page"},{"location":"funcs_types/#Prediction","page":"Types and functions","title":"Prediction","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"A prediction, also known as a forward simulation, is just a forward simulation given a model configuration, based on parameters, glaciers and models. These are managed in Huginn.jl, since they do not involve any inverse methods nor parameter optimization.","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Huginn.Prediction\nHuginn.Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G <: Sleipnir.AbstractGlacier}","category":"page"},{"location":"funcs_types/#Huginn.Prediction","page":"Types and functions","title":"Huginn.Prediction","text":"Prediction <: Simulation\n\nA mutable struct that represents a prediction simulation.\n\nFields\n\nmodel::Sleipnir.Model: The model used for the prediction.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the prediction.\nparameters::Sleipnir.Parameters: The parameters used for the prediction.\nresults::Vector{Results}: A vector of results obtained from the prediction.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Types and functions","title":"Huginn.Prediction","text":"Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G <: Sleipnir.AbstractGlacier}\n\nCreate a Prediction object using the given model, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for prediction.\nglaciers::Vector{G}: A vector of glacier objects, where each glacier is a subtype of Sleipnir.AbstractGlacier.\nparameters::Sleipnir.Parameters: The parameters used for the prediction.\n\nReturns\n\nPrediction: A Prediction object based on the input values.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Inversion","page":"Types and functions","title":"Inversion","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"An inversion optimises a given set of model parameters, based on a given target and an optimizer. These are handled by ODINN.jl. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"ODINN.Inversion\nODINN.Inversion(\n    model::Sleipnir.Model,\n    glaciers::Vector{G},\n    parameters::Sleipnir.Parameters\n    ) where {G <: Sleipnir.AbstractGlacier}","category":"page"},{"location":"funcs_types/#ODINN.Inversion","page":"Types and functions","title":"ODINN.Inversion","text":"Inversion <: Simulation\n\nA mutable struct that represents an inversion simulation.\n\nFields\n\nmodel::Sleipnir.Model: The model used for the inversion.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the inversion.\nparameters::Sleipnir.Parameters: The parameters used for the inversion.\ninversion::Vector{InversionResults}: A vector of results from the inversion.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Types and functions","title":"ODINN.Inversion","text":"Inversion(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G <: Sleipnir.AbstractGlacier}\n\nCreate an Inversion object using the provided model, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model to be used for the inversion.\nglaciers::Vector{G}: A vector of glaciers, where each glacier is a subtype of Sleipnir.AbstractGlacier.\nparameters::Sleipnir.Parameters: The parameters to be used for the inversion.\n\nReturns\n\ninversion: An Inversion object initialized with the provided model, glaciers, and parameters.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Functional-inversion","page":"Types and functions","title":"Functional inversion","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"A functional inversion is the inversion of the parameters of a regressor (e.g. a neural network), which parametrize a function that modulates a parameter or set of parameters in a given mechanistic model (e.g. the SIA).","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"ODINN.FunctionalInversion\nODINN.FunctionalInversion(\n    model::Sleipnir.Model,\n    glaciers::Vector{G},\n    parameters::Sleipnir.Parameters\n    ) where {G <: Sleipnir.AbstractGlacier}","category":"page"},{"location":"funcs_types/#ODINN.FunctionalInversion","page":"Types and functions","title":"ODINN.FunctionalInversion","text":"mutable struct FunctionalInversion <: Simulation\n\nAn object representing a functional inversion simulation (i.e. the inversion of a function using some data-driven regressor).\n\nFields\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\nresults::Vector{Results}: A vector to store the results of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.FunctionalInversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Types and functions","title":"ODINN.FunctionalInversion","text":"function FunctionalInversion(\n    model::Sleipnir.Model,\n    glaciers::Vector{G},\n    parameters::Sleipnir.Parameters\n) where {G <: Sleipnir.AbstractGlacier}\n\nConstructor for FunctionalInversion struct with glacier model information, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{G}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\n\nReturns\n\nFunctionalInversion: A new instance of the FunctionalInversion struct.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/#Results-and-plotting","page":"Types and functions","title":"Results and plotting","text":"","category":"section"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Every Simulation type has an associated Results object(s), one for each one of the glaciers in the simulation. This object, as its name indicates, stores all the results of the simulation, which can be used for data anlysis and plotting. These types are handled by Sleipnir.jl. ","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.Results\nSleipnir.Results(glacier::G, ifm::IF) where {G <: AbstractGlacier, F <: AbstractFloat, IF <: AbstractModel, I <: Int}","category":"page"},{"location":"funcs_types/#Sleipnir.Results","page":"Types and functions","title":"Sleipnir.Results","text":"mutable struct Results{F <: AbstractFloat, I <: Int}\n\nA mutable struct to store the results of simulations.\n\nFields\n\nrgi_id::String: Identifier for the RGI (Randolph Glacier Inventory).\nH::Vector{Matrix{F}}: Vector of matrices representing glacier ice thickness H over time.\nH_glathida::Union{Nothing, Vector{Matrix{F}}}: Optional vector of matrices for Glathida ice thicknesses.\nS::Matrix{F}: Glacier surface altimetry.\nB::Matrix{F}: Glacier bedrock.\nV::Matrix{F}: Glacier ice surface velocities.\nVx::Matrix{F}: x-component of the glacier ice surface velocity V.\nVy::Matrix{F}: y-component of the glacier ice surface velocity V.\nV_ref::Union{Nothing, Matrix{F}}: Reference data for glacier ice surface velocities V.\nVx_ref::Union{Nothing, Matrix{F}}: Reference data for the x-component of the glacier ice surface velocity Vx.\nVy_ref::Union{Nothing, Matrix{F}}: Reference data for the y-component of the glacier ice surface velocity Vy.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nlon::Union{Nothing, F}: Optional longitude value.\nlat::Union{Nothing, F}: Optional latitude value.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ntspan::Vector{F}: Time span of the simulation.\nθ::Union{Nothing, ComponentArray{F}}: Machine learning model parameters.\nloss::Union{Nothing, Vector{F}} Vector with evolution of loss function.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G<:AbstractGlacier, F<:AbstractFloat, IF<:AbstractModel, I<:Int64}","page":"Types and functions","title":"Sleipnir.Results","text":"Results(glacier::G, ifm::IF; rgi_id::String = glacier.rgi_id, H::Vector{Matrix{F}} = Vector{Matrix{F}}([]), \n        H_glathida::Union{Nothing, Vector{Matrix{F}}} = glacier.H_glathida, S::Matrix{F} = zeros(F, size(ifm.S)), \n        B::Matrix{F} = zeros(F, size(ifm.B)), V::Matrix{F} = zeros(F, size(ifm.V)), \n        Vx::Matrix{F} = zeros(F, size(ifm.Vx)), Vy::Matrix{F} = zeros(F, size(ifm.Vy)), \n        V_ref::Union{Nothing, Matrix{F}} = glacier.V, Vx_ref::Union{Nothing, Matrix{F}} = glacier.Vx, \n        Vy_ref::Union{Nothing, Matrix{F}} = glacier.Vy, Δx::F = glacier.Δx, Δy::F = glacier.Δy, \n        lon::Union{Nothing, F} = glacier.cenlon, lat::Union{Nothing, F} = glacier.cenlat, \n        nx::I = glacier.nx, ny::I = glacier.ny, θ::Union{Nothing, ComponentArray{F}} = nothing,\n        loss::Union{Nothing, Vector{F}} = Nothing) where {G <: AbstractGlacier, F <: AbstractFloat, IF <: AbstractModel}\n\nConstruct a Results object for a glacier simulation.\n\nArguments\n\nglacier::G: The glacier object, subtype of AbstractGlacier.\nifm::IF: The model object, subtype of AbstractModel.\nrgi_id::String: The RGI identifier for the glacier. Defaults to glacier.rgi_id.\nH::Vector{Matrix{F}}: Ice thickness matrices. Defaults to an empty vector.\nH_glathida::Union{Nothing, Vector{Matrix{F}}}: Ice thickness from GlaThiDa. Defaults to glacier.H_glathida.\nS::Matrix{F}: Surface elevation matrix. Defaults to a zero matrix of the same size as ifm.S.\nB::Matrix{F}: Bed elevation matrix. Defaults to a zero matrix of the same size as ifm.B.\nV::Matrix{F}: Velocity magnitude matrix. Defaults to a zero matrix of the same size as ifm.V.\nVx::Matrix{F}: Velocity in the x-direction matrix. Defaults to a zero matrix of the same size as ifm.Vx.\nVy::Matrix{F}: Velocity in the y-direction matrix. Defaults to a zero matrix of the same size as ifm.Vy.\nV_ref::Union{Nothing, Matrix{F}}: Reference velocity magnitude matrix. Defaults to glacier.V.\nVx_ref::Union{Nothing, Matrix{F}}: Reference velocity in the x-direction matrix. Defaults to glacier.Vx.\nVy_ref::Union{Nothing, Matrix{F}}: Reference velocity in the y-direction matrix. Defaults to glacier.Vy.\nΔx::F: Grid spacing in the x-direction. Defaults to glacier.Δx.\nΔy::F: Grid spacing in the y-direction. Defaults to glacier.Δy.\nlon::Union{Nothing, F}: Longitude of the glacier center. Defaults to glacier.cenlon.\nlat::Union{Nothing, F}: Latitude of the glacier center. Defaults to glacier.cenlat.\nnx::I: Number of grid points in the x-direction. Defaults to glacier.nx.\nny::I: Number of grid points in the y-direction. Defaults to glacier.ny.\ntspan::Tuple(F, F): Timespan of the simulation.\nθ::Union{Nothing, ComponentArray{F}}: Model parameters. Defaults to nothing.\nloss::Union{Nothing, Vector{F}}: Loss values. Defaults to nothing.\n\nReturns\n\nresults::Results: A Results object containing the simulation results.\n\n\n\n\n\n","category":"method"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"One of the main things one can do with a Results object, is plotting them. The main function to do so is the following one:","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.plot_glacier","category":"page"},{"location":"funcs_types/#Sleipnir.plot_glacier","page":"Types and functions","title":"Sleipnir.plot_glacier","text":"plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -> Figure\n\nGenerate various types of plots for glacier data.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nplot_type::String: Type of plot to generate. Options are:\n\"heatmaps\": Heatmaps for glacier variables like :H, :S, :B, :V, :Vx, and :Vy.\n\"evolution difference\": Temporal difference metrics (between start and end) for a variable, with optional metrics like \"hist\" (histogram) and \"difference\".\n\"evolution statistics\": Temporal statistical metrics for a variable, with optional metrics like \"average\", \"median\", \"min\", \"max\", and \"std\".\n\"integrated volume\": Temporal evolution of the integrated ice volume for a variable.\n\"bias\": Scatter plot to visualize the bias between two variables.\nvariables::Vector{Symbol}: Variables to be plotted, e.g., :H.\n\nOptional Keyword Arguments\n\ntspan: A tuple representing the start and end time for the simulation.\nmetrics: Metrics to visualize, e.g., [\"average\"] for statistics, [\"difference\"] for difference.\nscale_text_size::Union{Nothing,Float64}: Optional argument to scale the text size for heatmaps.\nthreshold::Vector{F}: Threshold values for filtering data in bias plots.\n\nReturns\n\nA Figure object containing the desired visualization.\n\nNotes\n\nEnsure the variables and kwargs match the requirements of the specified plot_type.\nThe function routes requests to specific plotting functions based on plot_type.\n\n\n\n\n\n","category":"function"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Another option is to generate a video of the evolution of the glacier's ice thickness during the simulation:","category":"page"},{"location":"funcs_types/","page":"Types and functions","title":"Types and functions","text":"Sleipnir.plot_glacier_vid","category":"page"},{"location":"funcs_types/#Sleipnir.plot_glacier_vid","page":"Types and functions","title":"Sleipnir.plot_glacier_vid","text":"plot_glacier_vid(\n    plot_type::String,\n    H::Vector{Matrix{Float64}},\n    glacier::Glacier2D,\n    simuparams::SimulationParameters,\n    pathVideo::String;\n    framerate::Int=24,\n    baseTitle::String=\"\"\n)\n\nGenerate various types of videos for glacier data. For now only the evolution of the glacier ice thickness is supported. More types of visualizations will be added in the future. \n\nArguments\n\nplot_type: Type of plot to generate. Options are:\n\"thickness\": Heatmap of the glacier thickness.\nH: A vector of matrices containing the ice thickness over time. This should be   replaced by a Results instance in the future once Results no longer depends on   an iceflow model.\nglacier: A glacier instance.\nsimuparams: The simulation parameters.\npathVideo: Path of the mp4 file to generate.\n\nOptional Keyword Arguments\n\nframerate: The framerate to use for the video generation.\nbaseTitle: The prefix to use in the title of the frames. In each frame it is   concatenated with the value of the year in the form \" (t=XXXX)\".\n\n\n\n\n\n","category":"function"}]
}
