var documenterSearchIndex = {"docs":
[{"location":"api/#Index-of-functions-and-types","page":"Index of functions and types","title":"Index of functions and types","text":"","category":"section"},{"location":"api/","page":"Index of functions and types","title":"Index of functions and types","text":"Modules = [ODINN, Huginn, Muninn, Sleipnir]\nOrder = [:type, :function]","category":"page"},{"location":"api/#ODINN.FunctionalInversion","page":"Index of functions and types","title":"ODINN.FunctionalInversion","text":"mutable struct FunctionalInversion <: Simulation\n\nAn object representing a functional inversion simulation (i.e. the inversion of a function using some data-driven regressor).\n\nFields\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\nresults::Vector{Results}: A vector to store the results of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.FunctionalInversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Index of functions and types","title":"ODINN.FunctionalInversion","text":"function FunctionalInversion(\n    model::Sleipnir.Model,\n    glaciers::Vector{G},\n    parameters::Sleipnir.Parameters\n) where {G <: Sleipnir.AbstractGlacier}\n\nConstructor for FunctionalInversion struct with glacier model information, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{G}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\n\nReturns\n\nFunctionalInversion: A new instance of the FunctionalInversion struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Hyperparameters-Tuple{}","page":"Index of functions and types","title":"ODINN.Hyperparameters","text":"Hyperparameters(;\n    current_epoch::Int64 = nothing,\n    current_minibatch::Int64 = nothing,\n    loss_history::Vector{Float64} = Vector{Float64}(),\n    optimizer::Optim.FirstOrderOptimizer = BFGS(initial_stepnorm=0.001),\n    epochs::Int64 = 50,\n    batch_size::Int64 = 15\n    )\n\nInitialize the hyperparameters of a machine learning model (Machine). Keyword arguments =================     - current_epoch: Current epoch in training     - current_minibatch: Current minibatch in training     - loss_history: Vector storing the loss for each epoch during training     - optimizer: Optimizer to be used for training. Currently supports both Optim.jl and Flux.jl optimisers.     - epochs: Number of epochs for the training     - batch_size: Batch size for the training\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Inversion","page":"Index of functions and types","title":"ODINN.Inversion","text":"Inversion <: Simulation\n\nA mutable struct that represents an inversion simulation.\n\nFields\n\nmodel::Sleipnir.Model: The model used for the inversion.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the inversion.\nparameters::Sleipnir.Parameters: The parameters used for the inversion.\ninversion::Vector{InversionResults}: A vector of results from the inversion.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Index of functions and types","title":"ODINN.Inversion","text":"function Inversion(\n    model::Sleipnir.Model,\n    glaciers::Vector{Sleipnir.AbstractGlacier},\n    parameters::Sleipnir.Parameters\n    )\n\nConstrunctor for Inversion struct with glacier model infomation, glaciers and parameters. Keyword arguments =================\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.InversionParameters","page":"Index of functions and types","title":"ODINN.InversionParameters","text":"InversionParameters{F<:AbstractFloat}\n\nA mutable struct that holds parameters for inversion processes. This struct is a subtype of AbstractParameters.\n\nFields\n\ninitial_conditions::Vector{F}: A vector of initial conditions.\nlower_bound::Vector{F}: A vector specifying the lower bounds for the parameters.\nupper_bound::Vector{F}: A vector specifying the upper bounds for the parameters.\nregions_split::Vector{Int}: A vector indicating how the regions are split.\nx_tol::F: The tolerance for the solution's x-values.\nf_tol::F: The tolerance for the function values.\nsolver::Any: The solver to be used for the inversion process.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F<:AbstractFloat","page":"Index of functions and types","title":"ODINN.InversionParameters","text":"InversionParameters{F<:AbstractFloat}(;\n    initial_conditions::Vector{F} = [1.0],\n    lower_bound::Vector{F} = [0.0],\n    upper_bound::Vector{F} = [Inf],\n    regions_split::Vector{Int} = [1, 1],\n    x_tol::F = 1.0e-3,\n    f_tol::F = 1.0e-3,\n    solver = BFGS()\n)\n\nInitialize the parameters for the inversion process.\n\nArguments\n\ninitial_conditions::Vector{F}: Starting point for optimization.\nlower_bound::Vector{F}: Lower bounds for optimization variables.\nupper_bound::Vector{F}: Upper bounds for optimization variables.\nregions_split::Vector{Int}: Defines the amount of region split based on altitude and distance to border for the inversion process.\nx_tol::F: Tolerance for variables convergence.\nf_tol::F: Tolerance for function value convergence.\nsolver: Optimization solver to be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.InversionResults","page":"Index of functions and types","title":"ODINN.InversionResults","text":"mutable struct InversionResults{F <: Real}\n\nA structure to store the results of an inversion simulation.\n\nFields\n\nrgi_id::Union{String, Nothing}: The RGI identifier, which can be a string or nothing.\nA::F: Area parameter.\nn::F: Exponent parameter.\nC::Matrix{F}: Coefficient matrix.\nH_pred::Matrix{F}: Predicted height matrix.\nH_obs::Matrix{F}: Observed height matrix.\nH_diff::Matrix{F}: Difference between predicted and observed height matrices.\nV_pred::Matrix{F}: Predicted volume matrix.\nV_obs::Matrix{F}: Observed volume matrix.\nV_diff::Matrix{F}: Difference between predicted and observed volume matrices.\nMSE::F: Mean squared error.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nlon::F: Longitude.\nlat::F: Latitude.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.NN","page":"Index of functions and types","title":"ODINN.NN","text":"NN{F <: AbstractFloat}(architecture::Flux.Chain, NN_f::Optimisers.Restructure, θ::Vector{F})\n\nFeed-forward neural network.\n\nFields\n\narchitecture: Flux.Chain neural network architecture\nNN_f: Neural network restructuring\nθ: Neural network parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.NN-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F<:AbstractFloat","page":"Index of functions and types","title":"ODINN.NN","text":"NN(params::Parameters;\n    architecture::Union{Flux.Chain, Nothing} = nothing,\n    θ::Union{Vector{AbstractFloat}, Nothing} = nothing)\n\nCreates a new feed-forward neural network.\n\nKeyword arguments\n\narchitecture: Flux.Chain neural network architecture (optional)\nθ: Neural network parameters (optional)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.UDEparameters-Tuple{}","page":"Index of functions and types","title":"ODINN.UDEparameters","text":"UDEparameters(;\n    sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm = GaussAdjoint(autojacvec=EnzymeVJP()),\n    optimization_method::String = \"AD+AD\",\n    loss_type::String = \"V\",\n    scale_loss::Bool = true\n    target::String = \"D\"\n    )\n\nInitialize the parameters for the training of the UDE. Keyword arguments =================     - sensealg: Sensitivity algorithm from SciMLSensitivity.jl to be used.     - optimization_method: Optimization method for the UDE.     - loss_type: Type of loss function to be used. Can be either V (ice velocities), or H (ice thickness).     - scale_loss: Determines if the loss function should be scaled or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM<:IceflowModel, MBM<:MBmodel, MLM<:ODINN.MLmodel}","page":"Index of functions and types","title":"ODINN.Model","text":"function Model(;     iceflow::Union{IFM, Nothing},     massbalance::Union{MBM, Nothing}     machinelearning::Union{MLM, Nothing},     ) where {IFM <: IceflowModel, MBM <: MBmodel, MLM <: MLmodel}\n\nInitialize Model at ODINN level (iceflow + mass balance + machine learning).\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Parameters-Tuple{}","page":"Index of functions and types","title":"ODINN.Parameters","text":"Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters(),         solver::SolverParameters = SolverParameters(),         hyper::Hyperparameters = Hyperparameters(),         UDE::UDEparameters = UDEparameters()         inversion::InversionParameters = InversionParameters()         ) Initialize ODINN parameters\n\nKeyword arguments\n\nphysical::PhysicalParameters: Physical parameters for the simulation.\nsimulation::SimulationParameters: Parameters related to the simulation setup.\nsolver::SolverParameters: Parameters for the solver configuration.\nhyper::Hyperparameters: Hyperparameters for the model.\nUDE::UDEparameters: Parameters specific to the UDE (Universal Differential Equation).\ninversion::InversionParameters: Parameters for inversion processes.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}","page":"Index of functions and types","title":"ODINN.enable_multiprocessing","text":"Initialize_ODINN(processes, python_path)\n\nInitializes ODINN by configuring PyCall based on a given Python path. It also configures multiprocessing for a given number of processes. \n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.generate_batches-Tuple{S} where S<:Simulation","page":"Index of functions and types","title":"ODINN.generate_batches","text":"generate_batches(simulation::S; shuffle=true)\n\nGenerates batches for the UE inversion problem based on input data and feed them to the loss function.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.get_NN-Tuple{Any}","page":"Index of functions and types","title":"ODINN.get_NN","text":"get_NN(θ_trained)\n\nGenerates a neural network.\n\nArguments\n\nθ_trained: Pre-trained neural network parameters (optional).\n\nReturns\n\nUA: Flux.Chain neural network architecture.\nθ: Neural network parameters.\nUA_f: Neural network restructuring.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.predict_A̅-Tuple{Any, Any}","page":"Index of functions and types","title":"ODINN.predict_A̅","text":"predict_A̅(U, temp)\n\nPredicts the value of A with a neural network based on the long-term air temperature.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.run!-Tuple{FunctionalInversion}","page":"Index of functions and types","title":"ODINN.run!","text":"run!(simulation::FunctionalInversion)\n\nIn-place run of the model. \n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.sigmoid_A-Tuple{Any}","page":"Index of functions and types","title":"ODINN.sigmoid_A","text":"sigmoid_A(x)\n\nSigmoid activation function for the neural network output.\n\nArguments\n\nx: Input value.\n\nReturns\n\nSigmoid-transformed output value.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.sigmoid_A_inv-Tuple{Any}","page":"Index of functions and types","title":"ODINN.sigmoid_A_inv","text":"sigmoid_A_inv(x)\n\nInverse sigmoid activation function for the neural network output.\n\nArguments\n\nx: Input value.\n\nReturns\n\nInverse sigmoid-transformed output value.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback, I}} where {I<:Integer, SIM<:Simulation}","page":"Index of functions and types","title":"ODINN.simulate_iceflow_UDE!","text":"function simulateiceflowUDE!(     θ,     simulation::SIM,      model::Sleipnir.Model,      params::Sleipnir.Parameters,      cb::DiscreteCallback,     batch_id::I;      du = Huginn.SIA2D) where {I <: Integer, SIM <: Simulation}\n\nMake forward simulation of the iceflow UDE determined in du.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.train_UDE!-Tuple{FunctionalInversion}","page":"Index of functions and types","title":"ODINN.train_UDE!","text":"train_UDE!(simulation::FunctionalInversion) \n\nTrains UDE based on the current FunctionalInversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S<:Simulation","page":"Index of functions and types","title":"ODINN.update_training_state!","text":"update_training_state!(simulation::S, l) where {S <: Simulation}\n\nUpdate the training state to determine if the training has completed an epoch. If an epoch is completed, reset the minibatches, update the history loss, and increment the epoch count.\n\nArguments\n\nsimulation: The current state of the simulation or training process.\nl: The current loss value or other relevant metric.\n\nReturns\n\nNone. This function updates the state in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Index of functions and types","title":"Huginn.Prediction","text":"function Prediction(\n    model::Sleipnir.Model,\n    glaciers::Vector{Sleipnir.AbstractGlacier},\n    parameters::Sleipnir.Parameters\n    )\n\nConstrunctor for Prediction struct with glacier model infomation, glaciers and parameters. Keyword arguments =================\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer}","page":"Index of functions and types","title":"Huginn.SolverParameters","text":"SolverParameters(;\n    solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),\n    reltol::Float64 = 1e-7\n    )\n\nInitialize the parameters for the numerical solver. Keyword arguments =================     - solver: solver to use from DifferentialEquations.jl     - reltol: Relative tolerance for the solver\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R<:Real, SIM<:Simulation}","page":"Index of functions and types","title":"Huginn.SIA2D!","text":"SIA2D!(dH, H, SIA2Dmodel)\n\nCompute an in-place step of the Shallow Ice Approximation PDE in a forward model\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R<:Real, I<:Integer, SIM<:Simulation}","page":"Index of functions and types","title":"Huginn.SIA2D","text":"SIA(H, SIA2Dmodel)\n\nCompute a step of the Shallow Ice Approximation UDE in a forward model. Allocates memory.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg-Tuple{Any}","page":"Index of functions and types","title":"Huginn.avg","text":"avg(A)\n\n4-point average of a matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_surface_V!-Tuple{SIM} where SIM<:Simulation","page":"Index of functions and types","title":"Huginn.avg_surface_V!","text":"avg_surface_V(simulation::SIM)\n\nComputes the average ice surface velocity for a given glacier evolution period based on the initial and final ice thickness states. \n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I<:Integer, SIM<:Simulation}","page":"Index of functions and types","title":"Huginn.avg_surface_V","text":"avg_surface_V(context, H, temp, sim, θ=[], UA_f=[])\n\nComputes the average ice surface velocity for a given glacier evolution period based on the initial and final ice thickness states. \n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_x-Tuple{Any}","page":"Index of functions and types","title":"Huginn.avg_x","text":"avg_x(A)\n\n2-point average of a matrix's X axis\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_y-Tuple{Any}","page":"Index of functions and types","title":"Huginn.avg_y","text":"avg_y(A)\n\n2-point average of a matrix's Y axis\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I<:Integer","page":"Index of functions and types","title":"Huginn.batch_iceflow_PDE!","text":"batch_iceflow_PDE!(glacier_idx::I, simulation::Prediction)\n\nSolve the Shallow Ice Approximation iceflow PDE for a given temperature series batch in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I<:Integer","page":"Index of functions and types","title":"Huginn.batch_iceflow_PDE","text":"batch_iceflow_PDE(glacier_idx::I, simulation::Prediction)\n\nSolve the Shallow Ice Approximation iceflow PDE for a given temperature series batch out-of-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.define_callback_steps-Tuple{Tuple{Float64, Float64}, Float64}","page":"Index of functions and types","title":"Huginn.define_callback_steps","text":"define_callback_steps(tspan::Tuple{Float64, Float64}, step::Float64)\n\nDefines the times to stop for the DiscreteCallback given a step\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.diff_x-Tuple{Any}","page":"Index of functions and types","title":"Huginn.diff_x","text":"diff_x(A)\n\n2-point differential of a matrix's X axis\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.diff_y-Tuple{Any}","page":"Index of functions and types","title":"Huginn.diff_y","text":"diff_y(A)\n\n2-point differential of a matrix's Y axis\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF<:IceflowModel, I<:Integer, G<:AbstractGlacier}","page":"Index of functions and types","title":"Huginn.initialize_iceflow_model!","text":"function initializeiceflowmodel!(iceflowmodel::IF,       glacieridx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters     ) where {IF <: IceflowModel, I <: Integer}\n\nInitialize iceflow model data structures to enable in-place mutation.\n\nKeyword arguments\n\n- `iceflow_model`: Iceflow model used for simulation. \n- `glacier_idx`: Index of glacier.\n- `glacier`: `Glacier` to provide basic initial state of the ice flow model.\n- `parameters`: `Parameters` to configure some physical variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF<:IceflowModel, I<:Integer}","page":"Index of functions and types","title":"Huginn.initialize_iceflow_model","text":"function initializeiceflowmodel(iceflowmodel::IF,       glacieridx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters     ) where {IF <: IceflowModel, I <: Integer}\n\nInitialize iceflow model data structures to enable out-of-place mutation.\n\nKeyword arguments\n\n- `iceflow_model`: Iceflow model used for simulation. \n- `glacier_idx`: Index of glacier.\n- `glacier`: `Glacier` to provide basic initial state of the ice flow model.\n- `parameters`: `Parameters` to configure some physical variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.inn-Tuple{Any}","page":"Index of functions and types","title":"Huginn.inn","text":"inn(A)\n\nAccess the inner part of the matrix (-2,-2)\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.inn1-Tuple{Any}","page":"Index of functions and types","title":"Huginn.inn1","text":"inn1(A)\n\nAccess the inner part of the matrix (-1,-1)\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.run!-Tuple{Prediction}","page":"Index of functions and types","title":"Huginn.run!","text":"run!(simulation::Prediction)\n\nIn-place run of the model. \n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.run₀-Tuple{Prediction}","page":"Index of functions and types","title":"Huginn.run₀","text":"run(simulation::Prediction)\n\nOut-of-place run of the model. \n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback}} where SIM<:Simulation","page":"Index of functions and types","title":"Huginn.simulate_iceflow_PDE!","text":"function simulate_iceflow_PDE!(\n    simulation::SIM, \n    model::Sleipnir.Model, \n    params::Sleipnir.Parameters, \n    cb::DiscreteCallback; \n    du = SIA2D!) where {SIM <: Simulation}\n\nMake forward simulation of the iceflow PDE determined in du.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback}} where SIM<:Simulation","page":"Index of functions and types","title":"Huginn.simulate_iceflow_PDE","text":"function simulate_iceflow_PDE(\n    simulation::SIM, \n    model::Sleipnir.Model, \n    params::Sleipnir.Parameters, \n    cb::DiscreteCallback; \n    du = SIA2D) where {SIM <: Simulation}\n\nMake forward simulation of the iceflow PDE determined in du.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{<:Real}, SIM}} where SIM<:Simulation","page":"Index of functions and types","title":"Huginn.surface_V!","text":"surface_V!(H, B, Δx, Δy, temp, sim, A_noise, θ=[], UA_f=[])\n\nComputes the ice surface velocity for a given glacier state\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I<:Integer, R<:Real, SIM<:Simulation}","page":"Index of functions and types","title":"Huginn.surface_V","text":"surface_V(H, B, Δx, Δy, temp, sim, A_noise, θ=[], UA_f=[])\n\nComputes the ice surface velocity for a given glacier state\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F<:AbstractFloat","page":"Index of functions and types","title":"Muninn.TImodel1","text":"TImodel1(params::Sleipnir.Parameters;\n    DDF::Float64 = 7.0/1000.0,\n    acc_factor::Float64 = 1.0/1000.0\n    )\n\nTemperature-index model with a single degree-day factor.\n\nKeyword arguments\n\n- `DDF`: Single degree-day factor, for both snow and ice.\n- `acc_factor`: Accumulation factor\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F<:AbstractFloat","page":"Index of functions and types","title":"Muninn.TImodel2","text":"TImodel2(params::Parameters;\n    DDF_snow::Float64 = 3.0/1000.0,\n    DDF_ice::Float64 = 6.0/1000.0,\n    acc_factor::Float64 = 1.0/1000.0\n    )\n\nTemperature-index model with two melt factors, for snow and ice.\n\nKeyword arguments\n\n- `DDF_snow`: Degree-day factor for snow.\n- `DDF_ice`: Degree-day factor for ice.\n- `acc_factor`: Accumulation factor\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I<:Integer, F<:AbstractFloat, G<:AbstractGlacier}","page":"Index of functions and types","title":"Muninn.MB_timestep!","text":"MB_timestep!(model::Model, glacier::G, step::F, t; batch_id::Union{Nothing, I} = nothing) where {I <: Integer, F <: AbstractFloat, G <: AbstractGlacier}\n\nRetrieve the climate data, apply downscaling and compute the mass balance of a glacier for a specific time step and possibly for a batch of iceflow models.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F<:AbstractFloat, G<:AbstractGlacier}","page":"Index of functions and types","title":"Muninn.MB_timestep","text":"MB_timestep(model::Model, glacier::G, step::F, t::F) where {F <: AbstractFloat, G <: AbstractGlacier}\n\nRetrieve the climate data, apply downscaling and compute the mass balance of a glacier for a specific time step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}","page":"Index of functions and types","title":"Muninn.compute_MB","text":"compute_MB(mb_model::TImodel1, climate_2D_period::Climate2Dstep)\n\nCompute the the mass balance given a mass balance model and a climate step.\n\nKeyword arguments\n\n- `mb_model`: Mass balance model.\n- `climate_2D_period`: Climate step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer}","page":"Index of functions and types","title":"Sleipnir.Glacier1D","text":"function Glacier1D(;     rgiid::Union{String, Nothing} = nothing,     climate::Union{Climate1D, Nothing} = nothing,     H₀::Union{Vector{F}, Nothing} = nothing,     S::Union{Vector{F}, Nothing} = nothing,     B::Union{Vector{F}, Nothing} = nothing,     V::Union{Vector{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     w₀::Union{Vector{F}, Nothing} = nothing,     λ::Union{Vector{F}, Nothing} = nothing,     slope::Union{Vector{F}, Nothing} = nothing,     distborder::Union{Vector{F}, Nothing} = nothing,     S_coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing     ) where {F <: AbstractFloat, I <: Integer}\n\nConstructor for empty 2D Glacier object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer}","page":"Index of functions and types","title":"Sleipnir.Glacier2D","text":"function Glacier2D(;     rgiid::Union{String, Nothing} = nothing,     climate::Union{Climate2D, Nothing} = nothing,     H₀::Union{Matrix{F}, Nothing} = nothing,     Hglathida::Union{Matrix{F}, Nothing} = nothing,     S::Union{Matrix{F}, Nothing} = nothing,     B::Union{Matrix{F}, Nothing} = nothing,     V::Union{Matrix{F}, Nothing}= nothing,     Vx::Union{Matrix{F}, Nothing}= nothing,     Vy::Union{Matrix{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     slope::Union{Matrix{F}, Nothing} = nothing,     distborder::Union{Matrix{F}, Nothing} = nothing,     Scoords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing,     cenlon::Union{F, Nothing} = nothing,     cenlat::Union{F, Nothing} = nothing     ) where {F <: AbstractFloat, I <: Integer}\n\nConstructor for empty 2D Glacier object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Parameters-Tuple{}","page":"Index of functions and types","title":"Sleipnir.Parameters","text":"Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters()         ) Initialize ODINN parameters\n\nKeyword arguments\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F<:AbstractFloat","page":"Index of functions and types","title":"Sleipnir.PhysicalParameters","text":"PhysicalParameters(;\n    ρ::Float64 = 900.0,\n    g::Float64 = 9.81,\n    ϵ::Float64 = 1e-3,\n    η₀::F = 1.0, \n    maxA::Float64 = 8e-17,\n    minA::Float64 = 8.5e-20,\n    maxTlaw::Float64 = 1.0,\n    minTlaw::Float64 = -25.0,\n    noise_A_magnitude::Float64 = 5e-18\n    )\n\nInitialize the physical parameters of a model. Keyword arguments =================     - ρ: Ice density     - g: Gravitational constant     - n: Glen's exponent     - A: Glen's coefficient     - ϵ: Small number     - C: Sliding coefficient     - η₀:       - maxA: Maximum value for A (Glen's coefficient)     - minA: Minimum value for A (Glen's coefficient)\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{F}, Tuple{I}} where {I<:Integer, F<:AbstractFloat}","page":"Index of functions and types","title":"Sleipnir.SimulationParameters","text":"SimulationParameters(;\n                    use_MB::Bool = true,\n                    use_iceflow::Bool = true,\n                    plots::Bool = true,\n                    velocities::Bool = true,\n                    overwrite_climate::Bool = false,\n                    use_glathida_data::Bool = false,\n                    float_type::DataType = Float64,\n                    int_type::DataType = Int64,\n                    tspan::Tuple{F, F} = (2010.0,2015.0),\n                    step::F = 1/12,\n                    multiprocessing::Bool = true,\n                    workers::I = 4,\n                    working_dir::String = \"\",\n                    test_mode::Bool = false,\n                    rgi_paths::Dict{String, String} = Dict{String, String}(),\n                    ice_thickness_source::String = \"Farinotti19\",\n    )\n\nInitialize the parameters for a simulation. Keyword arguments =================     - use_MB: Determines if surface mass balance should be used.     - plots: Determines if plots should be made.     - overwrite_climate: Determines if climate data should be overwritten     - 'useglathidadata': Determines if data from the Glathida data set should be used\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}","page":"Index of functions and types","title":"Sleipnir.apply_t_grad!","text":"apply_t_grad!(climate::RasterStack, dem::Raster)\n\nApplies temperature gradients to the glacier 2D climate data based on a DEM.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM<:Simulation, I<:Integer}","page":"Index of functions and types","title":"Sleipnir.create_results","text":"store_results!(simulation::SIM, glacier_idx::I, solution) where {SIM <: Simulation, I <: Int}\n\nStore the results of a simulation of a single glacier into a Results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}","page":"Index of functions and types","title":"Sleipnir.downscale_2D_climate!","text":"downscale_2D_climate(glacier::Glacier2D)\n\nProjects climate data to the glacier matrix by simply copying the closest gridpoint to all matrix gridpoints. Generates a new RasterStack which is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.fillNaN!","page":"Index of functions and types","title":"Sleipnir.fillNaN!","text":"fillNaN!(x, fill)\n\nConvert empty matrix grid cells into fill value\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.get_cumulative_climate!","page":"Index of functions and types","title":"Sleipnir.get_cumulative_climate!","text":"get_cumulative_climate(climate, gradient_bounds=[-0.009, -0.003], default_grad=-0.0065)\n\nComputes Positive Degree Days (PDDs) and cumulative rainfall and snowfall from climate data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.get_raw_climate_data-Tuple{String}","page":"Index of functions and types","title":"Sleipnir.get_raw_climate_data","text":"get_raw_climate_data(rgi_path::String)\n\nLoad the netCDF file containing the climate data for that glacier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}","page":"Index of functions and types","title":"Sleipnir.initialize_glacier","text":"initialize_glacier(rgi_id::String, parameters::Parameters; smoothing=false, velocities=true)\n\nInitialize a single Glaciers, including its Climate, based on a rgi_id and timestepping arguments.\n\nKeyword arguments\n\n- `rgi_id`: Glacier RGI ID\n- `parameters`: Parameters including the physical and simulation ones\n- `smoothing` Flag determining if smoothing needs to be applied to the surface elevation and ice thickness.\n- `velocities` Flag determining if the ice surface velocities need to be retrieved.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}","page":"Index of functions and types","title":"Sleipnir.initialize_glacier_climate!","text":"function initialize_glacier_climate!(glacier::AbstractGlacier, params::Parameters)\n\nInitializes the Climate data structure for a given Glacier`\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}","page":"Index of functions and types","title":"Sleipnir.initialize_glacier_data","text":"initialize_glacier(rgi_id::String, params::Parameters; smoothing=false, velocities=true)\n\nRetrieves the initial glacier geometry (bedrock + ice thickness) for a glacier with other necessary data (e.g. grid size and ice surface velocities).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}","page":"Index of functions and types","title":"Sleipnir.initialize_glaciers","text":"initialize_glaciers(rgi_ids::Vector{String}, params::Parameters; test=false)\n\nInitialize multiple Glaciers based on a list of RGI IDs and on parameters.\n\nKeyword arguments\n\n- `rgi_ids`: List of RGI IDs of glaciers\n- `params`: `Parameters` object to be passed\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier-Union{Tuple{T}, Tuple{T, String, Vector{Symbol}}} where T","page":"Index of functions and types","title":"Sleipnir.plot_glacier","text":"plot_glacier(results::T, plot_type::String, variables::Vector{Symbol}; kwargs...) -> Figure\n\nGenerate various types of plots for glacier data.\n\nArguments\n\nresults: A custom type containing the results of a glacier simulation.\nplot_type: Type of plot to generate. Options are:\n\"heatmaps\": Heatmaps for glacier variables like :H, :S, :B, :V, :Vx, and :Vy.\n\"difference\": Temporal difference metrics (between start and end) for a variable, with optional metrics like \"hist\" (histogram) and \"difference\".\n\"statistics\": Temporal statistical metrics for a variable, with optional metrics like \"average\", \"median\", \"min\", \"max\", and \"std\".\n\"integrated_volume\": Temporal evolution of the integrated ice volume for a variable.\nvariables: Variables to be plotted, e.g., :H.\n\nOptional Keyword Arguments\n\ntspan: A tuple representing the start and end time for the simulation.\nmetrics: Metrics to visualize, e.g., [\"average\"] for statistics, [\"difference\"] for difference.\n\nReturns\n\nA Figure object containing the desired visualization.\n\nNotes\n\nEnsure the variables and kwargs match the requirements of the specified plot_type.\nThe function routes requests to specific plotting functions based on plot_type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{F}, Tuple{Array{Results{F}, 1}, SIM}} where {F<:AbstractFloat, SIM<:Simulation}","page":"Index of functions and types","title":"Sleipnir.save_results_file!","text":"save_results_file(simulation::Prediction)\n\nSave simulation Results into a .jld2 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.smooth!-Tuple{Any}","page":"Index of functions and types","title":"Sleipnir.smooth!","text":"smooth!(A)\n\nSmooth data contained in a matrix with one time step (CFL) of diffusion.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.stop_condition_tstops-NTuple{4, Any}","page":"Index of functions and types","title":"Sleipnir.stop_condition_tstops","text":"stop_condition_tstops(u,t,integrator, tstops)\n\nFunction that iterates through the tstops, with a closure including tstops\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.trim_period-Tuple{Any, Any}","page":"Index of functions and types","title":"Sleipnir.trim_period","text":"trim_period(period, climate)\n\nTrims a time period based on the time range of a climate series. \n\n\n\n\n\n","category":"method"},{"location":"#ODINN.jl-documentation","page":"Home","title":"ODINN.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the ODINN.jl documentation, a large-scale scientific machine learning (SciML) glacier model, leveraging differentiable programming in Julia. This documentation provides the necessary information to understand the ecosystem built around `ODINN.jl, its APIs, workflows and some examples of the main usage types of the model(s).","category":"page"},{"location":"#Vision","page":"Home","title":"Vision","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rather than focusing on global-scale simulations and sea-level rise contributions, ODINN.jl has, for now, a regional and catchment-scale focus, aiming to exploit the latest remote sensing and in situ observations to capture missing or subgrid processes of glacier processes. In order to do so, ODINN.jl leverages Universal Differential Equations (UDEs), combining PDEs describing ice flow dynamics with data-driven regressors, such as neural networks. For this, ODINN.jl relies heavily on the SciML Julia ecosytem and the native automatic differentiation (AD) support. Therefore ODINN.jl has a two-fold goal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"To advance the application of scientific machine learning and differentiable programming for large-scale geoscientific modelling.\nTo advance the inference of new parametrizations to characterize key missing or subgrid processes of glaciers to improve large-scale glacier simulations. ","category":"page"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ODINN.jl is a modular model, split into multiple packages, each one handling a specific task:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./assets/ODINN_architecture.png\" alt=\"ODINN ecosystem overview\" width=\"500\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"ODINN.j is the high-level interace to the whole ODINN ecosystem, containing the SciML functionalities related to automatic differentiation and sensitivity of hybrid models, mixing differential equations and data-driver regressors. \nHuginn.jl is the ice flow dynamics module of ODINN. It contains all the information regarding glacier ice flow models, including the numerical methods to solve the PDEs using OrdinaryDiffEq.jl. \nMuninn.jl is the surface mass balance module of ODINN. It  contains all the information regarding glacier interactions with the atmosphere (i.e. surface mass balance processes). For now we support simple temperature-index models, but soon we are planning to incorporate machine learning models coming from the MassBalanceMachine. \nSleipnir.jl is the core package of ODINN, holding all the basic data structures and functions, common to the whole ecosystem. It directly reads the files provided by Gungnir. \nGungnir is a Python package, using OGGM to retrieve all the necessary files (i.e. rasters and climate data) for the initial conditions and simulations in all the ODINN ecosystem. The user has the possibility to either store those files locally, or to use the ones we provide in a server. This is work in progress, so we will progressively cover more and more glaciers and regions in the near future. ","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ODINN.jl is being developed by Jordi Bolibar (CNRS, IGE), Facundo Sapienza (Stanford University) and Alban Gossard (Université Grenoble Alpes, IGE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Past developers include Lucille Gimenes (Université Grenoble Alpes, IGE) and Vivek Gajadhar (TU Delft).","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ODINN.jl for research, teaching or other activities, please use the following citation from our latest paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{bolibar_sapienza_universal_2023,\n\ttitle = {Universal differential equations for glacier ice flow modelling},\n\tauthor = {Bolibar, J. and Sapienza, F. and Maussion, F. and Lguensat, R. and Wouters, B. and P\\'erez, F.},\n\tjournal = {Geoscientific Model Development},\n\tvolume = {16},\n\tyear = {2023},\n\tnumber = {22},\n\tpages = {6671--6687},\n\turl = {https://gmd.copernicus.org/articles/16/6671/2023/},\n\tdoi = {10.5194/gmd-16-6671-2023}\n}","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ODINN project has been funded by an IRGA fellowship from the Multidisciplinary Institute on Artificial Intelligence (Grenoble, France), the Nederlandse Organisatie voor Wetenschappelijk Onderzoek, Stichting voor de Technische Wetenschappen (Vidi grant 016.Vidi.171.063), the National Science Foundation (EarthCube programme under awards 1928406 and 1928374) and a TU Delft Climate Action grant. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this section, we present some tutorials to showcase the basic use of ODINN.jl","category":"page"},{"location":"tutorial/#Forward-simulation-tutorial","page":"Tutorial","title":"Forward simulation tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ODINN\n\n# Define the working directory\nworking_dir = joinpath(homedir(), \"ODINN_simulations\")\n\n# Ensure the working directory exists\nmkpath(working_dir)\n\n# Define which glacier RGI IDs we want to work with\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()\n# Filter out glaciers that are not used to avoid having references that depend on all the glaciers processed in Gungnir\nrgi_paths = Dict(k => rgi_paths[k] for k in rgi_ids)\n\n# Create the necessary parameters\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n\t\tmultiprocessing = false,\n        #workers = 5,\n\t\trgi_paths = rgi_paths\n    )\n)\n\n# Specify a model based on an iceflow model, a mass balance model, and a machine learning model\nmodel = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),\n\tmachine_learning = nothing\n)\n\n# We initialize the glaciers with all the necessary data\nglaciers = initialize_glaciers(rgi_ids, params)\n\n# We specify the type of simulation we want to perform\nprediction = Prediction(model, glaciers, params)\n\n# And finally, we just run the simulation\nHuginn.run!(prediction)","category":"page"},{"location":"tutorial/#Step-by-step-explanation-of-the-tutorial","page":"Tutorial","title":"Step-by-step explanation of the tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we will cover in detail each one of the steps that lead us to run the Prediction from the previous example (i.e. a forward run). This first tutorial keeps things simple, and since we are not using machine learning models, we will only use the Model type to specify the iceflow and mass balance models. These functionalities are mainly covered by Huginn.jl.","category":"page"},{"location":"tutorial/#Step-1:-Parameter-initialization","page":"Tutorial","title":"Step 1: Parameter initialization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step is to initialize and specify all the necessary parameters. In ODINN.jl we have many different types of parameters, specifying different aspects of the model. All the parameter types come with a default constructor, which will provide default values in case you don't want to tune those. The main types of parameters are:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Simulation parameters: SimulationParameters includes all the parameters related to the                            ODINN.jl simulation, including the number of workers, the timespan                             of the simulation or the working directory.\nHyperparameters: Hyperparameters includes all the necessary hyperparameters for a machine learning model.\nUDEparameters: UDEparameters contains the parameters related to the training of a Universal Differential Equation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All these sub-types of parameters are held in a Parameters struct, a general parameters structure to be passed to an ODINN simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First we need to specify a list of RGI IDs of the glacier we want to work with. Specifying an RGI region is also possible. From these RGI IDs, we will look for the necessary files inside the workspace.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Filter out glaciers that are not used to avoid having references that depend on all the glaciers processed in Gungnir","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rgi_paths = Dict(k => rgi_paths[k] for k in rgi_ids)\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n\t\tmultiprocessing = false,\n        #workers = 5,\n\t\trgi_paths = rgi_paths\n    )\n)","category":"page"},{"location":"tutorial/#Step-2:-Model-specification","page":"Tutorial","title":"Step 2: Model specification","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The next step is to specify which model(s) we want to use for our simulation. In ODINN we have three different types of model, which are encompassed in a Model structure:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Iceflow model: IceflowModel is the ice flow dynamics model that will be used to simulate                     iceflow. It defaults to a 2D Shallow Ice Approximation.\nSurface mass balance model: MassBalanceModel is the mass balance model that will be used for                             simulations. Options here include temperature-index models, or                             machine learning models coming from MassBalanceMachine.\nMachine learning model: MLmodel is the machine learning model (e.g. a neural network) which will                             be used as part of a hybrid model based on a Universal Differential Equation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Generally, a model can be initialized directly using the Model constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    machine_learning = nothing\n)","category":"page"},{"location":"tutorial/#Step-3:-Glacier-initialization","page":"Tutorial","title":"Step 3: Glacier initialization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The third step is to fetch and initialize all the necessary data for our glaciers of interest. This is strongly built on top of OGGM, mostly providing a Julia interface to automatize this. The package Gungnir is used to fetch the necessary data from the RGI and other sources. The data is then stored in servers and fetched and read using Rasters.jl directly by Sleipnir.jl when needed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, we initialize those glaciers based on those RGI IDs and the parameters we previously specified.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"glaciers = initialize_glaciers(rgi_ids, params)","category":"page"},{"location":"tutorial/#Step-4:-Creating-and-running-a-simulation","page":"Tutorial","title":"Step 4: Creating and running a simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The final step of the pipeline, is to create an ODINN simulation based on all the previous steps, and then to run it. There are different types of simulations that we can do with ODINN:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Prediction: This is a forward simulation, where the initial glacier conditions are run forward in                 in time based on specified parameters and climate data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is as simple as doing:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prediction = Prediction(model, glaciers, params)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And once we have the Prediction object, we can run it using Huginn.run!:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Huginn.run!(prediction)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There we go, we have successfully simulated the evolution of 3 glaciers for 5 years in a second!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"funcs_types/#Index-of-functions-and-types","page":"Index of functions and types","title":"Index of functions and types","text":"","category":"section"},{"location":"funcs_types/#Parameters","page":"Index of functions and types","title":"Parameters","text":"","category":"section"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"There are different types of parameters, holding specific information for different modelling aspects. All the types of parameters are wrapped into a Parameter type, which is threaded throughout ODINN.jl. ","category":"page"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"Sleipnir.SimulationParameters\nSleipnir.PhysicalParameters\nODINN.Hyperparameters\nODINN.UDEparameters","category":"page"},{"location":"funcs_types/#Sleipnir.SimulationParameters","page":"Index of functions and types","title":"Sleipnir.SimulationParameters","text":"SimulationParameters(;\n                    use_MB::Bool = true,\n                    use_iceflow::Bool = true,\n                    plots::Bool = true,\n                    velocities::Bool = true,\n                    overwrite_climate::Bool = false,\n                    use_glathida_data::Bool = false,\n                    float_type::DataType = Float64,\n                    int_type::DataType = Int64,\n                    tspan::Tuple{F, F} = (2010.0,2015.0),\n                    step::F = 1/12,\n                    multiprocessing::Bool = true,\n                    workers::I = 4,\n                    working_dir::String = \"\",\n                    test_mode::Bool = false,\n                    rgi_paths::Dict{String, String} = Dict{String, String}(),\n                    ice_thickness_source::String = \"Farinotti19\",\n    )\n\nInitialize the parameters for a simulation. Keyword arguments =================     - use_MB: Determines if surface mass balance should be used.     - plots: Determines if plots should be made.     - overwrite_climate: Determines if climate data should be overwritten     - 'useglathidadata': Determines if data from the Glathida data set should be used\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#Sleipnir.PhysicalParameters","page":"Index of functions and types","title":"Sleipnir.PhysicalParameters","text":"PhysicalParameters(;\n    ρ::Float64 = 900.0,\n    g::Float64 = 9.81,\n    ϵ::Float64 = 1e-3,\n    η₀::F = 1.0, \n    maxA::Float64 = 8e-17,\n    minA::Float64 = 8.5e-20,\n    maxTlaw::Float64 = 1.0,\n    minTlaw::Float64 = -25.0,\n    noise_A_magnitude::Float64 = 5e-18\n    )\n\nInitialize the physical parameters of a model. Keyword arguments =================     - ρ: Ice density     - g: Gravitational constant     - n: Glen's exponent     - A: Glen's coefficient     - ϵ: Small number     - C: Sliding coefficient     - η₀:       - maxA: Maximum value for A (Glen's coefficient)     - minA: Minimum value for A (Glen's coefficient)\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.Hyperparameters","page":"Index of functions and types","title":"ODINN.Hyperparameters","text":"Hyperparameters(;\n    current_epoch::Int64 = nothing,\n    current_minibatch::Int64 = nothing,\n    loss_history::Vector{Float64} = Vector{Float64}(),\n    optimizer::Optim.FirstOrderOptimizer = BFGS(initial_stepnorm=0.001),\n    epochs::Int64 = 50,\n    batch_size::Int64 = 15\n    )\n\nInitialize the hyperparameters of a machine learning model (Machine). Keyword arguments =================     - current_epoch: Current epoch in training     - current_minibatch: Current minibatch in training     - loss_history: Vector storing the loss for each epoch during training     - optimizer: Optimizer to be used for training. Currently supports both Optim.jl and Flux.jl optimisers.     - epochs: Number of epochs for the training     - batch_size: Batch size for the training\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/#ODINN.UDEparameters","page":"Index of functions and types","title":"ODINN.UDEparameters","text":"UDEparameters(;\n    sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm = GaussAdjoint(autojacvec=EnzymeVJP()),\n    optimization_method::String = \"AD+AD\",\n    loss_type::String = \"V\",\n    scale_loss::Bool = true\n    target::String = \"D\"\n    )\n\nInitialize the parameters for the training of the UDE. Keyword arguments =================     - sensealg: Sensitivity algorithm from SciMLSensitivity.jl to be used.     - optimization_method: Optimization method for the UDE.     - loss_type: Type of loss function to be used. Can be either V (ice velocities), or H (ice thickness).     - scale_loss: Determines if the loss function should be scaled or not.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"All these subtypes of parameters are gathered in a Parameters struct:","category":"page"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"ODINN.Parameters","category":"page"},{"location":"funcs_types/#ODINN.Parameters","page":"Index of functions and types","title":"ODINN.Parameters","text":"Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters(),         solver::SolverParameters = SolverParameters(),         hyper::Hyperparameters = Hyperparameters(),         UDE::UDEparameters = UDEparameters()         inversion::InversionParameters = InversionParameters()         ) Initialize ODINN parameters\n\nKeyword arguments\n\nphysical::PhysicalParameters: Physical parameters for the simulation.\nsimulation::SimulationParameters: Parameters related to the simulation setup.\nsolver::SolverParameters: Parameters for the solver configuration.\nhyper::Hyperparameters: Hyperparameters for the model.\nUDE::UDEparameters: Parameters specific to the UDE (Universal Differential Equation).\ninversion::InversionParameters: Parameters for inversion processes.\n\n\n\n\n\n","category":"function"},{"location":"funcs_types/#Glaciers","page":"Index of functions and types","title":"Glaciers","text":"","category":"section"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"Glaciers in ODINN.jl are represented by a Glacier type. Each glacier has its related Climate. Since ODINN.jl supports different types of simulations, we offer the possibility to work on 1D (i.e. flowline), 2D (e.g. SIA) or even 3D (not yet implemented, e.g. Full Stokes).","category":"page"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"Sleipnir.Glacier2D","category":"page"},{"location":"funcs_types/#Sleipnir.Glacier2D","page":"Index of functions and types","title":"Sleipnir.Glacier2D","text":"function Glacier2D(;     rgiid::Union{String, Nothing} = nothing,     climate::Union{Climate2D, Nothing} = nothing,     H₀::Union{Matrix{F}, Nothing} = nothing,     Hglathida::Union{Matrix{F}, Nothing} = nothing,     S::Union{Matrix{F}, Nothing} = nothing,     B::Union{Matrix{F}, Nothing} = nothing,     V::Union{Matrix{F}, Nothing}= nothing,     Vx::Union{Matrix{F}, Nothing}= nothing,     Vy::Union{Matrix{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     slope::Union{Matrix{F}, Nothing} = nothing,     distborder::Union{Matrix{F}, Nothing} = nothing,     Scoords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing,     cenlon::Union{F, Nothing} = nothing,     cenlat::Union{F, Nothing} = nothing     ) where {F <: AbstractFloat, I <: Integer}\n\nConstructor for empty 2D Glacier object.\n\n\n\n\n\n","category":"type"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"Every glacier has its associated climate, following the same spatial representation (e.g. 2D):","category":"page"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"<!– @docs Sleipnir.Climate2D –>","category":"page"},{"location":"funcs_types/#Models","page":"Index of functions and types","title":"Models","text":"","category":"section"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"There are 3 main types of models in ODINN.jl, iceflow models, mass balance models and machine learning models. ","category":"page"},{"location":"funcs_types/","page":"Index of functions and types","title":"Index of functions and types","text":"Work in progress...","category":"page"}]
}
