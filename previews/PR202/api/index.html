<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index of functions and types · ODINN.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ODINN-SciML.github.io/ODINN.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../funcs_types/">Index of functions and types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index of functions and types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index of functions and types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index-of-functions-and-types"><a class="docs-heading-anchor" href="#Index-of-functions-and-types">Index of functions and types</a><a id="Index-of-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Index-of-functions-and-types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ODINN.FunctionalInversion" href="#ODINN.FunctionalInversion"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FunctionalInversion &lt;: Simulation</code></pre><p>An object representing a functional inversion simulation (i.e. the inversion of a function using some data-driven regressor).</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li><li><code>results::Vector{Results}</code>: A vector to store the results of the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/functional_inversions/FunctionalInversion.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.FunctionalInversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#ODINN.FunctionalInversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function FunctionalInversion(
    model::Sleipnir.Model,
    glaciers::Vector{G},
    parameters::Sleipnir.Parameters
) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Constructor for FunctionalInversion struct with glacier model information, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>FunctionalInversion</code>: A new instance of the FunctionalInversion struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/functional_inversions/FunctionalInversion.jl#L22-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Hyperparameters-Tuple{}" href="#ODINN.Hyperparameters-Tuple{}"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hyperparameters(;
    current_epoch::Int64 = nothing,
    current_minibatch::Int64 = nothing,
    loss_history::Vector{Float64} = Vector{Float64}(),
    optimizer::Optim.FirstOrderOptimizer = BFGS(initial_stepnorm=0.001),
    epochs::Int64 = 50,
    batch_size::Int64 = 15
    )</code></pre><p>Initialize the hyperparameters of a machine learning model (<code>Machine</code>). Keyword arguments =================     - <code>current_epoch</code>: Current epoch in training     - <code>current_minibatch</code>: Current minibatch in training     - <code>loss_history</code>: <code>Vector</code> storing the loss for each epoch during training     - <code>optimizer</code>: Optimizer to be used for training. Currently supports both <code>Optim.jl</code> and <code>Flux.jl</code> optimisers.     - <code>epochs</code>: Number of epochs for the training     - <code>batch_size</code>: Batch size for the training</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/parameters/Hyperparameters.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Inversion" href="#ODINN.Inversion"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Inversion &lt;: Simulation</code></pre><p>A mutable struct that represents an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the inversion.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the inversion.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the inversion.</li><li><code>inversion::Vector{InversionResults}</code>: A vector of results from the inversion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/inversions/Inversion.jl#L62-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Inversion(
    model::Sleipnir.Model,
    glaciers::Vector{Sleipnir.AbstractGlacier},
    parameters::Sleipnir.Parameters
    )</code></pre><p>Construnctor for Inversion struct with glacier model infomation, glaciers and parameters. Keyword arguments =================</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/inversions/Inversion.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.InversionParameters" href="#ODINN.InversionParameters"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}</code></pre><p>A mutable struct that holds parameters for inversion processes. This struct is a subtype of <code>AbstractParameters</code>.</p><p><strong>Fields</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: A vector of initial conditions.</li><li><code>lower_bound::Vector{F}</code>: A vector specifying the lower bounds for the parameters.</li><li><code>upper_bound::Vector{F}</code>: A vector specifying the upper bounds for the parameters.</li><li><code>regions_split::Vector{Int}</code>: A vector indicating how the regions are split.</li><li><code>x_tol::F</code>: The tolerance for the solution&#39;s x-values.</li><li><code>f_tol::F</code>: The tolerance for the function values.</li><li><code>solver::Any</code>: The solver to be used for the inversion process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/parameters/InversionParameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat" href="#ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}(;
    initial_conditions::Vector{F} = [1.0],
    lower_bound::Vector{F} = [0.0],
    upper_bound::Vector{F} = [Inf],
    regions_split::Vector{Int} = [1, 1],
    x_tol::F = 1.0e-3,
    f_tol::F = 1.0e-3,
    solver = BFGS()
)</code></pre><p>Initialize the parameters for the inversion process.</p><p><strong>Arguments</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: Starting point for optimization.</li><li><code>lower_bound::Vector{F}</code>: Lower bounds for optimization variables.</li><li><code>upper_bound::Vector{F}</code>: Upper bounds for optimization variables.</li><li><code>regions_split::Vector{Int}</code>: Defines the amount of region split based on altitude and distance to border for the inversion process.</li><li><code>x_tol::F</code>: Tolerance for variables convergence.</li><li><code>f_tol::F</code>: Tolerance for function value convergence.</li><li><code>solver</code>: Optimization solver to be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/parameters/InversionParameters.jl#L27-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.InversionResults" href="#ODINN.InversionResults"><code>ODINN.InversionResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct InversionResults{F &lt;: Real}</code></pre><p>A structure to store the results of an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::Union{String, Nothing}</code>: The RGI identifier, which can be a string or nothing.</li><li><code>A::F</code>: Area parameter.</li><li><code>n::F</code>: Exponent parameter.</li><li><code>C::Matrix{F}</code>: Coefficient matrix.</li><li><code>H_pred::Matrix{F}</code>: Predicted height matrix.</li><li><code>H_obs::Matrix{F}</code>: Observed height matrix.</li><li><code>H_diff::Matrix{F}</code>: Difference between predicted and observed height matrices.</li><li><code>V_pred::Matrix{F}</code>: Predicted volume matrix.</li><li><code>V_obs::Matrix{F}</code>: Observed volume matrix.</li><li><code>V_diff::Matrix{F}</code>: Difference between predicted and observed volume matrices.</li><li><code>MSE::F</code>: Mean squared error.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::F</code>: Longitude.</li><li><code>lat::F</code>: Latitude.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/inversions/Inversion.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.NN" href="#ODINN.NN"><code>ODINN.NN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NN{F &lt;: AbstractFloat}(architecture::Flux.Chain, NN_f::Optimisers.Restructure, θ::Vector{F})</code></pre><p>Feed-forward neural network.</p><p><strong>Fields</strong></p><ul><li><code>architecture</code>: <code>Flux.Chain</code> neural network architecture</li><li><code>NN_f</code>: Neural network restructuring</li><li><code>θ</code>: Neural network parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/MLmodel.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.NN-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat" href="#ODINN.NN-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat"><code>ODINN.NN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NN(params::Parameters;
    architecture::Union{Flux.Chain, Nothing} = nothing,
    θ::Union{Vector{AbstractFloat}, Nothing} = nothing)</code></pre><p>Creates a new feed-forward neural network.</p><p><strong>Keyword arguments</strong></p><ul><li><code>architecture</code>: <code>Flux.Chain</code> neural network architecture (optional)</li><li><code>θ</code>: Neural network parameters (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/MLmodel.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.UDEparameters-Tuple{}" href="#ODINN.UDEparameters-Tuple{}"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UDEparameters(;
    sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm = GaussAdjoint(autojacvec=EnzymeVJP()),
    optimization_method::String = &quot;AD+AD&quot;,
    loss_type::String = &quot;V&quot;,
    scale_loss::Bool = true
    target::String = &quot;D&quot;
    )</code></pre><p>Initialize the parameters for the training of the UDE. Keyword arguments =================     - <code>sensealg</code>: Sensitivity algorithm from SciMLSensitivity.jl to be used.     - <code>optimization_method</code>: Optimization method for the UDE.     - <code>loss_type</code>: Type of loss function to be used. Can be either <code>V</code> (ice velocities), or <code>H</code> (ice thickness).     - <code>scale_loss</code>: Determines if the loss function should be scaled or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/parameters/UDEparameters.jl#L14-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, MLM&lt;:ODINN.MLmodel}" href="#ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, MLM&lt;:ODINN.MLmodel}"><code>ODINN.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Model(;     iceflow::Union{IFM, Nothing},     mass<em>balance::Union{MBM, Nothing}     machine</em>learning::Union{MLM, Nothing},     ) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel, MLM &lt;: MLmodel}</p><p>Initialize Model at ODINN level (iceflow + mass balance + machine learning).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/MLmodel.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.Parameters-Tuple{}" href="#ODINN.Parameters-Tuple{}"><code>ODINN.Parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters(),         solver::SolverParameters = SolverParameters(),         hyper::Hyperparameters = Hyperparameters(),         UDE::UDEparameters = UDEparameters()         inversion::InversionParameters = InversionParameters()         ) Initialize ODINN parameters</p><p><strong>Keyword arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: Physical parameters for the simulation.</li><li><code>simulation::SimulationParameters</code>: Parameters related to the simulation setup.</li><li><code>solver::SolverParameters</code>: Parameters for the solver configuration.</li><li><code>hyper::Hyperparameters</code>: Hyperparameters for the model.</li><li><code>UDE::UDEparameters</code>: Parameters specific to the UDE (Universal Differential Equation).</li><li><code>inversion::InversionParameters</code>: Parameters for inversion processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/parameters/UDEparameters.jl#L50-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}" href="#ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}"><code>ODINN.enable_multiprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Initialize_ODINN(processes, python_path)</code></pre><p>Initializes ODINN by configuring PyCall based on a given Python path. It also configures multiprocessing for a given number of processes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/setup/config.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.generate_batches-Tuple{S} where S&lt;:Simulation" href="#ODINN.generate_batches-Tuple{S} where S&lt;:Simulation"><code>ODINN.generate_batches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_batches(simulation::S; shuffle=true)</code></pre><p>Generates batches for the UE inversion problem based on input data and feed them to the loss function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/ML_utils.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.get_NN-Tuple{Any}" href="#ODINN.get_NN-Tuple{Any}"><code>ODINN.get_NN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_NN(θ_trained)</code></pre><p>Generates a neural network.</p><p><strong>Arguments</strong></p><ul><li><code>θ_trained</code>: Pre-trained neural network parameters (optional).</li></ul><p><strong>Returns</strong></p><ul><li><code>UA</code>: <code>Flux.Chain</code> neural network architecture.</li><li><code>θ</code>: Neural network parameters.</li><li><code>UA_f</code>: Neural network restructuring.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/ML_utils.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.predict_A̅-Tuple{Any, Any}" href="#ODINN.predict_A̅-Tuple{Any, Any}"><code>ODINN.predict_A̅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_A̅(U, temp)</code></pre><p>Predicts the value of A with a neural network based on the long-term air temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/ML_utils.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.run!-Tuple{FunctionalInversion}" href="#ODINN.run!-Tuple{FunctionalInversion}"><code>ODINN.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>run!(simulation::FunctionalInversion)</p><p>In-place run of the model. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/functional_inversions/functional_inversion_utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.sigmoid_A-Tuple{Any}" href="#ODINN.sigmoid_A-Tuple{Any}"><code>ODINN.sigmoid_A</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigmoid_A(x)</code></pre><p>Sigmoid activation function for the neural network output.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input value.</li></ul><p><strong>Returns</strong></p><ul><li>Sigmoid-transformed output value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/ML_utils.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.sigmoid_A_inv-Tuple{Any}" href="#ODINN.sigmoid_A_inv-Tuple{Any}"><code>ODINN.sigmoid_A_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigmoid_A_inv(x)</code></pre><p>Inverse sigmoid activation function for the neural network output.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input value.</li></ul><p><strong>Returns</strong></p><ul><li>Inverse sigmoid-transformed output value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/ML_utils.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback, I}} where {I&lt;:Integer, SIM&lt;:Simulation}" href="#ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback, I}} where {I&lt;:Integer, SIM&lt;:Simulation}"><code>ODINN.simulate_iceflow_UDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function simulate<em>iceflow</em>UDE!(     θ,     simulation::SIM,      model::Sleipnir.Model,      params::Sleipnir.Parameters,      cb::DiscreteCallback,     batch_id::I;      du = Huginn.SIA2D) where {I &lt;: Integer, SIM &lt;: Simulation}</p><p>Make forward simulation of the iceflow UDE determined in <code>du</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/functional_inversions/functional_inversion_utils.jl#L161-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.train_UDE!-Tuple{FunctionalInversion}" href="#ODINN.train_UDE!-Tuple{FunctionalInversion}"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>train_UDE!(simulation::FunctionalInversion) </p><p>Trains UDE based on the current FunctionalInversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/simulations/functional_inversions/functional_inversion_utils.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation" href="#ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation"><code>ODINN.update_training_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_training_state!(simulation::S, l) where {S &lt;: Simulation}</code></pre><p>Update the training state to determine if the training has completed an epoch. If an epoch is completed, reset the minibatches, update the history loss, and increment the epoch count.</p><p><strong>Arguments</strong></p><ul><li><code>simulation</code>: The current state of the simulation or training process.</li><li><code>l</code>: The current loss value or other relevant metric.</li></ul><p><strong>Returns</strong></p><ul><li>None. This function updates the state in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/ecdf473352ccb2ab228794cb2d649229a075eadd/src/models/machine_learning/ML_utils.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier" href="#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Prediction(
    model::Sleipnir.Model,
    glaciers::Vector{Sleipnir.AbstractGlacier},
    parameters::Sleipnir.Parameters
    )</code></pre><p>Construnctor for Prediction struct with glacier model infomation, glaciers and parameters. Keyword arguments =================</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}" href="#Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolverParameters(;
    solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),
    reltol::Float64 = 1e-7
    )</code></pre><p>Initialize the parameters for the numerical solver. Keyword arguments =================     - <code>solver</code>: solver to use from DifferentialEquations.jl     - <code>reltol</code>: Relative tolerance for the solver</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}" href="#Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, SIM&lt;:Simulation}"><code>Huginn.SIA2D!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>SIA2D!(dH, H, SIA2Dmodel)</p><p>Compute an in-place step of the Shallow Ice Approximation PDE in a forward model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}" href="#Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}"><code>Huginn.SIA2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SIA(H, SIA2Dmodel)</code></pre><p>Compute a step of the Shallow Ice Approximation UDE in a forward model. Allocates memory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg-Tuple{Any}" href="#Huginn.avg-Tuple{Any}"><code>Huginn.avg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg(A)</code></pre><p>4-point average of a matrix</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_surface_V!-Tuple{SIM} where SIM&lt;:Simulation" href="#Huginn.avg_surface_V!-Tuple{SIM} where SIM&lt;:Simulation"><code>Huginn.avg_surface_V!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_surface_V(simulation::SIM)</code></pre><p>Computes the average ice surface velocity for a given glacier evolution period based on the initial and final ice thickness states. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I&lt;:Integer, SIM&lt;:Simulation}" href="#Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I&lt;:Integer, SIM&lt;:Simulation}"><code>Huginn.avg_surface_V</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_surface_V(context, H, temp, sim, θ=[], UA_f=[])</code></pre><p>Computes the average ice surface velocity for a given glacier evolution period based on the initial and final ice thickness states. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_x-Tuple{Any}" href="#Huginn.avg_x-Tuple{Any}"><code>Huginn.avg_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_x(A)</code></pre><p>2-point average of a matrix&#39;s X axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.avg_y-Tuple{Any}" href="#Huginn.avg_y-Tuple{Any}"><code>Huginn.avg_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">avg_y(A)</code></pre><p>2-point average of a matrix&#39;s Y axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer" href="#Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer"><code>Huginn.batch_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE!(glacier_idx::I, simulation::Prediction)</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE for a given temperature series batch in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer" href="#Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer"><code>Huginn.batch_iceflow_PDE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE(glacier_idx::I, simulation::Prediction)</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE for a given temperature series batch out-of-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.define_callback_steps-Tuple{Tuple{Float64, Float64}, Float64}" href="#Huginn.define_callback_steps-Tuple{Tuple{Float64, Float64}, Float64}"><code>Huginn.define_callback_steps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">define_callback_steps(tspan::Tuple{Float64, Float64}, step::Float64)</code></pre><p>Defines the times to stop for the DiscreteCallback given a step</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.diff_x-Tuple{Any}" href="#Huginn.diff_x-Tuple{Any}"><code>Huginn.diff_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_x(A)</code></pre><p>2-point differential of a matrix&#39;s X axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.diff_y-Tuple{Any}" href="#Huginn.diff_y-Tuple{Any}"><code>Huginn.diff_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_y(A)</code></pre><p>2-point differential of a matrix&#39;s Y axis</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer, G&lt;:AbstractGlacier}" href="#Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer, G&lt;:AbstractGlacier}"><code>Huginn.initialize_iceflow_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function initialize<em>iceflow</em>model!(iceflow<em>model::IF,       glacier</em>idx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters     ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable in-place mutation.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `iceflow_model`: Iceflow model used for simulation. 
- `glacier_idx`: Index of glacier.
- `glacier`: `Glacier` to provide basic initial state of the ice flow model.
- `parameters`: `Parameters` to configure some physical variables.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer}" href="#Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer}"><code>Huginn.initialize_iceflow_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function initialize<em>iceflow</em>model(iceflow<em>model::IF,       glacier</em>idx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters     ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable out-of-place mutation.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `iceflow_model`: Iceflow model used for simulation. 
- `glacier_idx`: Index of glacier.
- `glacier`: `Glacier` to provide basic initial state of the ice flow model.
- `parameters`: `Parameters` to configure some physical variables.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.inn-Tuple{Any}" href="#Huginn.inn-Tuple{Any}"><code>Huginn.inn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inn(A)</code></pre><p>Access the inner part of the matrix (-2,-2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.inn1-Tuple{Any}" href="#Huginn.inn1-Tuple{Any}"><code>Huginn.inn1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inn1(A)</code></pre><p>Access the inner part of the matrix (-1,-1)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.run!-Tuple{Prediction}" href="#Huginn.run!-Tuple{Prediction}"><code>Huginn.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(simulation::Prediction)</code></pre><p>In-place run of the model. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.run₀-Tuple{Prediction}" href="#Huginn.run₀-Tuple{Prediction}"><code>Huginn.run₀</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(simulation::Prediction)</code></pre><p>Out-of-place run of the model. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation" href="#Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation"><code>Huginn.simulate_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate_iceflow_PDE!(
    simulation::SIM, 
    model::Sleipnir.Model, 
    params::Sleipnir.Parameters, 
    cb::DiscreteCallback; 
    du = SIA2D!) where {SIM &lt;: Simulation}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation" href="#Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, Sleipnir.Model, Sleipnir.Parameters, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation"><code>Huginn.simulate_iceflow_PDE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function simulate_iceflow_PDE(
    simulation::SIM, 
    model::Sleipnir.Model, 
    params::Sleipnir.Parameters, 
    cb::DiscreteCallback; 
    du = SIA2D) where {SIM &lt;: Simulation}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation" href="#Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation"><code>Huginn.surface_V!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surface_V!(H, B, Δx, Δy, temp, sim, A_noise, θ=[], UA_f=[])</code></pre><p>Computes the ice surface velocity for a given glacier state</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I&lt;:Integer, R&lt;:Real, SIM&lt;:Simulation}" href="#Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I&lt;:Integer, R&lt;:Real, SIM&lt;:Simulation}"><code>Huginn.surface_V</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surface_V(H, B, Δx, Δy, temp, sim, A_noise, θ=[], UA_f=[])</code></pre><p>Computes the ice surface velocity for a given glacier state</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat" href="#Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TImodel1(params::Sleipnir.Parameters;
    DDF::Float64 = 7.0/1000.0,
    acc_factor::Float64 = 1.0/1000.0
    )</code></pre><p>Temperature-index model with a single degree-day factor.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `DDF`: Single degree-day factor, for both snow and ice.
- `acc_factor`: Accumulation factor</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat" href="#Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat"><code>Muninn.TImodel2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TImodel2(params::Parameters;
    DDF_snow::Float64 = 3.0/1000.0,
    DDF_ice::Float64 = 6.0/1000.0,
    acc_factor::Float64 = 1.0/1000.0
    )</code></pre><p>Temperature-index model with two melt factors, for snow and ice.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `DDF_snow`: Degree-day factor for snow.
- `DDF_ice`: Degree-day factor for ice.
- `acc_factor`: Accumulation factor</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I&lt;:Integer, F&lt;:AbstractFloat, G&lt;:AbstractGlacier}" href="#Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I&lt;:Integer, F&lt;:AbstractFloat, G&lt;:AbstractGlacier}"><code>Muninn.MB_timestep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MB_timestep!(model::Model, glacier::G, step::F, t; batch_id::Union{Nothing, I} = nothing) where {I &lt;: Integer, F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Retrieve the climate data, apply downscaling and compute the mass balance of a glacier for a specific time step and possibly for a batch of iceflow models.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}" href="#Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}"><code>Muninn.MB_timestep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MB_timestep(model::Model, glacier::G, step::F, t::F) where {F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Retrieve the climate data, apply downscaling and compute the mass balance of a glacier for a specific time step.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}" href="#Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}"><code>Muninn.compute_MB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_MB(mb_model::TImodel1, climate_2D_period::Climate2Dstep)</code></pre><p>Compute the the mass balance given a mass balance model and a climate step.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `mb_model`: Mass balance model.
- `climate_2D_period`: Climate step.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}" href="#Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}"><code>Sleipnir.Glacier1D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Glacier1D(;     rgi<em>id::Union{String, Nothing} = nothing,     climate::Union{Climate1D, Nothing} = nothing,     H₀::Union{Vector{F}, Nothing} = nothing,     S::Union{Vector{F}, Nothing} = nothing,     B::Union{Vector{F}, Nothing} = nothing,     V::Union{Vector{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     w₀::Union{Vector{F}, Nothing} = nothing,     λ::Union{Vector{F}, Nothing} = nothing,     slope::Union{Vector{F}, Nothing} = nothing,     dist</em>border::Union{Vector{F}, Nothing} = nothing,     S_coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing     ) where {F &lt;: AbstractFloat, I &lt;: Integer}</p><p>Constructor for empty 2D Glacier object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}" href="#Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Glacier2D(;     rgi<em>id::Union{String, Nothing} = nothing,     climate::Union{Climate2D, Nothing} = nothing,     H₀::Union{Matrix{F}, Nothing} = nothing,     H</em>glathida::Union{Matrix{F}, Nothing} = nothing,     S::Union{Matrix{F}, Nothing} = nothing,     B::Union{Matrix{F}, Nothing} = nothing,     V::Union{Matrix{F}, Nothing}= nothing,     Vx::Union{Matrix{F}, Nothing}= nothing,     Vy::Union{Matrix{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     slope::Union{Matrix{F}, Nothing} = nothing,     dist<em>border::Union{Matrix{F}, Nothing} = nothing,     S</em>coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing,     cenlon::Union{F, Nothing} = nothing,     cenlat::Union{F, Nothing} = nothing     ) where {F &lt;: AbstractFloat, I &lt;: Integer}</p><p>Constructor for empty 2D Glacier object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.Parameters-Tuple{}" href="#Sleipnir.Parameters-Tuple{}"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parameters(;         physical::PhysicalParameters = PhysicalParameters(),         simulation::SimulationParameters = SimulationParameters()         ) Initialize ODINN parameters</p><p><strong>Keyword arguments</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat" href="#Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PhysicalParameters(;
    ρ::Float64 = 900.0,
    g::Float64 = 9.81,
    ϵ::Float64 = 1e-3,
    η₀::F = 1.0, 
    maxA::Float64 = 8e-17,
    minA::Float64 = 8.5e-20,
    maxTlaw::Float64 = 1.0,
    minTlaw::Float64 = -25.0,
    noise_A_magnitude::Float64 = 5e-18
    )</code></pre><p>Initialize the physical parameters of a model. Keyword arguments =================     - <code>ρ</code>: Ice density     - <code>g</code>: Gravitational constant     - <code>n</code>: Glen&#39;s exponent     - <code>A</code>: Glen&#39;s coefficient     - <code>ϵ</code>: Small number     - <code>C</code>: Sliding coefficient     - <code>η₀</code>:       - <code>maxA</code>: Maximum value for <code>A</code> (Glen&#39;s coefficient)     - <code>minA</code>: Minimum value for <code>A</code> (Glen&#39;s coefficient)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat}" href="#Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat}"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimulationParameters(;
                    use_MB::Bool = true,
                    use_iceflow::Bool = true,
                    plots::Bool = true,
                    velocities::Bool = true,
                    overwrite_climate::Bool = false,
                    use_glathida_data::Bool = false,
                    float_type::DataType = Float64,
                    int_type::DataType = Int64,
                    tspan::Tuple{F, F} = (2010.0,2015.0),
                    step::F = 1/12,
                    multiprocessing::Bool = true,
                    workers::I = 4,
                    working_dir::String = &quot;&quot;,
                    test_mode::Bool = false,
                    rgi_paths::Dict{String, String} = Dict{String, String}(),
                    ice_thickness_source::String = &quot;Farinotti19&quot;,
    )</code></pre><p>Initialize the parameters for a simulation. Keyword arguments =================     - <code>use_MB</code>: Determines if surface mass balance should be used.     - <code>plots</code>: Determines if plots should be made.     - <code>overwrite_climate</code>: Determines if climate data should be overwritten     - &#39;use<em>glathida</em>data&#39;: Determines if data from the Glathida data set should be used</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}" href="#Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}"><code>Sleipnir.apply_t_grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_t_grad!(climate::RasterStack, dem::Raster)</code></pre><p>Applies temperature gradients to the glacier 2D climate data based on a DEM.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM&lt;:Simulation, I&lt;:Integer}" href="#Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM&lt;:Simulation, I&lt;:Integer}"><code>Sleipnir.create_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">store_results!(simulation::SIM, glacier_idx::I, solution) where {SIM &lt;: Simulation, I &lt;: Int}</code></pre><p>Store the results of a simulation of a single glacier into a <code>Results</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}" href="#Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}"><code>Sleipnir.downscale_2D_climate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">downscale_2D_climate(glacier::Glacier2D)</code></pre><p>Projects climate data to the glacier matrix by simply copying the closest gridpoint to all matrix gridpoints. Generates a new RasterStack which is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.fillNaN!" href="#Sleipnir.fillNaN!"><code>Sleipnir.fillNaN!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fillNaN!(x, fill)</p><p>Convert empty matrix grid cells into fill value</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.get_cumulative_climate!" href="#Sleipnir.get_cumulative_climate!"><code>Sleipnir.get_cumulative_climate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cumulative_climate(climate, gradient_bounds=[-0.009, -0.003], default_grad=-0.0065)</code></pre><p>Computes Positive Degree Days (PDDs) and cumulative rainfall and snowfall from climate data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.get_raw_climate_data-Tuple{String}" href="#Sleipnir.get_raw_climate_data-Tuple{String}"><code>Sleipnir.get_raw_climate_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_raw_climate_data(rgi_path::String)</code></pre><p>Load the netCDF file containing the climate data for that glacier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}" href="#Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}"><code>Sleipnir.initialize_glacier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_glacier(rgi_id::String, parameters::Parameters; smoothing=false, velocities=true)</code></pre><p>Initialize a single <code>Glacier</code>s, including its <code>Climate</code>, based on a <code>rgi_id</code> and timestepping arguments.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `rgi_id`: Glacier RGI ID
- `parameters`: Parameters including the physical and simulation ones
- `smoothing` Flag determining if smoothing needs to be applied to the surface elevation and ice thickness.
- `velocities` Flag determining if the ice surface velocities need to be retrieved.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}" href="#Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}"><code>Sleipnir.initialize_glacier_climate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function initialize_glacier_climate!(glacier::AbstractGlacier, params::Parameters)</code></pre><p>Initializes the <code>Climate</code> data structure for a given <code>Glacier</code>`</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}" href="#Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}"><code>Sleipnir.initialize_glacier_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_glacier(rgi_id::String, params::Parameters; smoothing=false, velocities=true)</code></pre><p>Retrieves the initial glacier geometry (bedrock + ice thickness) for a glacier with other necessary data (e.g. grid size and ice surface velocities).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}" href="#Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}"><code>Sleipnir.initialize_glaciers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_glaciers(rgi_ids::Vector{String}, params::Parameters; test=false)</code></pre><p>Initialize multiple <code>Glacier</code>s based on a list of RGI IDs and on parameters.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `rgi_ids`: List of RGI IDs of glaciers
- `params`: `Parameters` object to be passed</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.plot_glacier-Union{Tuple{T}, Tuple{T, String, Vector{Symbol}}} where T" href="#Sleipnir.plot_glacier-Union{Tuple{T}, Tuple{T, String, Vector{Symbol}}} where T"><code>Sleipnir.plot_glacier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_glacier(results::T, plot_type::String, variables::Vector{Symbol}; kwargs...) -&gt; Figure</code></pre><p>Generate various types of plots for glacier data.</p><p><strong>Arguments</strong></p><ul><li><code>results</code>: A custom type containing the results of a glacier simulation.</li><li><code>plot_type</code>: Type of plot to generate. Options are:<ul><li>&quot;heatmaps&quot;: Heatmaps for glacier variables like <code>:H</code>, <code>:S</code>, <code>:B</code>, <code>:V</code>, <code>:Vx</code>, and <code>:Vy</code>.</li><li>&quot;difference&quot;: Temporal difference metrics (between start and end) for a variable, with optional metrics like &quot;hist&quot; (histogram) and &quot;difference&quot;.</li><li>&quot;statistics&quot;: Temporal statistical metrics for a variable, with optional metrics like &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;.</li><li>&quot;integrated_volume&quot;: Temporal evolution of the integrated ice volume for a variable.</li></ul></li><li><code>variables</code>: Variables to be plotted, e.g., <code>:H</code>.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics</code>: Metrics to visualize, e.g., <code>[&quot;average&quot;]</code> for statistics, <code>[&quot;difference&quot;]</code> for difference.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Figure</code> object containing the desired visualization.</li></ul><p><strong>Notes</strong></p><ul><li>Ensure the <code>variables</code> and <code>kwargs</code> match the requirements of the specified <code>plot_type</code>.</li><li>The function routes requests to specific plotting functions based on <code>plot_type</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{F}, Tuple{Array{Results{F}, 1}, SIM}} where {F&lt;:AbstractFloat, SIM&lt;:Simulation}" href="#Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{F}, Tuple{Array{Results{F}, 1}, SIM}} where {F&lt;:AbstractFloat, SIM&lt;:Simulation}"><code>Sleipnir.save_results_file!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_results_file(simulation::Prediction)</code></pre><p>Save simulation <code>Results</code> into a <code>.jld2</code> file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.smooth!-Tuple{Any}" href="#Sleipnir.smooth!-Tuple{Any}"><code>Sleipnir.smooth!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth!(A)</code></pre><p>Smooth data contained in a matrix with one time step (CFL) of diffusion.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.stop_condition_tstops-NTuple{4, Any}" href="#Sleipnir.stop_condition_tstops-NTuple{4, Any}"><code>Sleipnir.stop_condition_tstops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stop_condition_tstops(u,t,integrator, tstops)</code></pre><p>Function that iterates through the tstops, with a closure including <code>tstops</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sleipnir.trim_period-Tuple{Any, Any}" href="#Sleipnir.trim_period-Tuple{Any, Any}"><code>Sleipnir.trim_period</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trim_period(period, climate)</code></pre><p>Trims a time period based on the time range of a climate series. </p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 21 February 2025 10:00">Friday 21 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
