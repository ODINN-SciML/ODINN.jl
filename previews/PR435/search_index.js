var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"In this page we provide the main references used in the ODINN project, grouped by themes.","category":"section"},{"location":"references/#Papers-using-ODINN.jl","page":"References","title":"Papers using ODINN.jl","text":"Universal differential equations for glacier ice flow modelling, Bolibar and Sapienza et al. (2023), Geoscientific Model Development [2].","category":"section"},{"location":"references/#Papers-about-Universal-Differential-Equations-and-the-SciML-ecosystem","page":"References","title":"Papers about Universal Differential Equations and the SciML ecosystem","text":"Universal Differential Equations for Scientific Machine Learning, Rackauckas et al. (2020) [1].\nStiff neural ordinary differential equations, Kim et al. (2021) [10].\nSpherical Path Regression through Universal Differential Equations with Applications to Paleomagnetism, Sapienza et al. (preprint) [11].\nOn Neural Differential Equations, Kidger (2022) [12].\nPhysics-Based Deep Learning, Thuerey et al. (2021) [13].","category":"section"},{"location":"references/#Papers-about-differentiable-programming","page":"References","title":"Papers about differentiable programming","text":"Differentiable programming for differential equations: a review, Sapienza et al. (preprint) [8].\nDifferentiable programming for Earth System modelling, Gelbrecht et al. (2023), Geoscientific Model Development [14].","category":"section"},{"location":"references/#Papers-about-Julia-packages","page":"References","title":"Papers about Julia packages","text":"Interpretable Machine Learning for Science with PySR and SymbolicRegression.jl, Cranmer (2023), arXiV [15].","category":"section"},{"location":"references/#Papers-about-glacier-(ice-flow)-modelling","page":"References","title":"Papers about glacier (ice flow) modelling","text":"Inversion of basal friction in Antarctica using exact and incomplete adjoints of a higher-order model, Morlighem et al. (2013), JGR Earth Surface [4].\nWhat is glacier sliding?, Law et al. (2025), arXiV [16].\nDeep learning the flow law of Antarctic ice shelves, Wang et al. (2025), Science [17].\nThe Physics of Glaciers, Cuffey and Paterson (2010) [9].\nIce-Dynamical Glacier Evolution Modeling - A Review, Zekollari et al. (2022) [18].\nDo existing theories explain seasonal to multi-decadal changes in glacier basal sliding speed?, Gimbert et al. (2021) [19].","category":"section"},{"location":"references/#Papers-about-the-MassBalanceMachine","page":"References","title":"Papers about the MassBalanceMachine","text":"Machine learning improves seasonal mass balance prediction for unmonitored glaciers, Sjursen et al. (preprint) [20].","category":"section"},{"location":"references/#Datasets","page":"References","title":"Datasets","text":"GlaThiDa: Glacier ice thickness database, Welty et al. (2020), ESSD [5].\nIce velocity and thickness of the world’s glaciers, Millan et al. (2022), Nature Geoscience [6].\nSatellite-Derived Annual Glacier Surface Flow Velocity Products for the European Alps, 2015–2021, Rabatel et al. (2023) [7]","category":"section"},{"location":"references/#Full-bibliography","page":"References","title":"Full bibliography","text":"C. Rackauckas, Y. Ma, J. Martensen, C. Warner, K. Zubov, R. Supekar, D. Skinner and A. Ramadhan. Universal Differential Equations for Scientific Machine Learning, arXiv:2001.04385 cs, math, q-bio, stat. Accessed on Jan 15, 2020, arXiv: 2001.04385.\n\n\n\nJ. Bolibar, F. Sapienza, F. Maussion, R. Lguensat, B. Wouters and F. Pérez. Universal differential equations for glacier ice flow modelling. Geoscientific Model Development 16, 6671–6687 (2023). Accessed on Jan 29, 2025. Publisher: Copernicus GmbH.\n\n\n\nM. Perego, S. Price and G. Stadler. Optimal initial conditions for coupling ice sheet models to Earth system models. Journal of Geophysical Research: Earth Surface 119, 1894–1917 (2014).\n\n\n\nM. Morlighem, H. Seroussi, E. Larour and E. Rignot. Inversion of basal friction in Antarctica using exact and incomplete adjoints of a higher-order model. Journal of Geophysical Research: Earth Surface 118, 1746–1753 (2013). Accessed on Aug 6, 2025.\n\n\n\nE. Welty, M. Zemp, F. Navarro, M. Huss, J. J. Fürst, I. Gärtner-Roer, J. Landmann, H. Machguth, K. Naegeli, L. M. Andreassen, D. Farinotti, H. Li and G. Contributors. Worldwide version-controlled database of glacier thickness observations. Earth System Science Data 12, 3039–3055 (2020). Accessed on Aug 12, 2025. Publisher: Copernicus GmbH.\n\n\n\nR. Millan, J. Mouginot, A. Rabatel and M. Morlighem. Ice velocity and thickness of the world’s glaciers. Nature Geoscience 15, 124–129 (2022). Accessed on Feb 25, 2022.\n\n\n\nA. Rabatel, E. Ducasse, R. Millan and J. Mouginot. Satellite-Derived Annual Glacier Surface Flow Velocity Products for the European Alps, 2015–2021. Data 8, 66 (2023). Accessed on Jan 28, 2025. Number: 4 Publisher: Multidisciplinary Digital Publishing Institute.\n\n\n\nF. Sapienza, J. Bolibar, F. Schäfer, B. Groenke, A. Pal, V. Boussange, P. Heimbach, G. Hooker, F. Pérez, P.-O. Persson and C. Rackauckas. Differentiable Programming for Differential Equations: A Review (Jun 2024). Accessed on Sep 2, 2024, arXiv:2406.09699 [physics, stat].\n\n\n\nK. Cuffey and W. Paterson. The Physics of Glaciers (Elsevier Science, 2010).\n\n\n\nS. Kim, W. Ji, S. Deng, Y. Ma and C. Rackauckas. Stiff neural ordinary differential equations. Chaos: An Interdisciplinary Journal of Nonlinear Science 31, 093122 (2021). Accessed on Feb 25, 2022.\n\n\n\nFacundo Sapienza, Leandro Cesar Gallo, Jordi Bolibar, Fernando Perez and Jonathan Taylor. Spherical Path Regression through Universal Differential Equations with Applications to Paleomagnetism (Feb 2025). Accessed on Feb 7, 2025.\n\n\n\nP. Kidger. On Neural Differential Equations (Feb 2022). Accessed on Dec 29, 2024, arXiv:2202.02435 [cs].\n\n\n\nN. Thuerey, P. Holl, M. Mueller, P. Schnell, F. Trost and K. Um. Physics-based Deep Learning, arXiv:2109.05237 physics. Accessed on Feb 25, 2022, arXiv: 2109.05237.\n\n\n\nM. Gelbrecht, A. White, S. Bathiany and N. Boers. Differentiable programming for Earth system modeling. Geoscientific Model Development 16, 3123–3135 (2023). Accessed on Mar 27, 2025. Publisher: Copernicus GmbH.\n\n\n\nM. Cranmer. Interpretable Machine Learning for Science with PySR and SymbolicRegression.jl (2023). Accessed on Jan 15, 2025. Version Number: 3.\n\n\n\nR. Law, D. Chandler and A. Born. What is glacier sliding (Mar 2025). Accessed on Apr 30, 2025, arXiv:2407.13577 [physics].\n\n\n\nY. Wang, C.-Y. Lai, D. J. Prior and C. Cowen-Breen. Deep learning the flow law of Antarctic ice shelves. Science 387, 1219–1224 (2025). Accessed on Mar 17, 2025. Publisher: American Association for the Advancement of Science.\n\n\n\nH. Zekollari, M. Huss, D. Farinotti and S. Lhermitte. Ice-Dynamical Glacier Evolution Modeling—A Review. Reviews of Geophysics 60, e2021RG000754 (2022).\n\n\n\nF. Gimbert, A. Gilbert, O. Gagliardini, C. Vincent and L. Moreau. Do Existing Theories Explain Seasonal to Multi-Decadal Changes in Glacier Basal Sliding Speed? Geophysical Research Letters 48, e2021GL092858 (2021). Publisher: Wiley Online Library.\n\n\n\nK. H. Sjursen, J. Bolibar, M. van der Meer, L. M. Andreassen, J. P. Biesheuvel, T. Dunse, M. Huss, F. Maussion, D. R. Rounce and B. Tober. Machine learning improves seasonal mass balance prediction for unmonitored glaciers. EGUsphere, 1–39 (2025). Accessed on Jul 7, 2025. Publisher: Copernicus GmbH.\n\n\n\n","category":"section"},{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"In this section, we discuss the aspects of the inversions related to parameter or model state optimization and the associated loss functions.","category":"section"},{"location":"optimization/#Loss-functions","page":"Optimization","title":"Loss functions","text":"The loss function that is being optimized mathcalL consists of a data fidelity term and an optional regularization term. The data fidelity term represents the empirical error between the predicted state of the glacier (given by the simulated forward model) and observations. The state of the glacier can be characterized by the thickness H and/or the ice surface velocity V. The ground truth for each of these variables is available through different datasets. On both cases, the objective is to find the value of the model parameters (e.g, the weights of the neural network, the initial state of the glacier), that minimize the total loss.\n\nWe distinguish between the contributions of the loss function that include observations (empirical loss) and regularization losses that penalize solutions that do not comply with some handcrafted prior. The total loss function is given by\n\nmathcalL(theta)\n=\nlambda_1 mathcalL_1(theta)\n+ ldots\nlambda_k mathcalL_k(theta)\n\nwhere each mathcalL_i is a different contribution to the loss (either empirical or regularization) weighted by an hyperparameter lambda_i. ODINN supports multiobjective loss functions thought MultiLoss. For example, an objective function consisting of one empirical loss function corresponding to differences in ice thickness and a regularization of the ice surface velocity can be defined as follows\n\nloss = MultiLoss(\n    losses=(LossH(), VelocityRegularization()),\n    λs=(0.4, 1e-5)\n)\n\nIn the following sections, we introduce how to define empirical and regularization loss terms, respectively.","category":"section"},{"location":"optimization/#Empirical-loss-functions","page":"Optimization","title":"Empirical loss functions","text":"The empirical error can be as simple as the squared sum or the error between model and observations, but it can also involve more complex cost functions. The complete description of the different losses are available in their corresponding docstrings but we provide here a brief summary for each of them.\n\nThere are very simple types which are agnostic to the nature of the variables whose error is being computed (that is H or V). These are:\n\nL2Sum: L^2 sum of the error inside the glacier.\nLogSum: Logarithmic sum of the ratio between ice surface velocities (see [4]).\n\nThese types which define very simple operations are used in more complex loss functions:\n\nLossH: Loss function over the ice thickness only.\nLossV: Loss function over the ice surface velocity only.\nLossHV: Loss function over both the ice thickness and ice surface velocity.\n\nThe loss function for the ice thickness H (similar for ice surface velocity V) is mathematically defined as:\n\nmathcalL(theta)\n=\nint_tinmathcalT int_xinOmega ell(H(x t theta) theta) mathrmdt mathrmdOmega\n\nwhere OmegasubsetmathbbR^2 defines the spatial domain where we evaluate the loss (usually this corresponds to areas within the glacier that are at least at a given distance from the borders), and ell(hat H(x t) theta) is the point evaluated loss function. In the case of the L^2 loss, we simply have\n\nell(H(x t theta) theta) = left(hat H(t x) - H(t x)right)^2\n\nIn the formula above, hat H and H are written as continuous variables, function of both space and time. In practice, the iceflow equation is solved on a given grid (x_i)_ileq I where each x_iinmathbbR^2.\n\nHowever, since we have very sparse observations, data is available only at specific points in time and space. The ground truth ice thickness, generally coming from ground penetrating radar (GPR) field work from the Glathida database [5], displays a very strong sparsity, with observations concentrated along radar transects. Glacier ice surface velocity products , e.g. [6], [7], are notoriously less sparse, but still present many gaps in the grid due to signal-to-noise-ratio issues from the products. Let mathcalX=(x_jt_j)_jleq J define the set of points where there are ground truth measurements. We assume that forall jleq J x_jin(x_i)_i, that is the ground truth measurements are aligned with the simulation grid. For this setting, the empirical error term can be defined as\n\nsum_j leq J left( hat H(t_jx_j)-H(t_jx_j) right)^2\n\nwith hat H(t_jx_j) the predicted ice thickness at time t_j and on the node of the simulation grid x_j.","category":"section"},{"location":"optimization/#Regularization","page":"Optimization","title":"Regularization","text":"Regularizations are very common in inverse modelling as they help to constraint the possible solutions of the problem to physical reasonable values. From a mathematical and computational perspective, regularization losses are just another type of loss that do not include contribution from observations (and then have no empirical contribution to their value).\n\nODINN currently supports the following type of regularization, although the development of new regularization should be straightforward from the source code API:\n\nTikhonovRegularization: Very common in geophysical inversion. Given an linear operator A, this is given by the value of  A(S) _2^2, where S is some state variable (e.g., the ice thickness or ice surface velocity). Default choice in ODINN is the Laplacian operator.\nInitialThicknessRegularization: Penalizes large second order derivatives in the initial condition of the glacier when this is treated as an optimization variable.\n\nRegularization and empirical losses can be combined together to construct new form of regularizations.","category":"section"},{"location":"results_plotting/#Results-and-plotting","page":"Results and plotting","title":"Results and plotting","text":"","category":"section"},{"location":"results_plotting/#Results","page":"Results and plotting","title":"Results","text":"Every Simulation type has an associated Results object(s), one for each one of the glaciers in the simulation. This object, as its name indicates, stores all the results of the simulation, which can be used for data analysis and plotting. These types are handled by Sleipnir.jl.","category":"section"},{"location":"results_plotting/#Plots","page":"Results and plotting","title":"Plots","text":"One of the main things one can do with a Results object, is plotting them. The main function to do so is the following one:\n\nAnother option is to generate a video of the evolution of the glacier's ice thickness during the simulation:","category":"section"},{"location":"results_plotting/#Sleipnir.Results","page":"Results and plotting","title":"Sleipnir.Results","text":"mutable struct Results{F <: AbstractFloat, I <: Integer}\n\nA mutable struct to store the results of simulations.\n\nFields\n\nrgi_id::String: Identifier for the RGI (Randolph Glacier Inventory).\nH::Vector{Matrix{F}}: Vector of matrices representing glacier ice thickness H over time.\nH_glathida::Matrix{F}: Optional matrix for Glathida ice thicknesses.\nH_ref::Vector{Matrix{F}}: Reference data for ice thickness.\nS::Matrix{F}: Glacier surface altimetry.\nB::Matrix{F}: Glacier bedrock.\nV::Matrix{F}: Glacier ice surface velocities.\nVx::Matrix{F}: x-component of the glacier ice surface velocity V.\nVy::Matrix{F}: y-component of the glacier ice surface velocity V.\nV_ref::Matrix{F}: Reference data for glacier ice surface velocities V.\nVx_ref::Matrix{F}: Reference data for the x-component of the glacier ice surface velocity Vx.\nVy_ref::Matrix{F}: Reference data for the y-component of the glacier ice surface velocity Vy.\ndate_Vref::Vector{F}: Date of velocity observation (mean of date1 and date2).\ndate1_Vref::Vector{F}: First date of velocity acquisition.\ndate2_Vref::Vector{F}: Second date of velocity acquisition.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nlon::F: Longitude of the glacier grid center.\nlat::F: Latitude of the glacier grid center.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ntspan::Vector{F}: Time span of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"results_plotting/#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G<:AbstractGlacier, F<:AbstractFloat, IF<:AbstractModel, I<:Integer}","page":"Results and plotting","title":"Sleipnir.Results","text":"Results(glacier::G, ifm::IF;\n    rgi_id::String = glacier.rgi_id,\n    H::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    H_glathida::Matrix{F} = glacier.H_glathida,\n    H_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    S::Matrix{F} = zeros(Sleipnir.Float, size(ifm.S)),\n    B::Matrix{F} = zeros(Sleipnir.Float, size(glacier.B)),\n    V::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vx::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vy::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    V_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vx_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vy_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    date_Vref::Vector{F} = Vector{Sleipnir.Float}([]),\n    date1_Vref::Vector{F} = Vector{Sleipnir.Float}([]),\n    date2_Vref::Vector{F} = Vector{Sleipnir.Float}([]),\n    Δx::F = glacier.Δx,\n    Δy::F = glacier.Δy,\n    lon::F = glacier.cenlon,\n    lat::F = glacier.cenlat,\n    nx::I = glacier.nx,\n    ny::I = glacier.ny,\n    t::Vector{F} = Vector{Sleipnir.Float}([]),\n    tspan::Tuple{F, F} = (NaN, NaN),\n) where {G <: AbstractGlacier, F <: AbstractFloat, IF <: AbstractModel, I <: Integer}\n\nConstruct a Results object for a glacier simulation.\n\nArguments\n\nglacier::G: The glacier object, subtype of AbstractGlacier.\nifm::IF: The model object, subtype of AbstractModel.\nrgi_id::String: The RGI identifier for the glacier. Defaults to glacier.rgi_id.\nH::Vector{Matrix{F}}: Ice thickness matrices. Defaults to an empty vector.\nH_glathida::Matrix{F}: Ice thickness from GlaThiDa. Defaults to glacier.H_glathida.\nH_ref::Vector{Matrix{F}}: Reference ice thickness. Defaults to an empty vector.\nS::Matrix{F}: Surface elevation matrix. Defaults to a zero matrix of the same size as ifm.S.\nB::Matrix{F}: Bed elevation matrix. Defaults to a zero matrix of the same size as glacier.B.\nV::Vector{Matrix{F}}: Velocity magnitude matrix. Defaults to an empty vector.\nVx::Vector{Matrix{F}}: Velocity in the x-direction matrix. Defaults to an empty vector.\nVy::Vector{Matrix{F}}: Velocity in the y-direction matrix. Defaults to an empty vector.\nV_ref::Vector{Matrix{F}}: Reference velocity magnitude matrix. Defaults to an empty vector.\nVx_ref::Vector{Matrix{F}}: Reference velocity in the x-direction matrix. Defaults to an empty vector.\nVy_ref::Vector{Matrix{F}}: Reference velocity in the y-direction matrix. Defaults to an empty vector.\ndate_Vref::Vector{F}: Date of velocity observation (mean of date1 and date2). Defaults to an empty vector.\ndate1_Vref::Vector{F}: First date of velocity acquisition. Defaults to an empty vector.\ndate2_Vref::Vector{F}: Second date of velocity acquisition. Defaults to an empty vector.\nΔx::F: Grid spacing in the x-direction. Defaults to glacier.Δx.\nΔy::F: Grid spacing in the y-direction. Defaults to glacier.Δy.\nlon::F: Longitude of the glacier grid center. Defaults to glacier.cenlon.\nlat::F: Latitude of the glacier grid center. Defaults to glacier.cenlat.\nnx::I: Number of grid points in the x-direction. Defaults to glacier.nx.\nny::I: Number of grid points in the y-direction. Defaults to glacier.ny.\ntspan::Tuple(F, F): Timespan of the simulation.\nθ::Union{Nothing, ComponentArray{F}}: Model parameters. Defaults to nothing.\nloss::Union{Nothing, Vector{F}}: Loss values. Defaults to nothing.\n\nReturns\n\nresults::Results: A Results object containing the simulation results.\n\n\n\n\n\n","category":"method"},{"location":"results_plotting/#Sleipnir.plot_glacier","page":"Results and plotting","title":"Sleipnir.plot_glacier","text":"plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -> Figure\n\nGenerate various types of plots for glacier data.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nplot_type::String: Type of plot to generate. Options are:\n\"heatmaps\": Heatmaps for glacier variables like :H, :H₀, :S, :B, :V, :Vx, :Vy, :V_ref.\n\"evolution difference\": Temporal difference metrics (between start and end) for a variable, with optional metrics like \"hist\" (histogram) and \"difference\".\n\"evolution statistics\": Temporal statistical metrics for a variable, with optional metrics like \"average\", \"median\", \"min\", \"max\", and \"std\".\n\"integrated volume\": Temporal evolution of the integrated ice volume for a variable.\n\"bias\": Scatter plot to visualize the bias between two variables.\nvariables::Vector{Symbol}: Variables to be plotted, e.g., :H.\n\nOptional Keyword Arguments\n\ntspan: A tuple representing the start and end time for the simulation.\nmetrics: Metrics to visualize, e.g., [\"average\"] for statistics, [\"difference\"] for difference.\nscale_text_size::Union{Nothing,Float64}: Optional argument to scale the text size for heatmaps.\nthreshold::Vector{F}: Threshold values for filtering data in bias plots.\nfigsize::Tuple{Int64, Int64}: Size of the figure.\n\nReturns\n\nA Figure object containing the desired visualization.\n\nNotes\n\nEnsure the variables and kwargs match the requirements of the specified plot_type.\nThe function routes requests to specific plotting functions based on plot_type.\n\n\n\n\n\n","category":"function"},{"location":"results_plotting/#Sleipnir.plot_glacier_vid","page":"Results and plotting","title":"Sleipnir.plot_glacier_vid","text":"plot_glacier_vid(\n    plot_type::String,\n    results::Results,\n    glacier::Glacier2D,\n    tspan,\n    step,\n    pathVideo::String;\n    framerate::Int=24,\n    baseTitle::String=\"\"\n)\n\nGenerate various types of videos for glacier data. For now only the evolution of the glacier ice thickness is supported. More types of visualizations will be added in the future. \n\nArguments\n\nplot_type: Type of plot to generate. Options are:\n\"thickness\": Heatmap of the glacier thickness.\nresults: A result object containing the simulation results including ice   thickness over time.\nglacier: A glacier instance.\ntspan: The simulation time span.\nstep: Time step to use to retrieve the results and generate the video.\npathVideo: Path of the mp4 file to generate.\n\nOptional Keyword Arguments\n\nframerate: The framerate to use for the video generation.\nbaseTitle: The prefix to use in the title of the frames. In each frame it is   concatenated with the value of the year in the form \" (t=XXXX)\".\n\n\n\n\n\n","category":"function"},{"location":"sensitivity/#Sensitivity-Analysis","page":"Sensitivity analysis","title":"Sensitivity Analysis","text":"In this section we aim to discuss the main choices and strategies regarding sensitivity analysis within the ODINN ecosystem. Sensitivity analysis is important in order to differentiate the different ice flow simulations and enable parameter calibration during the inverse modelling stage.\n\nODINN currently supports two main strategies regarding the computation of model sensitivity of hybrid models combining differential equations (e.g. SIA2D) and regressors: manual adjoints and SciMLSensitivity.jl.","category":"section"},{"location":"sensitivity/#Manual-adjoints","page":"Sensitivity analysis","title":"Manual adjoints","text":"ODINN includes an implementation of both discrete and continuous adjoint methods (see [8] for a complete overview of these different methods). In both cases, the adjoint variable is computed as the solution of a time reversed differential equation. The adjoint state variable is then used to efficiently compute the gradient of a prescribed loss function.\n\nFor the SIA2D equation, the iceflow equations can be written as\n\n    fracpartial Hpartial t\n    =\n    dot b\n    +\n    nabla cdot\n    left(\n    D(H nabla S)\n    nabla S\n    right)\n\nwhere D is a diffusivity term (see [9] for more information). Given a loss function L(theta) (see the Optimization section), the adjoint variable lambda is defined as the solution of the following partial differential equation:\n\n    fracpartial lambdapartial t\n    =\n    - nabla cdot left( D nabla lambda right)\n    + fracpartial Dpartial H nabla S cdot nabla lambda\n    - nabla cdot left( fracpartial Dpartial (nabla H) nabla S cdot nabla lambda right)\n    - fracpartial ellpartial H\n\nwith final condition lambda(xyt_1) = 0 and lambda _partial Omega equiv 0. The gradient of the loss function L(theta) with respect to the parameter theta then can be computed using the following expression:\n\n    fracdLdtheta_i\n    =\n    - iint\n    fracpartial Dpartial theta_i nabla S cdot nabla lambda mathrmdt mathrmdOmega\n    +\n    iint fracpartial ellpartial theta_i mathrmdt mathrmdOmega\n\nThe integration of the adjoint equation can be performed using the discrete adjoint (discretize-then-differentiate) or the continuous adjoint (differentiate-then-discretize). Both types of adjoints are implemented as an AbstractAdjointMethod:\n\nDiscreteAdjoint(): The discrete adjoint is a very simple adjoint that uses an explicit Euler scheme to solve the adjoint ODE. The timestep is prescribed by the frequency at which the results are saved in the forward run. It is usually set to one month.\nContinuousAdjoint(): With this adjoint method, the adjoint ODE is treated and solved as a standard ODE using SciMLSensitivity. The VJP with respect to the ice thickness of the ice flow equation (e.g. SIA2D!) is integrated backward in time. The gradients with respect to the parameters involved in the iceflow equation are then computed using a simple Gauss Quadrature at prescribed time steps. These time steps are determined by the Gauss Quadrature method and in a general case they are different from the time steps at which results are gathered in the forward run. This is way the adjoint solution is interpolated. For the moment only linear interpolators are supported.\n\nThe default choice for the manual adjoint is ContinuousAdjoint(), which relies on DifferentialEquations.jl for solving the reverse adjoint equations, then providing better error control on the computation of the gradients.","category":"section"},{"location":"sensitivity/#Computing-the-VJPs-inside-the-solver","page":"Sensitivity analysis","title":"Computing the VJPs inside the solver","text":"When evaluating the adjoint differential equations used to compute the gradient of the loss function, vector-Jacobian products (VJPs) need to be evaluated at every given timestep (see Section 4.2.1.1 in [8]). These VJPs are then used inside both continuous and discrete adjoints, where the adjoint equation is integrated in time.  The computation of these VJPs can be efficiently be computed using automatic differentiation. ODINN provides manual implementations of the pullback operations required to compute these VJPs, together with the interface to compute these VJPs using the native Julia automatic differentiation libraries. The VJP methods in ODINN are implemented as concrete types of AbstractVJPMethod:\n\nEnzymeVJP(): The Enzyme VJPs rely on Enzyme.jl to compute the (spatially) discrete VJPs of the iceflow equation. It corresponds to the true VJP of the numerical code. \nDiscreteVJP(): This is a manual implementation of what the (spatially) discrete Enzyme VJP does. Equations were derived manually by differentiating the discretized differential operators. For example, this means that the partial derivative fracpartial fpartial x is first discretized as, for example, df[i] = (f[i + 1] - f[i]) / dx and then the pullback operator is directly applied to the discretization df.\nContinuousVJP(): In the special case of SIA2D!, as we are dealing with a diffusion equation, a (spatially) continuous VJP can be derived by integrating by parts the spatial differential operators inside the SIA equation. This means the pullback operator of the differentiation step fracpartial fpartial x is first computed before discretizing. It is then discretized after differentiation","category":"section"},{"location":"sensitivity/#SciMLSensitivity","page":"Sensitivity analysis","title":"SciMLSensitivity","text":"Gradients can also be computed using SciMLSensitivity.jl. It enables to automate the computation of the adjoint method and the VJPs (Vector-Jacobian Products), done using automatic differentiation via Enzyme.jl.\n\nIn order to ensure end-to-end differentiability of the whole model using Enzyme.jl, special attention needs to be taken in terms of code style and type stability. For this, we leverage the adjoint capabilities of SciMLSensitivity.jl from the SciML ecosystem.\n\nHere, we compile the main considerations and things that need to be taken into account when developing differentiable code within ODINN:\n\nEnsure and test type stability. All new functions and types need to be type stable. This is crucial for them to be differentiable with Enzyme.jl. This is mainly implemented in tests using JET.@test_opt, a macro from the JET.jl package that performs static analysis on Julia code to detect potential type instabilities, method errors, or other issues at compile time. In particular, structures with abstract fields must use parametric types.\nMake sure that the input variables of the ice flow equation (e.g. SIA2D!) are not mutated. As calls to Enzyme.jl in SciMLSensitivity.jl use Enzyme.Const for the input variable H when computing the VJP with respect to the parameters, it expects H to not be modified in-place. A typical example is SIA2D! where in the first lines, H is copied even though this is an in-place implementation because we need to clip the negative values of the input variable H. Failing to respect this constraint will result in the following error:\n\ndanger: ERROR\nConstant memory is stored (or returned) to a differentiable variable.\nAs a result, Enzyme cannot provably ensure correctness and throws this error.\nThis might be due to the use of a constant variable as temporary storage for active memory (https://enzyme.mit.edu/julia/stable/faq/#Runtime-Activity).\nIf Enzyme should be able to prove this use non-differentiable, open an issue!\nTo work around this issue, either:\n    a) rewrite this variable to not be conditionally active (fastest, but requires a code change), or\n    b) set the Enzyme mode to turn on runtime activity (e.g. autodiff(set_runtime_activity(Reverse), ...) ). This will maintain correctness, but may slightly reduce performance.\n\nThe ODEProblem needs to be defined out of the function that is being differentiated. We use remake(iceflow_prob; p=container) to define a new ODEProblem and the solver will use the parameters defined in container.\nNo closures are used to provide the Simulation object to the iceflow equation. The SciMLStructures.jl package has been especially implemented for this use case where one wants to provide both a vector of parameters to optimize, and a complex struct. This struct is designed to store some intermediate results through a cache and simulation parameters that are used to store physical quantities. The documentation provides an example of how to implement the interface. Special attention should be given to the definition of the replace function which should deepcopy the whole struct and zero the fields that are not used to differentiate parameters.\nAt the loss function level, all the operations need to be out-of-place as Zygote.jl is used to differentiate this part of the computational graph. This means for example that one cannot affect the results in simulation and this has to be done outside of the functions that are called by Zygote.gradient. The error raised in case an in-place affectation is done is rather explicit.\nParts of the computational graph are not needed to compute the true gradient and they can be bypassed thanks to the @ignore_derivatives macro. This is the case for example of the reference ice thickness.","category":"section"},{"location":"classical_inversion/#Classical-inversion-tutorial","page":"Classical inversion","title":"Classical inversion tutorial","text":"This tutorial provides a simple example on how to perform a classical gridded inversion in ODINN.jl. For this, we generate a synthetic dataset using a forward simulation, and then we use this dataset to perform the classical inversion. The goal of this classical inversion is to retrieve the matrix of A values, i.e. the ice rigidity, that was used to generate the results of a forward simulation.","category":"section"},{"location":"classical_inversion/#Step-1:-Parameter-and-glacier-initialization","page":"Classical inversion","title":"Step 1: Parameter and glacier initialization","text":"using ODINN\n\n# We fetch the paths with the files for the available glaciers on disk\n\nrgi_paths = get_rgi_paths()\n\nDefine which glacier RGI IDs we want to work with\n\nrgi_ids = [\"RGI60-11.03638\"]\n\nDefine the time step for the simulation output and for the adjoint calculation. In this case, a month.\n\nδt = 1/12\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        use_MB=false,\n        tspan=(2010.0, 2015.0),\n        test_mode=false,\n        multiprocessing=false, # We are processing only one glacier\n        rgi_paths=rgi_paths,\n        gridScalingFactor=4), # Downscale the glacier grid to speed-up this example for the GitHub servers\n    hyper = Hyperparameters(\n        batch_size=length(rgi_ids), # We set batch size equals all datasize so we test gradient\n        epochs=[2,2], # [35,30]\n        optimizer=[ODINN.ADAM(0.02), ODINN.LBFGS(linesearch = ODINN.LineSearches.BackTracking(iterations = 5))]),\n    physical = PhysicalParameters(\n        minA = 8e-21,\n        maxA = 8e-17),\n    UDE = UDEparameters(\n        optim_autoAD=ODINN.NoAD(),\n        empirical_loss_function = LossH() # Loss function based on ice thickness\n    ),\n    solver = Huginn.SolverParameters(step=δt),\n)","category":"section"},{"location":"classical_inversion/#Step-2:-Defining-a-forward-simulation-as-a-synthetic-ground-truth","page":"Classical inversion","title":"Step 2: Defining a forward simulation as a synthetic ground truth","text":"We define a synthetic law to generate the synthetic dataset. For this, we use some tabular data from Cuffey and Paterson (2010) in a law that we have already available in ODINN.jl, which we specify to be in a gridded format (i.e. non-scalar).\n\nA_law = CuffeyPaterson(scalar=false)\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n)\n\nWe initialize the glaciers with all the necessary data\n\nglaciers = initialize_glaciers(rgi_ids, params)\n\nTime snapshots where to store data for the inversion\n\ntstops = collect(2010:δt:2015)\n\nWe generate the synthetic dataset using the forward simulation. This will generate a dataset with the ice thickness and surface velocities for each glacier at each time step. The dataset will be to make the inversion hereafter.\n\nprediction = generate_ground_truth_prediction(glaciers, params, model, tstops)\n\nglaciers = prediction.glaciers\n\nNow we compute the spatially varying A to have a ground truth for the comparison at the end of this tutorial.\n\nA_ground_truth = zeros(size(prediction.glaciers[1].H₀))\ninn1(A_ground_truth) .= eval_law(prediction.model.iceflow.A, prediction, 1, (;T=get_input(iAvgGriddedTemp(), prediction, 1, tstops[1])), nothing)\nA_ground_truth[prediction.glaciers[1].H₀.==0] .= NaN;\nnothing #hide","category":"section"},{"location":"classical_inversion/#Step-3:-Model-specification-to-perform-a-classical-inversion","page":"Classical inversion","title":"Step 3: Model specification to perform a classical inversion","text":"After this forward simulation, we restart the iceflow model to be ready for the inversions\n\ntrainable_model = GriddedInv(params, glaciers, :A)\nA_law = LawA(params; scalar=false)\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    regressors = (; A=trainable_model)\n)","category":"section"},{"location":"classical_inversion/#Step-4:-Perform-the-inversion-by-optimizing-the-model","page":"Classical inversion","title":"Step 4: Perform the inversion by optimizing the model","text":"We specify the type of simulation we want to perform\n\ninversion = Inversion(model, glaciers, params)\n\nAnd finally, we just run the simulation\n\nrun!(inversion)\n\nNow that the model has been optimized, we retrieve the inverted parameters. These parameters do not correspond directly to the values of A. What it defines instead is a parameterization of A to ensure positiveness through a tanh function.\n\nθ = inversion.results.stats.θ\n\nWe map the parameters to the values of A by evaluating the law.\n\nA = zeros(size(inversion.glaciers[1].H₀))\ninn1(A) .= eval_law(inversion.model.iceflow.A, inversion, 1, (;), θ)\nA[inversion.glaciers[1].H₀.==0] .= NaN;\nnothing #hide","category":"section"},{"location":"classical_inversion/#Step-5:-Compare-the-inverted-parameter-to-the-synthetic-ground-truth","page":"Classical inversion","title":"Step 5: Compare the inverted parameter to the synthetic ground truth","text":"Finally we visualize the inverted A.\n\nplot_gridded_data(A, inversion.results.simulation[1]; colormap=:YlGnBu, logPlot=true)\n\nWe can compare it to the ground truth A values:\n\nplot_gridded_data(A_ground_truth, inversion.results.simulation[1]; colormap=:YlGnBu, logPlot=true)\n\nUnsurprisingly the inverted A is noisy in comparison to the ground truth. This is because the inversion requires regularization. For more information on how to define regularizations, see the Optimization section.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"glaciers/#Glaciers","page":"Glaciers","title":"Glaciers","text":"","category":"section"},{"location":"glaciers/#Glacier-types","page":"Glaciers","title":"Glacier types","text":"Glaciers in ODINN.jl are represented by a Glacier type. Each glacier has its related Climate type. Since ODINN.jl supports different types of simulations, we offer the possibility to work on 1D (i.e. flowline), 2D (e.g. SIA) or even 3D (not yet implemented, e.g. Full Stokes). For now, all the simulations are workflows are focused on a 2D Shallow Ice Approximation (SIA).","category":"section"},{"location":"glaciers/#Climate","page":"Glaciers","title":"Climate","text":"Every glacier has its associated climate, following the same spatial representation (e.g. 2D). These are also retrieved using OGGM, and different types of climate can be used. By default we provide W5E5, which is downscaled (for now using very simple methods) to the glacier grid. ","category":"section"},{"location":"glaciers/#Climate-data","page":"Glaciers","title":"Climate data","text":"In ODINN we can leverage all the climate datasets available through OGGM. For more details, please check the OGGM documentation regarding that. \n\nThe main climate data supported include:\n\nW5E5\nCRU\nERA5 and CERA-20C\nHISTALP\nAny other climate dataset. It is fairly easy to add climate datasets into OGGM.","category":"section"},{"location":"glaciers/#Initializing-glaciers-and-their-climate","page":"Glaciers","title":"Initializing glaciers and their climate","text":"In order to create Glacier types with information of a given glacier for a simulation, one can initialize a list of glaciers based on RGI (Randolph Glacier Inventory) IDs. Before running this, make sure to have used Gungnir to download all the necessary data for those glaciers in local. Here you will find a notebook showing how to do so. Even easier, you can just double check that these glaciers are already available on the ODINN server. The list of the already processed glaciers can be obtained with get_rgi_paths().\n\ninfo: Info\nWe will soon host all the preprocessed glacier directories in a server so they can be automatically downloaded by users, without having to process them using Gungnir.","category":"section"},{"location":"glaciers/#Sleipnir.Glacier2D","page":"Glaciers","title":"Sleipnir.Glacier2D","text":"A mutable struct representing a 2D glacier. Notice that all fields can be empty by providing nothing as the default value.\n\n/!\\ WARNING /!\\ Glacier objects should not be constructed manually, but rather through the initialize_glaciers function.\n\nGlacier2D{F <: AbstractFloat, I <: Integer, CLIM <: Climate2D, THICKDATA <: Union{<: ThicknessData, Nothing}, SURFVELDATA <: Union{<: SurfaceVelocityData, Nothing}}\n\nFields\n\nrgi_id::String: The RGI (Randolph Glacier Inventory) identifier for the glacier.\nname::String: The name of the glacier if available.\nclimate::CLIM: The climate data associated with the glacier.\nH₀::Matrix{F}: Initial ice thickness matrix.\nH_glathida::Matrix{F}: Ice thickness matrix from the GLATHIDA dataset.\nS::Matrix{F}: Surface elevation matrix.\nB::Matrix{F}: Bedrock elevation matrix.\nV::Matrix{F}: Ice velocity magnitude matrix.\nVx::Matrix{F}: Ice velocity in the x-direction matrix.\nVy::Matrix{F}: Ice velocity in the y-direction matrix.\nA::F: Flow law parameter.\nC::F: Sliding law parameter.\nn::F: Flow law exponent.\np::F: Power law exponent associated to Weertman sliding law (Power associated to basal drag).\nq::F: Power law exponent associated to Weertman sliding law (Power associated to normal pressure).\nslope::Matrix{F}: Surface slope matrix.\ndist_border::Matrix{F}: Distance to the glacier border matrix.\nmask::BitMatrix: Boolean matrix representing the glacier mask, where true values indicate regions constrained by the mask (i.e., no-ice zones)\nCoords::Dict{String, Vector{Float64}}: Coordinates dictionary with keys as coordinate names and values as vectors of coordinates.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ncenlon::F: Longitude of the glacier center.\ncenlat::F: Latitude of the glacier center.\nparams_projection::Dict{String, Float64}: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.\nthicknessData::THICKDATA: Thickness data structure that is used to store the reference values.\nvelocityData::SURFVELDATA: Surface velocity data structure that is used to store the reference values.\n\n\n\n\n\n","category":"type"},{"location":"glaciers/#Sleipnir.Glacier2D-Tuple{}","page":"Glaciers","title":"Sleipnir.Glacier2D","text":"Glacier2D(;\n    rgi_id::String = \"\",\n    name::String = \"\",\n    climate::Climate2D = nothing,\n    H₀::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    H_glathida::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    S::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    B::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    V::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    Vx::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    Vy::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    A::F = 0.0,\n    C::F = 0.0,\n    n::F = 0.0,\n    p::F = 0.0,\n    q::F = 0.0,\n    slope::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    dist_border::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    mask::BitMatrix = BitMatrix([;;]),\n    Coords::Dict{String, Vector{Float64}} = Dict{String, Vector{Float64}}(\"lon\" => [], \"lat\" => []),\n    Δx::F = 0.0,\n    Δy::F = 0.0,\n    nx::I = 0,\n    ny::I = 0,\n    cenlon::F = NaN,\n    cenlat::F = NaN,\n    params_projection::Dict{String, Float64} = Dict{String, Float64}(),\n    thicknessData::THICKDATA = nothing,\n    velocityData::SURFVELDATA = nothing,\n) where {\n    F <: AbstractFloat,\n    I <: Integer,\n    THICKDATA <: Union{<: ThicknessData, Nothing},\n    SURFVELDATA <: Union{<: SurfaceVelocityData, Nothing},\n}\n\nConstructs a Glacier2D object with the given parameters, including default ones.\n\nArguments\n\nrgi_id::String: The RGI identifier for the glacier.\nname::String: The name of the glacier if available.\nclimate::Climate2D: The climate data associated with the glacier.\nH₀::Matrix{F}: Initial ice thickness matrix.\nH_glathida::Matrix{F}: Ice thickness matrix from GLATHIDA.\nS::Matrix{F}: Surface elevation matrix.\nB::Matrix{F}: Bed elevation matrix.\nV::Matrix{F}: Ice velocity magnitude matrix.\nVx::Matrix{F}: Ice velocity in the x-direction matrix.\nVy::Matrix{F}: Ice velocity in the y-direction matrix.\nA::F: Flow law parameter.\nC::F: Sliding law parameter.\nn::F: Flow law exponent.\np::F: Power law exponent associated to Weertman sliding law (Power associated to basal drag).\nq::F: Power law exponent associated to Weertman sliding law (Power associated to normal pressure).\nslope::Matrix{F}: Slope matrix.\ndist_border::Matrix{F}: Distance to border matrix.\nmask::BitMatrix: Boolean matrix representing the glacier mask, where true values indicate regions constrained by the mask (i.e., no-ice zones)\nCoords::Dict{String, Vector{Float64}}: Coordinates dictionary with keys \"lon\" and \"lat\".\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ncenlon::F: Central longitude of the glacier.\ncenlat::F: Central latitude of the glacier.\nparams_projection::Dict{String, Float64}: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.\nthicknessData::THICKDATA: Thickness data structure that is used to store the reference values.\nvelocityData::SURFVELDATA: Surface velocity data structure that is used to store the reference values.\n\nReturns\n\nA Glacier2D object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"glaciers/#Sleipnir.Climate2D","page":"Glaciers","title":"Sleipnir.Climate2D","text":"A mutable struct representing a 2D climate for a glacier with various buffers and datasets.\n\nClimate2D{CLIMRAW <: RasterStack, CLIMRAWSTEP <: RasterStack, CLIMSTEP <: ClimateStep, CLIM2DSTEP <: Climate2Dstep, F <: AbstractFloat}\n\nFields\n\nraw_climate::CLIMRAW: Raw climate dataset for the whole simulation.\nclimate_raw_step::CLIMRAWSTEP: Raw climate trimmed for the current step to avoid memory allocations.\nclimate_step::ClimateStep: Climate data for the current step.\nclimate_2D_step::Climate2Dstep: 2D climate data for the current step to feed to the mass balance (MB) model.\nlongterm_temps::Vector{F}: Long-term temperatures for the ice rheology.\navg_temps::F: Intermediate buffer for computing average temperatures.\navg_gradients::F: Intermediate buffer for computing average gradients.\nref_hgt::F: Reference elevation of the raw climate data.\nClimate2D(       rgi_id,       params::Parameters,       S::Matrix{<: AbstractFloat},       Coords::Dict,   )\n\nInitialize the climate data given a RGI ID, a matrix of surface elevation and glacier coordinates.\n\nArguments\n\nrgi_id: The glacier RGI ID.\nparams::Parameters: The parameters containing simulation settings and paths.\nS::Matrix{<: AbstractFloat}: Matrix of surface elevation used to initialize the downscaled climate data.\nCoords::Dict: Coordinates of the glacier.\n\nDescription\n\nThis function initializes the climate data for a glacier by:\n\nCreating a dummy period based on the simulation time span and step.\nLoading the raw climate data from a NetCDF file.\nCalculating the cumulative climate data for the dummy period.\nDownscaling the cumulative climate data to a 2D grid.\nRetrieving long-term temperature data for the glacier.\nReturning the climate data, including raw climate data, cumulative climate data, downscaled 2D climate data, long-term temperatures, average temperatures, and average gradients.\nClimate2D(      rawclimate::RasterStack,      climaterawstep::RasterStack,      climatestep::ClimateStep,      climate2Dstep::Climate2Dstep,      longtermtemps::Vector{<: AbstractFloat},      avgtemps::AbstractFloat,      avggradients::AbstractFloat,      refhgt::AbstractFloat,  )\n\nInitialize the climate data with the fields provided as arguments. Refer to the list of fields for a complete description of the arguments.\n\n\n\n\n\n","category":"type"},{"location":"glaciers/#Sleipnir.initialize_glaciers","page":"Glaciers","title":"Sleipnir.initialize_glaciers","text":"initialize_glaciers(\n    rgi_ids::Vector{String},\n    params::Parameters;\n    velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}=Dict(),\n)\n\nInitialize glaciers based on provided RGI IDs and parameters.\n\nArguments\n\nrgi_ids::Vector{String}: A vector of RGI IDs representing the glaciers to be initialized.\nparams::Parameters: A Parameters object containing simulation parameters.\nvelocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}: A dictionary that provides for each RGI ID either the path to the datacube or the RasterStack with velocity data.\n\nReturns\n\nglaciers::Vector{Glacier2D}: A vector of initialized Glacier2D objects.\n\nDescription\n\nThis function performs the following steps:\n\nGenerates a file for missing glaciers if it does not already exist.\nFilters out missing glaciers from the provided RGI IDs.\nGenerates raw climate data for the glaciers if necessary.\nInitializes the glaciers using the provided RGI IDs and parameters.\nIf use_glathida_data is enabled in the simulation parameters, assigns GlaThiDa data to the glaciers.\n\nErrors\n\nThrows an error if none of the provided RGI IDs have GlaThiDa data.\n\nWarnings\n\nIssues a warning if not all glaciers have GlaThiDa data available.\n\nExample\n\n# We declare a list of glaciers to be initialized with their RGI IDs\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\n# We initialize those glaciers based on the RGI IDs and the parameters we previously specified\nglaciers = initialize_glaciers(rgi_ids, params)\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"There are different types of parameters in ODINN, holding specific information for different modelling aspects. All the types of parameters are wrapped into a parent Parameter type, which is threaded throughout ODINN.jl.\n\nThe main child types of parameters are the following ones:","category":"section"},{"location":"parameters/#Simulation-parameters","page":"Parameters","title":"Simulation parameters","text":"Simulation parameters are used to specify anything related to ODINN simulations, ranging from types, working directories to multiprocessing.","category":"section"},{"location":"parameters/#Physical-parameters","page":"Parameters","title":"Physical parameters","text":"Physical parameters are used to store physical constants and variables used in the physical and machine learning models.","category":"section"},{"location":"parameters/#Solver-parameters","page":"Parameters","title":"Solver parameters","text":"Solver parameters determine all aspects related to the numerical scheme used to solve the differential equations of glacier ice flow.","category":"section"},{"location":"parameters/#Hyperparameters","page":"Parameters","title":"Hyperparameters","text":"Hyperparameters determine different aspects of a given machine learning model. For now, these are focused on neural networks, but we plan to extend them in the future for other types of regressors.","category":"section"},{"location":"parameters/#UDE-parameters","page":"Parameters","title":"UDE parameters","text":"Universal Differential Equation (UDE) parameters are used to determine different modelling choices regarding the use of UDEs, such as wich sensitivity algorithm or optimization method to use.","category":"section"},{"location":"parameters/#Sleipnir.Parameters","page":"Parameters","title":"Sleipnir.Parameters","text":"mutable struct Parameters{PPHY <: AbstractEmptyParams, PSIM <: AbstractEmptyParams, PHY <: AbstractEmptyParams,\n    PSOL <: AbstractEmptyParams, PUDE <: AbstractEmptyParams, PINV <: AbstractEmptyParams}\n\nA mutable struct that holds various parameter sets for different aspects of a simulation or model.\n\nFields\n\nphysical::PPHY: Physical parameters.\nsimulation::PSIM: Simulation parameters.\nhyper::PHY: Hyperparameters.\nsolver::PSOL: Solver parameters.\nUDE::PUDE: Universal Differential Equation (UDE) parameters.\ninversion::PINV: Inversion parameters.\n\nType Parameters\n\nPPHY: Type of the physical parameters, must be a subtype of AbstractEmptyParams.\nPSIM: Type of the simulation parameters, must be a subtype of AbstractEmptyParams.\nPHY: Type of the hyperparameters, must be a subtype of AbstractEmptyParams.\nPSOL: Type of the solver parameters, must be a subtype of AbstractEmptyParams.\nPUDE: Type of the UDE parameters, must be a subtype of AbstractEmptyParams.\nPINV: Type of the inversion parameters, must be a subtype of AbstractEmptyParams.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#ODINN.Parameters-Tuple{}","page":"Parameters","title":"ODINN.Parameters","text":"Constructor for the Parameters type. Since some of the subtypes of parameters are defined in different packages of the ODINN ecosystem, this constructor will call the constructors of the different subtypes and return a Parameters object with the corresponding subtypes.  The Parameters mutable struct is defined in Sleipnir.jl using abstract types, which are later on defined in the different packages of the ODINN ecosystem.\n\nParameters(;\n        physical::PhysicalParameters = PhysicalParameters(),\n        simulation::SimulationParameters = SimulationParameters(),\n        solver::SolverParameters = SolverParameters(),\n        hyper::Hyperparameters = Hyperparameters(),\n        UDE::UDEparameters = UDEparameters()\n        inversion::InversionParameters = InversionParameters()\n        )\n\nKeyword arguments\n\nphysical::PhysicalParameters: Physical parameters for the simulation.\nsimulation::SimulationParameters: Parameters related to the simulation setup.\nsolver::SolverParameters: Parameters for the solver configuration.\nhyper::Hyperparameters: Hyperparameters for the model.\nUDE::UDEparameters: Parameters specific to the UDE (Universal Differential Equation).\ninversion::InversionParameters: Parameters for inversion processes.\n\n\n\n\n\n","category":"method"},{"location":"parameters/#Sleipnir.SimulationParameters","page":"Parameters","title":"Sleipnir.SimulationParameters","text":"A structure to hold simulation parameters for a simulation in ODINN.\n\nstruct SimulationParameters{I <: Integer, F <: AbstractFloat, VM <: VelocityMapping} <: AbstractParameters\n\nFields\n\nuse_MB::Bool: Flag to indicate whether mass balance should be used.\nuse_iceflow::Bool: Flag to indicate whether ice flow should be used.\nplots::Bool: Flag to indicate whether plots should be generated.\nuse_velocities::Bool: Flag to indicate whether velocities should be calculated.\nf_surface_velocity_factor::F: Numerical factor representing the ratio between depth integrated ice velocity and surface velocity.\noverwrite_climate::Bool: Flag to indicate whether to overwrite climate data.\nuse_glathida_data::Bool: Flag to indicate whether to use GLATHIDA data.\ntspan::Tuple{F, F}: Time span for the simulation.\nstep_MB::F: Time step for the MB simulation.\nmultiprocessing::Bool: Flag to indicate whether multiprocessing should be used.\nworkers::I: Number of workers for multiprocessing.\nworking_dir::String: Directory for working files.\ntest_mode::Bool: Flag to indicate whether to run in test mode.\nrgi_paths::Dict{String, String}: Dictionary of RGI paths.\nice_thickness_source::String: Source of ice thickness data.\nmapping::VM: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.\ngridScalingFactor::I: Grid downscaling factor, used to speed-up the tests.   Default value is 1 which means no downscaling is applied.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Sleipnir.SimulationParameters-Tuple{}","page":"Parameters","title":"Sleipnir.SimulationParameters","text":"Constructor for SimulationParameters type, including default values.\n\nSimulationParameters(;\n    use_MB::Bool = true,\n    use_iceflow::Bool = true,\n    plots::Bool = true,\n    use_velocities::Bool = true,\n    f_surface_velocity_factor::F = 1.0,\n    overwrite_climate::Bool = false,\n    use_glathida_data::Bool = false,\n    tspan::Tuple{F, F} = (2010.0, 2015.0),\n    step_MB::F = 1/12,\n    multiprocessing::Bool = true,\n    workers::I = 4,\n    working_dir::String = \"\",\n    test_mode::Bool = false,\n    rgi_paths::Dict{String, String} = Dict{String, String}(),\n    ice_thickness_source::String = \"Farinotti19\",\n    mapping::VM = MeanDateVelocityMapping(),\n    gridScalingFactor::I = 1,\n) where {I <: Integer, F <: AbstractFloat, VM <: VelocityMapping}\n\nKeyword arguments\n\nuse_MB::Bool: Whether to use mass balance (default: true).\nuse_iceflow::Bool: Whether to use ice flow (default: true).\nplots::Bool: Whether to generate plots (default: true).\nuse_velocities::Bool: Whether to calculate velocities (default: true).\nf_surface_velocity_factor::F: Numerical factor representing the ratio between depth integrated ice velocity and surface velocity (default: 1.0).\noverwrite_climate::Bool: Whether to overwrite climate data (default: false).\nuse_glathida_data::Bool: Whether to use GLATHIDA data (default: false).\nfloat_type::DataType: Data type for floating point numbers (default: Float64).\nint_type::DataType: Data type for integers (default: Int64).\ntspan::Tuple{F, F}: Time span for the simulation (default: (2010.0, 2015.0)).\nstep_MB::F: Time step for the MB simulation (default: 1/12).\nmultiprocessing::Bool: Whether to use multiprocessing (default: true).\nworkers::I: Number of workers for multiprocessing (default: 4).\nworking_dir::String: Working directory for the simulation (default: \"\").\ntest_mode::Bool: Whether to run in test mode (default: false).\nrgi_paths::Dict{String, String}: Dictionary of RGI paths (default: Dict{String, String}()).\nice_thickness_source::String: Source of ice thickness data, either \"Millan22\" or \"Farinotti19\" (default: \"Farinotti19\").\nmapping::VM: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.\ngridScalingFactor::I: Grid downscaling factor, used to speed-up the tests.   Default value is 1 which means no downscaling is applied.\n\nReturns\n\nsimulation_parameters: A new SimulationParameters object.\n\nThrows\n\nAssertionError: If ice_thickness_source is not \"Millan22\" or \"Farinotti19\".\n\nNotes\n\nIf the global variable ODINN_OVERWRITE_MULTI is set to true, multiprocessing is   is enabled in any case and the number of workers specified in the simulation   parameters must correspond to the number of processes with which Julia has been   started. This is to allow the documentation to build successfully in ODINN as we   cannot change the number of process in the CI.\n\n\n\n\n\n","category":"method"},{"location":"parameters/#Sleipnir.PhysicalParameters","page":"Parameters","title":"Sleipnir.PhysicalParameters","text":"A structure representing physical parameters used in simulations.\n\nPhysicalParameters{F <: AbstractFloat}\n\nFields\n\nρ::F: Density of ice.\ng::F: Gravitational acceleration.\nϵ::F: Regularization used in the square root of norms for AD numerical stability.\nη₀::F: Initial viscosity.\nmaxA::F: Maximum A.\nminA::F: Minimum A.\nmaxC::F: Maximum C.\nminC::F: Minimum C.\nmaxTlaw::F: Maximum temperature according to some law.\nminTlaw::F: Minimum temperature according to some law.\nnoise_A_magnitude::F: Magnitude of noise in A.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Sleipnir.PhysicalParameters-Tuple{}","page":"Parameters","title":"Sleipnir.PhysicalParameters","text":"Initialize the physical parameters of a model.\n\nPhysicalParameters(;\n    ρ::Float64 = 900.0,\n    g::Float64 = 9.81,\n    ϵ::Float64 = 1e-10,\n    η₀::F = 1.0,\n    maxA::Float64 = 8e-17,\n    minA::Float64 = 8.5e-20,\n    maxC::Float64 = 8e-17, # TODO: to be revised\n    minC::Float64 = 8.5e-20,\n    maxTlaw::Float64 = 1.0,\n    minTlaw::Float64 = -25.0,\n    noise_A_magnitude::Float64 = 5e-18\n    )\n\nKeyword arguments\n\n- `ρ`: Ice density\n- `g`: Gravitational acceleration.\n- `ϵ`: Regularization used in the square root of norms for AD numerical stability.\n- `η₀`: Factor to cap surface elevation differences with the upstream ice thickness to impose boundary condition in the iceflow equation\n- `maxA`: Maximum value for `A` (Glen's coefficient)\n- `minA`: Minimum value for `A` (Glen's coefficient)\n- `maxC`: Maximum value of sliding coefficient `C`\n- `minC`: Minimum value of sliding coefficient `C`\n- `maxTlaw`: Maximum value of Temperature used in simulations on fake law\n- `minTlaw`: Minimum value of Temperature used in simulations on fake law\n- `noise_A_magnitude`: Magnitude of noise added to A\n\n\n\n\n\n","category":"method"},{"location":"parameters/#Huginn.SolverParameters","page":"Parameters","title":"Huginn.SolverParameters","text":"A mutable struct that holds parameters for the solver.\n\nSolverParameters{F <: AbstractFloat, I <: Integer}\n\nFields\n\nsolver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm: The algorithm used for solving differential equations.\nreltol::F: The relative tolerance for the solver.\nstep::F: The step size that controls at which frequency the results must be saved.\ntstops::Vector{F}: Optional vector of time points where the solver should stop to store the results.\nsave_everystep::Bool: Flag indicating whether to save the solution at every step computed by the solver.\nprogress::Bool: Flag indicating whether to show progress during the solving process.\nprogress_steps::I: The number of steps between progress updates.\nmaxiters::I: Maximum number of iterations to perform in the iceflow solver.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Huginn.SolverParameters-Tuple{}","page":"Parameters","title":"Huginn.SolverParameters","text":"Constructs a SolverParameters object with the specified parameters or using default values.\n\nSolverParameters(;\n    solver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),\n    reltol::F = 1e-12,\n    step::F = 1.0/12.0,\n    tstops::Vector{Sleipnir.Float} = Vector{Sleipnir.Float}(),\n    save_everystep = false,\n    progress::Bool = true,\n    progress_steps::I = 10,\n    maxiters::I = Int(1e5),\n) where {F <: AbstractFloat, I <: Integer}\n\nArguments\n\nsolver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm: The ODE solver algorithm to use. Defaults to RDPK3Sp35().\nreltol::F: The relative tolerance for the solver. Defaults to 1e-12.\nstep::F: The step size that controls at which frequency the solution should be computed and returned in the results.   Defaults to 1.0/12.0 (i.e. a month).\ntstops::Vector{Sleipnir.Float}: Optional vector of time points where the solver should stop. Defaults to an empty vector.\nsave_everystep::Bool: Whether to save the solution at every step computed by the solver. Defaults to false.\nprogress::Bool: Whether to show progress during the solving process. Defaults to true.\nprogress_steps::I: The number of steps between progress updates. Defaults to 10.\nmaxiters::I: Maximum number of iterations to perform in the iceflow solver. Defaults to 1e5.\n\nReturns\n\nsolver_parameters: A SolverParameters object constructed with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"parameters/#ODINN.Hyperparameters","page":"Parameters","title":"ODINN.Hyperparameters","text":"mutable struct Hyperparameters{F <: AbstractFloat, I <: Integer} <: AbstractParameters\n\nA mutable struct that holds hyperparameters for training a machine learning model.\n\nKeyword arguments\n\ncurrent_epoch::I: The current epoch number.\ncurrent_minibatch::I: The current minibatch number.\nloss_history::Vector{F}: A vector storing the history of loss values.\noptimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}: The optimizer used for training.\nloss_epoch::F: The loss value for the current epoch.\nepochs::I: The total number of epochs for training.\nbatch_size::I: The size of each minibatch.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#ODINN.Hyperparameters-Tuple{}","page":"Parameters","title":"ODINN.Hyperparameters","text":"Hyperparameters(; current_epoch::Int64 = 1, current_minibatch::Int64 = 1, loss_history::Vector{Float64} = Vector{Float64}(), optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule} = BFGS(initial_stepnorm=0.001), loss_epoch::Float64 = 0.0, epochs::Int64 = 50, batch_size::Int64 = 15)\n\nConstructs a Hyperparameters object with the specified parameters.\n\nArguments\n\ncurrent_epoch::Int64: The current epoch number. Defaults to 1.\ncurrent_minibatch::Int64: The current minibatch number. Defaults to 1.\nloss_history::Vector{Float64}: A vector to store the history of loss values. Defaults to an empty vector.\noptimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}: The optimizer to be used. Defaults to BFGS(initial_stepnorm=0.001).\nloss_epoch::Float64: The loss value for the current epoch. Defaults to 0.0.\nepochs::Int64: The total number of epochs. Defaults to 50.\nbatch_size::Int64: The size of each minibatch. Defaults to 15.\n\nReturns\n\nA Hyperparameters object initialized with the provided values.\n\n\n\n\n\n","category":"method"},{"location":"parameters/#ODINN.UDEparameters","page":"Parameters","title":"ODINN.UDEparameters","text":"A mutable struct that holds parameters for a UDE (Universal Differential Equation).\n\nUDEparameters{ADJ <: AbstractAdjointMethod} <: AbstractParameters\n\nFields\n\nsensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm: The sensitivity algorithm used for adjoint sensitivity analysis.\noptimization_method::String: The optimization method to be used.\ntarget::Symbol: The target variable for the optimization.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#ODINN.UDEparameters-Tuple{}","page":"Parameters","title":"ODINN.UDEparameters","text":"UDEparameters(; sensealg, optim_autoAD, grad, optimization_method, empirical_loss_function, target) where {ADJ <: AbstractAdjointMethod}\n\nCreate a UDEparameters object for configuring the sensitivity analysis and optimization of a Universal Differential Equation (UDE).\n\nKeyword Arguments\n\nsensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm: The sensitivity algorithm to use for adjoint calculations. Defaults to GaussAdjoint(autojacvec=SciMLSensitivity.EnzymeVJP()).\noptim_autoAD::AbstractADType: The automatic differentiation type for optimization. Defaults to Optimization.AutoEnzyme().\ngrad::ADJ: The adjoint gradient computation method. Defaults to ContinuousAdjoint().\noptimization_method::String: The optimization method to use. Must be either \"AD+AD\" or \"AD+Diff\". Defaults to \"AD+AD\".\nempirical_loss_function::AbstractLoss: The loss function to use for optimization. Defaults to LossH().\ntarget::Union{Symbol, Nothing}: The target variable for optimization. Defaults to :A.\n\nReturns\n\nA UDEparameters object configured with the specified sensitivity, optimization, and loss settings.\n\nDescription\n\nThis function creates a UDEparameters object that encapsulates the configuration for sensitivity analysis, optimization, and loss computation in a Universal Differential Equation (UDE) framework. It verifies that the provided optimization_method is valid and constructs the solver parameters accordingly.\n\nNotes\n\nThe optimization_method must be either \"AD+AD\" (automatic differentiation for both forward and backward passes) or \"AD+Diff\" (automatic differentiation combined with finite differences).\nThe empirical_loss_function determines how the loss is computed during optimization.\n\n\n\n\n\n","category":"method"},{"location":"vjp_laws/#Law-VJP-customization","page":"VJP law customization","title":"Law VJP customization","text":"This tutorial explains how to customize VJP (vector-Jacobian product) computation of the laws in ODINN.jl and clarifies the runtime flow used internally by the library. It explains which functions are part of the public, user-facing customization API and which are internal helpers used by ODINN when an automatic-differentiation (AD) backend is required.\n\nIt assumes that you have followed the Laws tutorial.\n\nusing ODINN\nrgi_ids = [\"RGI60-11.03638\"]\nrgi_paths = get_rgi_paths()\nparams = Parameters(\n    simulation = SimulationParameters(rgi_paths=rgi_paths),\n    UDE = UDEparameters(grad=ContinuousAdjoint()),\n)\nnn_model = NeuralNetwork(params)","category":"section"},{"location":"vjp_laws/#Explanations","page":"VJP law customization","title":"Explanations","text":"","category":"section"},{"location":"vjp_laws/#High-level-summary","page":"VJP law customization","title":"High-level summary","text":"At the user level the customization can be made by implementing hand-written VJPs through the following functions:\n\nf_VJP_input!(...) — VJP w.r.t. inputs\nf_VJP_θ!(...) — VJP w.r.t. parameters θ\nYou may also implement your own precompute function to cache expensive computations which is the purpose of p_VJP!(...). This function is called before solving the adjoint iceflow PDE.\n\nInternally when the user does NOT provide VJPs, ODINN uses a default AD backend (via DifferentiationInterface.jl) to compute the VJPs of the laws. To support efficient reverse-mode execution, ODINN will:\n\ncompile and precompute adjoint-related helper functions and\nstore preparation objects that are used later during the in adjoint PDE.\n\nThis mechanism is triggered by prepare_vjp_law.","category":"section"},{"location":"vjp_laws/#Internal-function-roles","page":"VJP law customization","title":"Internal function roles","text":"prepare_vjp_law (internal)\nSignature used in the codebase:\nprepare_vjp_law(\n    simulation,\n    law::AbstractLaw,\n    law_cache,\n    θ,\n    glacier_idx,\n)\nIntent and behavior:\nThis is an internal routine. It is NOT intended to be called by users directly.\nIt is invoked when ODINN must fall back to the AD backend (with DifferentiationInterface.jl) because the law did not supply explicit VJP functions (f_VJP_input!/f_VJP_θ! or because p_VJP! is set to DIVJP()).\nIts job is to precompile and prepare the AD-based VJP code for a given law and to produce preparation objects that store preparation results.\nprepare_vjp_law is typically called just after the iceflow model / law objects have been instantiated — i.e., early in the setup — so that preparations are ready before solving or adjoint runs.\nprecompute_law_VJP (used before solving the adjoint PDE)\nThe typical signature in the codebase is:\nprecompute_law_VJP(\n  law::AbstractLaw,\n  cache,\n  vjpsPrepLaw,\n  simulation,\n  glacier_idx,\n  t,\n  θ\n)\nIntent and behavior:\nThis function precomputes VJP-related artifacts before the adjoint iceflow PDE is solved for given time t and parameters θ.\nIt typically uses the vjpsPrepLaw (an AbstractPrepVJP instance produced earlier by prepare_vjp_law) together with the cache and simulation object. The produced results are cached in cache and are optionally consumed later by law_VJP_input / law_VJP_θ during the adjoint solve.\nEntry points used in the adjoint PDE\nThese functions are the actual runtime entry points used when computing contributions of the laws to the gradient in the adjoint PDE:\nlaw_VJP_θ(law::AbstractLaw, cache, simulation, glacier_idx, t, θ)\nand\nlaw_VJP_input(law::AbstractLaw, cache, simulation, glacier_idx, t, θ)\nIntent and behavior:\nThese are called during the adjoint solve to compute parameter and input VJPs for the law at time t and for parameters θ.\nThey can either compute the VJPs directly or use cached VJP information that has been already computed in the user-supplied p_VJP! VJP function. The cache allows storing useful information from the forward or from the precomputation step.\nThey therefore carry the runtime context (simulation, glacier index, time, θ) which is necessary for adjoint calculations.","category":"section"},{"location":"vjp_laws/#Workflow","page":"VJP law customization","title":"Workflow","text":"For the wide audience we do not recommend to play with the VJPs. ODINN comes with default parameters and the average user does not need to customize the VJPs. Keeping the default values will work fine.\n\nAdvanced users seeking maximum performance can customize the VJPs which can significantly speed-up the code.\n\nHow do the pieces compose in practice?\n\nIf you, as a user, provide custom VJP functions (through f_VJP_input!/f_VJP_θ!, or through p_VJP!), ODINN will use them directly at adjoint time and will skip the AD fallback path. You can also provide your own precompute wrapper and cache to optimize expensive computations.\nIf you do NOT provide VJP functions, ODINN runs the AD fallback:\nprepare_vjp_law runs early (post-instantiation) to compile/prepare AD-based helpers and returns some AbstractPrepVJP object.\nprecompute_law_VJP is skipped.\nDuring the adjoint solve, law_VJP_input and law_VJP_θ use the preparation objects precompiled in prepare_vjp_law to automatically differentiate f! with DifferentiationInterface.jl and obtain the VJPs of the law with respect to the inputs and to the parameters θ.\n\ninfo: Info\nYou can change the default AD backend for laws that do not have custom VJPs in the VJP type, for example by setting VJP_method = DiscreteVJP(regressorADBackend = DI.AutoZygote()) when you define the adjoint method.","category":"section"},{"location":"vjp_laws/#User-level-customization","page":"VJP law customization","title":"User level customization","text":"What is user-visible and can be customized?\n\nf_VJP_input!(cache, inputs, θ) — compute the VJP with respect to the inputs and store the result in cache.vjp_inp\nf_VJP_θ!(cache, inputs, θ) — compute the VJP with respect to θ and store the result in cache.vjp_θ\np_VJP!(cache, vjpsPrepLaw, inputs, θ) — if you want to precompute some components (or even the whole VJPs when possible) before solving the adjoint iceflow PDE\ncustom cache implementations (described below)","category":"section"},{"location":"vjp_laws/#Notes-on-cache-definition","page":"VJP law customization","title":"Notes on cache definition","text":"The cache parameter that is threaded through p_VJP!/f_VJP_* calls is the place to store artifacts useful for efficient computation as well as the results of the VJPs computation. The following fields are mandatory:\n\nvalue: a placeholder to store the result of the forward evaluation, can be of any type\nvjp_θ: a placeholder to store the result of the VJP with respect to θ, depending on the type of law that is defined, it can be a vector or a 3 dimensional array\nvjp_inp: a placeholder to store the result of the VJP with respect to the inputs, must be of a type that matches the one of the inputs\n\nIn order to know the type of the inputs, simply run generate_inputs(law.f.inputs, simulation, glacier_idx, t).","category":"section"},{"location":"vjp_laws/#Using-the-preparation-object","page":"VJP law customization","title":"Using the preparation object","text":"error: Error\nFor the moment, using the preparation object at the user level is not supported yet.","category":"section"},{"location":"vjp_laws/#Best-practices-and-debugging-tips","page":"VJP law customization","title":"Best practices and debugging tips","text":"If you supply custom VJPs, test them with finite-difference checks for both inputs and parameters. ODINN does not check that the correctness of your implementation!\nIf you rely on ODINN's AD fallback, be aware that prepare_vjp_law will precompile and prepare AD helpers at model instantiation time — expect longer setup time but faster adjoint runs thereafter.\nInspect/validate cache content if you get inconsistent adjoints — a stale or incorrect cache entry is a common cause.\nAlthough the API is designed to provide everything you need as arguments, if your VJP needs anything from the forward pass, ensure it is stored in the cache.","category":"section"},{"location":"vjp_laws/#Simple-VJP-customization","page":"VJP law customization","title":"Simple VJP customization","text":"We will explore how we can customize the VJP computation of the law that is used in the Laws tutorial. The cache used for this law is a ScalarCache since the output of this law is a scalar value A, the creep coefficient. We can confirm that this type defines the fields needed for the VJP computation:\n\nfieldnames(ScalarCache)\n\nBefore defining the law, we retrieve the model architecture, the physical parameters to be used inside the f! function of the law and we define the inputs:\n\narchi = nn_model.architecture\nst = nn_model.st\nsmodel = ODINN.StatefulLuxLayer{true}(archi, nothing, st)\nmin_NN = params.physical.minA\nmax_NN = params.physical.maxA\ninputs = (; T=iAvgScalarTemp())\n\nAnd then the f! and init_cache functions:\n\nf! = let smodel = smodel, min_NN = min_NN, max_NN = max_NN\n    function (cache, inp, θ)\n        inp = collect(values(inp))\n        A = only(ODINN.scale(smodel(inp, θ.A), (min_NN, max_NN)))\n        ODINN.Zygote.@ignore_derivatives cache.value .= A # We ignore this in-place affectation in order to be able to differentiate it with Zygote hereafter\n        return A\n    end\nend\nfunction init_cache(simulation, glacier_idx, θ)\n    return ScalarCache(zeros(), zeros(), zero(θ))\nend\n\nThe declaration of the law without VJP customization would be:\n\nlaw = Law{ScalarCache}(;\n    inputs = inputs,\n    f! = f!,\n    init_cache = init_cache,\n)\n\nsuccess: Success\nWe see from the output that the VJPs are inferred using DifferentiationInterface.jl and that ODINN does not use precomputation. Now let's try to customize the VJPs by manually implementing the AD step:\n\nlaw = Law{ScalarCache}(;\n    inputs = inputs,\n    f! = f!,\n    f_VJP_input! = function (cache, inputs, θ)\n        nothing # The input does not depend on the glacier state\n    end,\n    f_VJP_θ! = function (cache, inputs, θ)\n        cache.vjp_θ .= ones(length(θ)) # The VJP is wrong on purpose to check that this function is properly called hereafter\n    end,\n    init_cache = init_cache,\n)\n\nIn order to instantiate the cache, we need to define the model:\n\nrgi_ids = [\"RGI60-11.03638\"]\nglaciers = initialize_glaciers(rgi_ids, params)\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=law),\n    mass_balance = nothing,\n    regressors = (; A=nn_model)\n)\nsimulation = Inversion(model, glaciers, params)\n\nWe will also need θ in order to call the VJPs of the law manually although in practice we do not have to worry about retrieving this:\n\nθ = simulation.model.machine_learning.θ\n\nWe then create the cache, and again all of this is handled internally in ODINN. We need to instantiate manually here to demonstrate how the VJPs can be customized.\n\nglacier_idx = 1\nsimulation.cache = ODINN.init_cache(model, simulation, glacier_idx, θ)\n\nFinally we demonstrate that this is our custom implementation that is being called:\n\nODINN.∂law∂θ!(\n    params.UDE.grad.VJP_method.regressorADBackend,\n    simulation.model.iceflow.A,\n    simulation.cache.iceflow.A,\n    simulation.cache.iceflow.A_prep_vjps,\n    (; T=1.0), θ)","category":"section"},{"location":"vjp_laws/#VJP-precomputation","page":"VJP law customization","title":"VJP precomputation","text":"Since the law that we have been using so far does not depend on the glacier state, it could be computed once for all at the beginning of the simulation and the VJPs could be precomputed before solving the adjoint iceflow PDE. The definition of the law below illustrates how we can do this in two ways:\n\nby using DifferentiationInterface.jl to automatically compute the VJPs;\nby manually precomputing the VJPs in the p_VJP function.","category":"section"},{"location":"vjp_laws/#Automatic-precomputation-with-DI","page":"VJP law customization","title":"Automatic precomputation with DI","text":"law = Law{ScalarCache}(;\n    inputs = inputs,\n    f! = f!,\n    init_cache = init_cache,\n    p_VJP! = DIVJP(),\n    callback_freq = 0,\n)\n\nsuccess: Success\nThis law is applied only once before the beginning of the simulation, and the VJP are precomputed automatically.","category":"section"},{"location":"vjp_laws/#Manual-precomputation","page":"VJP law customization","title":"Manual precomputation","text":"law = Law{ScalarCache}(;\n    inputs = inputs,\n    f! = f!,\n    init_cache = init_cache,\n    p_VJP! = function (cache, vjpsPrepLaw, inputs, θ)\n        cache.vjp_θ .= ones(length(θ))\n    end,\n    callback_freq = 0,\n)\n\nsuccess: Success\nThis law is applied only once before the beginning of the simulation, and the VJP are precomputed using our own implementation.","category":"section"},{"location":"vjp_laws/#Simple-cache-customization","page":"VJP law customization","title":"Simple cache customization","text":"In this last section we illustrate how we can define our own cache to store additional information. Our use case is the interpolation of the VJP on a coarse grid. By coarse grid we mean that in order to evaluate the VJP we do not need the differentiate the law for every value of ice thickness we have on the 2D grid at each time step. We only need to pre-evaluate the VJP for a few values of H (this set of values corresponds to the coarse grid), and then we can interpolate the precomputed VJP at the required values of H. The VJPs on the coarse grid are precomputed before solving the adjoint PDE and the evaluation at the exact points in the adjoint PDE are made using an interpolator that is stored inside the cache object.\n\nparams = Parameters(\n    simulation = SimulationParameters(rgi_paths=rgi_paths),\n    UDE = UDEparameters(grad=ContinuousAdjoint(),\n    target = :D_hybrid),\n)\nnn_model = NeuralNetwork(params)\n\nprescale_bounds = [(-25.0, 0.0), (0.0, 500.0)]\nprescale = X -> ODINN._ml_model_prescale(X, prescale_bounds)\npostscale = Y -> ODINN._ml_model_postscale(Y, params.physical.maxA)\n\narchi = nn_model.architecture\nst = nn_model.st\nsmodel = ODINN.StatefulLuxLayer{true}(archi, nothing, st)\n\ninputs = (; T=iAvgScalarTemp(), H̄=iH̄())\n\nf! = let smodel = smodel, prescale = prescale, postscale = postscale\n    function (cache, inp, θ)\n        Y = map(h -> ODINN._pred_NN([inp.T, h], smodel, θ.Y, prescale, postscale), inp.H̄)\n        ODINN.Zygote.@ignore_derivatives cache.value .= Y # # We ignore this in-place affectation in order to be able to differentiate it with Zygote hereafter\n        return Y\n    end\nend\n\nWe define a new cache struct to store the interpolator:\n\nusing Interpolations\nmutable struct MatrixCacheInterp <: Cache\n    value::Array{Float64, 2}\n    vjp_inp::Array{Float64, 2}\n    vjp_θ::Array{Float64, 3}\n    interp_θ::Interpolations.GriddedInterpolation{Vector{Float64}, 1, Vector{Vector{Float64}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{OnGrid}}}, Tuple{Vector{Float64}}}\nend\n\nwarning: Warning\nThe cache must of concrete type.\n\nfunction init_cache_interp(simulation, glacier_idx, θ)\n    glacier = simulation.glaciers[glacier_idx]\n    (; nx, ny) = glacier\n    H_interp = ODINN.create_interpolation(glacier.H₀; n_interp_half = simulation.model.machine_learning.target.n_interp_half)\n    θvec = ODINN.ComponentVector2Vector(θ)\n    grads = [zero(θvec) for i in 1:length(H_interp)]\n    grad_itp = interpolate((H_interp,), grads, Gridded(Linear()))\n    return MatrixCacheInterp(zeros(nx-1, ny-1), zeros(nx-1, ny-1), zeros(nx-1, ny-1, length(θ)), grad_itp)\nend\n\nIn order to initialize the cache, we created a fake interpolation grid above. However, this interpolation grid will be computed during the precomputation step based on the provided inputs at the beginning of the adjoint PDE.\n\nBelow we define the precomputation function which defines a coarse grid and differentiates the neural network at each of these points.\n\nfunction p_VJP!(cache, vjpsPrepLaw, inputs, θ)\n    H_interp = ODINN.create_interpolation(inputs.H̄; n_interp_half = simulation.model.machine_learning.target.n_interp_half)\n    grads = Vector{Float64}[]\n    for h in H_interp\n        ret, = ODINN.Zygote.gradient(_θ -> f!(cache, (; T=inputs.T, H̄=h), _θ), θ)\n        push!(grads, ODINN.ComponentVector2Vector(ret))\n    end\n    cache.interp_θ = interpolate((H_interp,), grads, Gridded(Linear()))\nend\n\nThen at each iteration of the adjoint PDE, we use the interpolator that we evaluate with the values in inputs.H̄. Since many of the points are zeros, we evaluate the interpolator for H̄=0 only once.\n\nfunction f_VJP_θ!(cache, inputs, θ)\n    H̄ = inputs.H̄\n    zero_interp = cache.interp_θ(0.0)\n    for i in axes(H̄, 1), j in axes(H̄, 2)\n        cache.vjp_θ[i, j, :] = map(h -> ifelse(h == 0.0, zero_interp, cache.interp_θ(h)), H̄[i, j])\n    end\nend\n\nFinally we can define the law:\n\nlaw = Law{MatrixCacheInterp}(;\n    inputs = inputs,\n    f! = f!,\n    init_cache = init_cache_interp,\n    p_VJP! = p_VJP!,\n    f_VJP_θ! = f_VJP_θ!,\n    f_VJP_input! = function (cache, inputs, θ) # Not implemented in this example\n    end,\n)\n\nAs in the previous example, we need to define some objects and make the initialization manually to be able to call the internals of ODINN ODINN.precompute_law_VJP and ODINN.∂law∂θ!.\n\nrgi_ids = [\"RGI60-11.03638\"]\nglaciers = initialize_glaciers(rgi_ids, params)\nmodel = Model(\n    iceflow = SIA2Dmodel(params; Y=law),\n    mass_balance = nothing,\n    regressors = (; Y=nn_model)\n)\nsimulation = Inversion(model, glaciers, params)\nθ = simulation.model.machine_learning.θ\nglacier_idx = 1\nt = simulation.parameters.simulation.tspan[1]\nsimulation.cache = ODINN.init_cache(model, simulation, glacier_idx, θ)\n\nApply once to be able to retrieve the inputs\n\ndH = zero(simulation.cache.iceflow.H)\nODINN.Huginn.SIA2D!(dH, simulation.cache.iceflow.H, simulation, t, θ);\nnothing #hide\n\nFinally we call the precompute function and the VJP function called at each iteration of the adjoint PDE.\n\nODINN.precompute_law_VJP(\n    simulation.model.iceflow.Y,\n    simulation.cache.iceflow.Y,\n    simulation.cache.iceflow.Y_prep_vjps,\n    simulation,\n    glacier_idx, t, θ)\n\nODINN.∂law∂θ!(\n    params.UDE.grad.VJP_method.regressorADBackend,\n    simulation.model.iceflow.Y,\n    simulation.cache.iceflow.Y,\n    simulation.cache.iceflow.Y_prep_vjps,\n    (; T=1.0, H̄=simulation.cache.iceflow.H̄), θ)\n\nNow let us check that the vjp_θ field of the cache, which is spatially varying, has been populated:\n\nsimulation.cache.iceflow.Y.vjp_θ","category":"section"},{"location":"vjp_laws/#Frequently-Asked-Questions","page":"VJP law customization","title":"Frequently Asked Questions","text":"Can I use the preparation object in the p_VJP!/f_VJP_* functions?\n\nNo it is not possible for the moment to use the preparation object inside these functions. The preparation object is used to store things precompiled by DifferentiationInterface.jl when p_VJP!=DIVJP() and hence it excludes from using it in p_VJP!. As for f_VJP_*, the preparation object cannot be accessed for the moment. If there is a need, we might add it as an argument in the future.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"models/#Models","page":"Models","title":"Models","text":"There are 3 main types of models in ODINN.jl, iceflow models, mass balance models and machine learning models. These three families are determined by abstract types, with specific types being declared as subtypes of these abstract types to ensure compatibility through the ODINN ecosystem.\n\nThe three main types of models are gathered in a parent type Model in the following way:","category":"section"},{"location":"models/#Ice-flow-models","page":"Models","title":"Ice flow models","text":"Ice flow models are used to solve the PDEs describing the gravitational flow of glaciers. All ice flow models must be a subtype of abstract type IceflowModel. Ice flow models are managed by the Huginn.jl package.\n\nThe main type of ice flow model used in ODINN.jl right now is a 2D Shallow Ice Approximation (SIA) model (Hutter, 1983). This is declared in the following way:\n\nWhen a simulation will be run in ODINN.jl using an ice flow model, its related equation will be solved using OrdinaryDiffEq.jl. The related equation to a SIA2Dmodel is declared in its related util functions. These equations need to be defined in-place (to reduce memory allocations and ensure maximum performance, see example below). This is both compatible with the forward runs and with the reverse pass differentiated using Enzyme.jl.","category":"section"},{"location":"models/#Mass-balance-models","page":"Models","title":"Mass balance models","text":"(Surface) Mass balance models are used to simulate the simplified thermodynamics of the forcing of the atmosphere on glaciers. As per ice flow models, all specific mass balance models needs to be a subtype of the abstract type MBmodel. Mass balance models are managed by Muninn.jl. For now, we have simple temperature-index models, with either one or two degree-day factors (DDFs) (Hock, 2003):\n\nSurface mass balance models are run in DiscreteCallbacks from OrdinaryDiffEq.jl, which enable the safe execution during the solving of a PDE in specificly prescribed time steps determined in the stepsfield in Sleipnir.SimulationParameters.\n\nWe soon plan to add compatibility with neural networks coming from the MassBalanceMachine, which should become the de facto surface mass balance model in the ODINN.jl ecosystem.","category":"section"},{"location":"models/#Regressors","page":"Models","title":"Regressors","text":"Regressors (e.g. machine learning models) are used in the context of Universal Differential Equations (UDEs, Rackauckas et al., 2020) to parametrize or learn specific parts of differential equations. Machine Learning models are managed by ODINN.jl. Virtually all available regressors in Julia can be used inside ODINN, but they need to be correctly interfaced. Here is an example of a simple neural network (multilayer perceptron) using Lux.jl:\n\nIn order to parametrize a given variable inside an (ice flow) model, one can do it via the regressors keyword in Model:\n\nnn_model = NeuralNetwork(params)\nA_law = LawA(nn_model, params)\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    regressors = (; A=nn_model)\n)","category":"section"},{"location":"models/#ODINN.Model","page":"Models","title":"ODINN.Model","text":"Model(;\n    iceflow::Union{IFM, Nothing} = nothing,\n    mass_balance::Union{MBM, Nothing} = nothing,\n    regressors::Union{NamedTuple, Nothing} = nothing,\n    target::Union{TAR, Nothing} = nothing,\n) where {IFM <: IceflowModel, MBM <: MBmodel, TAR <: AbstractTarget}\n\nCreates a new model instance using the provided iceflow, mass balance, and machine learning components.\n\nArguments\n\niceflow::Union{IFM, Nothing}: The iceflow model to be used. Can be a single model or nothing.\nmass_balance::Union{MBM, Nothing}: The mass balance model to be used. Can be a single model or nothing.\nregressors::Union{NamedTuple, Nothing}: The regressors to be used in the laws.\n\nReturns\n\nmodel: A new instance of Sleipnir.Model initialized with the provided components.\n\n\n\n\n\n","category":"function"},{"location":"models/#ODINN.Model-Tuple{}","page":"Models","title":"ODINN.Model","text":"Model(;\n    iceflow::Union{IFM, Nothing} = nothing,\n    mass_balance::Union{MBM, Nothing} = nothing,\n    regressors::Union{NamedTuple, Nothing} = nothing,\n    target::Union{TAR, Nothing} = nothing,\n) where {IFM <: IceflowModel, MBM <: MBmodel, TAR <: AbstractTarget}\n\nCreates a new model instance using the provided iceflow, mass balance, and machine learning components.\n\nArguments\n\niceflow::Union{IFM, Nothing}: The iceflow model to be used. Can be a single model or nothing.\nmass_balance::Union{MBM, Nothing}: The mass balance model to be used. Can be a single model or nothing.\nregressors::Union{NamedTuple, Nothing}: The regressors to be used in the laws.\n\nReturns\n\nmodel: A new instance of Sleipnir.Model initialized with the provided components.\n\n\n\n\n\n","category":"method"},{"location":"models/#Huginn.SIA2Dmodel","page":"Models","title":"Huginn.SIA2Dmodel","text":"SIA2Dmodel(A, C, n, Y, U, n_H, n_∇S)\nSIA2Dmodel(params; A, C, n, Y, U, n_H, n_∇S)\n\nCreate a SIA2Dmodel, representing a two-dimensional Shallow Ice Approximation (SIA) model.\n\nThe SIA model describes glacier flow under the assumption that deformation and basal sliding dominate the ice dynamics. It relies on:\n\nGlen's flow law for internal deformation, with flow rate factor A and exponent n,\nA sliding law governed by coefficient C,\nOptionally the user can provide either:\nA specific diffusive velocity U such that D = U * H\nA modified creep coefficient Y that takes into account the ice thickness   such that D = (C + Y * 2/(n+2)) * (ρ*g)^n * H^(n_H+1) * |∇S|^(n_∇S-1)   where n_H and n_∇S are optional parameters that control if the SIA   should use the n law or not.   This formulation is denoted as the hybrid diffusivity in the code.\n\nThis struct stores the laws used to compute these three parameters during a simulation. If not provided, default constant laws are used based on glacier-specific values.\n\nArguments\n\nA: Law for the flow rate factor. Defaults to a constant value from the glacier.\nC: Law for the sliding coefficient. Defaults similarly.\nn: Law for the flow law exponent. Defaults similarly.\np: Law for the sliding law exponent (basal drag). Defaults similarly.\nq: Law for the sliding law exponent (normal stress). Defaults similarly.\nY: Law for the hybrid diffusivity. Providing a law for Y discards the laws of A, C and n.\nU: Law for the diffusive velocity. Defaults behavior is to disable it and in such a case it is computed from A, C and n. Providing a law for U discards the laws of A, C, n and Y.\nn_H::F: The exponent to use for H in the SIA equation when using the Y law (hybrid diffusivity). It should be nothing when this law is not used.\nn_∇S::F: The exponent to use for ∇S in the SIA equation when using the Y law (hybrid diffusivity). It should be nothing when this law is not used.\nY_is_provided::Bool: Whether the diffusivity is provided by the user through the hybrid diffusivity Y or it has to be computed from the SIA formula from A, C and n.\nU_is_provided::Bool: Whether the diffusivity is provided by the user through the diffusive velocity U or it has to be computed from the SIA formula from A, C and n.\nn_H_is_provided::Bool: Whether the H exponent is prescribed by the user, or the one of the n law has to be used. This flag is used only when a law for Y is used.\nn_∇S_is_provided::Bool: Whether the ∇S exponent is prescribed by the user, or the one of the n law has to be used. This flag is used only when a law for Y is used.\napply_A_in_SIA::Bool: Whether the value of the A law should be computed each time the SIA is evaluated.\napply_C_in_SIA::Bool: Whether the value of the C law should be computed each time the SIA is evaluated.\napply_n_in_SIA::Bool: Whether the value of the n law should be computed each time the SIA is evaluated.\napply_p_in_SIA::Bool: Whether the value of the p law should be computed each time the SIA is evaluated.\napply_q_in_SIA::Bool: Whether the value of the q law should be computed each time the SIA is evaluated.\napply_Y_in_SIA::Bool: Whether the value of the Y law should be computed each time the SIA is evaluated.\napply_U_in_SIA::Bool: Whether the value of the U law should be computed each time the SIA is evaluated.\n\n\n\n\n\n","category":"type"},{"location":"models/#Huginn.SIA2D!","page":"Models","title":"Huginn.SIA2D!","text":"SIA2D!(\n    dH::Matrix{R},\n    H::Matrix{R},\n    simulation::SIM,\n    t::R,\n    θ,\n) where {R <:Real, SIM <: Simulation}\n\nSimulates the evolution of ice thickness in a 2D shallow ice approximation (SIA) model. Works in-place.\n\nArguments\n\ndH::Matrix{R}: Matrix to store the rate of change of ice thickness.\nH::Matrix{R}: Matrix representing the ice thickness.\nsimulation::SIM: Simulation object containing model parameters and state.\nt::R: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nDetails\n\nThis function updates the ice thickness H and computes the rate of change dH using the shallow ice approximation in 2D. It retrieves necessary parameters from the simulation object, enforces positive ice thickness values, updates glacier surface altimetry and computes surface gradients. It then applies the necessary laws that are not updated via callbacks (A, C, n or U depending on the use-case) and computes the flux components, and flux divergence.\n\nNotes\n\nThe function operates on a staggered grid for computing gradients and fluxes.\nSurface elevation differences are capped using upstream ice thickness to impose boundary conditions.\nThe function modifies the input matrices dH and H in-place.\n\nSee also SIA2D\n\n\n\n\n\n","category":"function"},{"location":"models/#Muninn.TImodel1","page":"Models","title":"Muninn.TImodel1","text":"TImodel1{F <: AbstractFloat}\n\nA structure representing a temperature index model with degree-day factor and accumulation factor.\n\nKeyword arguments\n\nDDF::F: Degree-day factor, which is a coefficient used to convert temperature into melt.\nacc_factor::F: Accumulation factor, which is a coefficient used to adjust the accumulation of mass.\n\nType Parameters\n\nF: A subtype of AbstractFloat representing the type of the factors.\n\n\n\n\n\n","category":"type"},{"location":"models/#Muninn.TImodel1-Tuple{Sleipnir.Parameters}","page":"Models","title":"Muninn.TImodel1","text":"TImodel1(params::Sleipnir.Parameters; DDF::F = 7.0/1000.0, acc_factor::F = 1.0/1000.0) where {F <: AbstractFloat}\n\nCreate a temperature index model with one degree-day factor (DDF) with the given parameters.\n\nArguments\n\nparams::Sleipnir.Parameters: The simulation parameters.\nDDF::F: Degree-day factor (default is 7.0/1000.0).\nacc_factor::F: Accumulation factor (default is 1.0/1000.0).\n\nReturns\n\nTI1_model: An instance of TImodel1 with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"models/#ODINN.NeuralNetwork","page":"Models","title":"ODINN.NeuralNetwork","text":"NeuralNetwork{\n    ChainType <: Lux.Chain,\n    ComponentVectorType <: ComponentVector,\n    NamedTupleType <: NamedTuple,\n} <: FunctionalModel\n\nFeed-forward neural network.\n\nFields\n\narchitecture::ChainType: Flux.Chain neural network architecture\nθ::ComponentVectorType: Neural network parameters\nst::NamedTupleType: Neural network status\n\n\n\n\n\n","category":"type"},{"location":"contribute/#How-to-contribute","page":"How to contribute","title":"How to contribute","text":"We welcome all types of contributions to the ODINN ecosystem! Most of the code, documentation, and features of ODINN are constantly under development, so your feedback can be very helpful! If you are interested in contributing, there are many ways in which you can help:\n\nReport bugs in the code. You can report problems with the code by opening issues under the issues tab in the ODINN repository. Please explain the problem you encounter and try to give a complete description of it so we can follow up on that.\nRequest new features and documentation. If there is an important topic or example that you feel falls under the scope of this project and you would like us to include it, please request it! We are looking for new insights into what the community wants to learn.\nContribute to the source code. We welcome pull requests (PRs) to any  of the libraries in the ODINN ecosystem. In order to contribute, please make a fork of the repository you would like to contribute to, and then submit a PR to:\nthe dev branch in ODINN.jl (main is only updated from time to time when enough meaningful commits are available to perform a new release);\nthe main branch in Sleipnir.jl, Muninn.jl and Huginn.jl.\n\nWe will review your PR it and provide feedback. If you are looking for ideas of how to contribute with code, you can check the opened issues in our repositories.\n\ntip: Tip\nIf you need help navigating the world of PRs and contributing in GitHub, we encourage you to take a look at the tutorial put together by our OGGM friends.","category":"section"},{"location":"contribute/#SciML-code-style","page":"How to contribute","title":"SciML code style","text":"In the ODINN.jl ecosystem, we follow the SciML code style. If you make changes to Sleipnir.jl, Muninn.jl, Huginn.jl or ODINN.jl, make sure that you have installed the code formatting tool before committing any change.\n\nwarning: Warning\nIf you open a PR with changes that were not properly formatted, the CI will raise an error and in any case a PR that does not follow the coding style cannot be merged.\n\nWe use JuliaFormatter.jl to format the code. This can be run automatically everytime you commit changes by using pre-commit which installs a pre-commit hook. The pre-commit hook is defined at the root of each repository, for example here for ODINN.jl.","category":"section"},{"location":"contribute/#Install-the-pre-commit-hook","page":"How to contribute","title":"Install the pre-commit hook","text":"In order to install the pre-commit hook, make sure that you have installed pre-commit in a Python environment:\n\npip install pre-commit\n\nThen in the environment where you have installed pre-commit, simply run:\n\npre-commit install\n\nnote: Note\nYou have to install the pre-commit hook (second command) in each of the packages you edit.\n\nnote: Note\nWhen committing changes, you don't need to be in the Python environment where pre-commit has been installed. This environment is used only for the installation of the hook.","category":"section"},{"location":"contribute/#Commit-changes","page":"How to contribute","title":"Commit changes","text":"Once you have staged your changes, when running the git commit command, the hook will trigger and the JuliaFormatter will ask you to confirm the formatting that have been applied (if changes to the code format were necessary).","category":"section"},{"location":"contribute/#Contributing-to-the-documentation","page":"How to contribute","title":"Contributing to the documentation","text":"Here we show the basics around building the docs locally and making contributions.\n\nwarning: Multiprocessing in the documentation\nIn order to use multiprocessing in the documentation, we set up a specific number of workers in the Julia session in the documentation.yml file. It is imperative that the number of workers set there matches the ones set in the Julia code run in the documentation. By default, we have set them to -p 3 in documentation.yml, meaning that 3 workers will be added on top of the head one. This will match the default number of workers in SimulationParameters, but if you manually specify them, make sure to set them to 4 (the number of parameters in ODINN DOES include the head worker). This is often a source of confusion, so refrain from playing with the number of workers in the documentation. ","category":"section"},{"location":"contribute/#Running-the-documentation-in-local","page":"How to contribute","title":"Running the documentation in local","text":"This section contains the instructions to run the documentation locally.\n\nTo generate the documentation on your local computer, in the docs/ folder run:\n\ninclude(\"make.jl\")\n\nThen in another REPL, in the docs/ folder, activate the docs environment and run the server:\n\nusing Pkg\nPkg.activate()\nusing LiveServer\nserve()\n\nThis will print a localhost URL that you can open in your browser. Then, click on the build folder to visualize the documentation.\n\nnote: What to do when it freezes?\nIf the building of the documentation freezes, there can be several reasons that cause this. First try to run include(\"testdocs.jl\") which will run the tutorial examples. If there is an error during the execution, this will be easier to spot it as Literate.jl does not always report the error. If after making sure that the code runs smoothly this still freezes, inspect the generated .md files (see the list of files at the beginning of make.jl) and check that the markdown file was generated properly (code in @example sections).","category":"section"},{"location":"quick_start/#Quick-start","page":"Quick start","title":"Quick start","text":"Before going into model details, it is always better to have a quick overview with a simple example on how ODINN.jl is used from a user point of view. This is the simplest example of how to create and run a simple glacier forward simulation:\n\nusing ODINN\n\nworking_dir = joinpath(ODINN.root_dir, \"demos\")\nmkpath(working_dir)\n\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n        multiprocessing=false,\n        rgi_paths = rgi_paths\n    )\n)\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),\n)\n\nglaciers = initialize_glaciers(rgi_ids, params)\nprediction = Prediction(model, glaciers, params)\nrun!(prediction)\n\nThis code will run a forward simulation for the glaciers defined in rgi_ids from 2010 to 2015, using the specified ice flow and mass balance models. The results will be stored in the working_dir directory.\n\nThen, we can easily visualize the results of the simulation, e.g. the difference in ice thickness between 2010 to 2015 for Argentière glacier:\n\npdiff = plot_glacier(prediction.results[1], \"evolution difference\", [:H]; metrics=[\"difference\"])\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"functional_inversion/#Functional-inversion-tutorial","page":"Functional inversion","title":"Functional inversion tutorial","text":"This tutorial provides a simple example on how to perform a functional inversion using Universal Differential Equations (UDEs) in ODINN.jl. For this, we will generate a synthetic dataset using a forward simulation, and then we will use this dataset to perform the functional inversion. The goal of this functional inversion will be to learn a synthetic law that maps A, i.e. the ice rigidity, to long-term changes in atmospheric surface temperature.\n\nFor more details on the functional inversion concept, please refer to the Functional Inversion section in the Inversion types page.","category":"section"},{"location":"functional_inversion/#Running-the-whole-code","page":"Functional inversion","title":"Running the whole code","text":"using ODINN\n\n# Define the working directory\nworking_dir = joinpath(ODINN.root_dir, \"demos\")\n\n## We fetch the paths with the files for the available glaciers on disk\nrgi_paths = get_rgi_paths()\n\n# Ensure the working directory exists\nmkpath(working_dir)\n\n# Define which glacier RGI IDs we want to work with\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-07.00065\"]\n# Define the time step for the simulation output and for the adjoint calculation. In this case, a month.\nδt = 1/12\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir=working_dir,\n        use_MB=false,\n        use_velocities=true,\n        tspan=(2010.0, 2015.0),\n        multiprocessing=true,\n        workers=4,\n        test_mode=false,\n        rgi_paths=rgi_paths,\n        gridScalingFactor=4), # Downscale the glacier grid to speed-up this example\n    hyper = Hyperparameters(\n        batch_size=length(rgi_ids), # We set batch size equals all datasize so we test gradient\n        epochs=[15,10],\n        optimizer=[ODINN.ADAM(0.01), ODINN.LBFGS(linesearch = ODINN.LineSearches.BackTracking(iterations = 5))]),\n    physical = PhysicalParameters(\n        minA = 8e-21,\n        maxA = 8e-17),\n    UDE = UDEparameters(\n        optim_autoAD=ODINN.NoAD(),\n        grad=ContinuousAdjoint(),\n        optimization_method=\"AD+AD\",\n        empirical_loss_function = LossH() # Loss function based on ice thickness\n    ),\n    solver = Huginn.SolverParameters(\n        step=δt,\n        progress=true)\n)\n\n# We define a synthetic law to generate the synthetic dataset. For this, we use some tabular data from Cuffey and Paterson (2010).\nA_law = CuffeyPaterson(scalar=true)\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n)\n\n# We initialize the glaciers with all the necessary data\nglaciers = initialize_glaciers(rgi_ids, params)\n\n# Time snapshots for transient inversion\ntstops = collect(2010:δt:2015)\n\n# We generate the synthetic dataset using the forward simulation. This will generate a dataset with the ice thickness and surface velocities for each glacier at each time step. The dataset will be used to train the machine learning model.\nglaciers = generate_ground_truth(glaciers, params, model, tstops)\n\n## After this forward simulation, we restart the iceflow model to be ready for the inversions\nnn_model = NeuralNetwork(params)\nA_law = LawA(nn_model, params)\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    regressors = (; A=nn_model)\n)\n\n# We specify the type of simulation we want to perform\nfunctional_inversion = Inversion(model, glaciers, params)\n\n# And finally, we just run the simulation\nrun!(functional_inversion)","category":"section"},{"location":"functional_inversion/#Step-by-step-explanation-of-the-tutorial","page":"Functional inversion","title":"Step-by-step explanation of the tutorial","text":"Here we will cover in detail each one of the steps that lead us to run the Inversion from the previous example. The goal of this simple example is to learn a mapping of a law for A, the creep coefficient of ice. Mathematically, we make A depends on the long term air temperature T through a neural network A=NN(T, θ) and we optimize θ so that the generated solution matches some ice thickness reference. This reference is generated using the relation of the book from Cuffey and Paterson (2010).","category":"section"},{"location":"functional_inversion/#Step-1:-Parameter-and-glacier-initialization","page":"Functional inversion","title":"Step 1: Parameter and glacier initialization","text":"First we need to specify a list of RGI IDs of the glacier we want to work with. Specifying an RGI region is also possible. From these RGI IDs, we will look for the necessary files inside the workspace.\n\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-07.00065\"]\nrgi_paths = get_rgi_paths()\n\nDefine the time step for the simulation output and for the adjoint calculation. In this case, a month.\n\nδt = 1/12\n\nThen we need to define the parameters of the simulation we want to perform. The arguments are very similar to the ones used in the forward simulation tutorial and for a complete explanation, the reader should refer to this tutorial. The main difference with the forward simulation tutorial here is that we need to specify the parameters for the functional inversion through the Hyperparameters and the UDEparameters. The Hyperparameters structure contains information about the optimization algorithm. The UDEparameters define how the Universal Differential Equation (UDE) is solved and how its gradient is computed.\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir=working_dir,\n        use_MB=false,\n        use_velocities=true,\n        tspan=(2010.0, 2015.0),\n        multiprocessing=true,\n        workers=4,\n        test_mode=false,\n        rgi_paths=rgi_paths,\n        gridScalingFactor=4), # Downscale the glacier grid to speed-up this example\n    hyper = Hyperparameters(\n        batch_size=length(rgi_ids), # We set batch size equals all datasize so we test gradient\n        epochs=[15,10],\n        optimizer=[ODINN.ADAM(0.01), ODINN.LBFGS(linesearch = ODINN.LineSearches.BackTracking(iterations = 5))]),\n    physical = PhysicalParameters(\n        minA = 8e-21,\n        maxA = 8e-17),\n    UDE = UDEparameters(\n        optim_autoAD=ODINN.NoAD(),\n        grad=ContinuousAdjoint(),\n        optimization_method=\"AD+AD\",\n        target = :A),\n    solver = Huginn.SolverParameters(\n        step=δt,\n        progress=true)\n)\n\nThen, we initialize those glaciers based on those RGI IDs and the parameters we previously specified.\n\nglaciers = initialize_glaciers(rgi_ids, params)","category":"section"},{"location":"functional_inversion/#Step-2:-Defining-a-forward-simulation-as-a-synthetic-ground-truth","page":"Functional inversion","title":"Step 2: Defining a forward simulation as a synthetic ground truth","text":"The next step is to generate a synthetic dataset using a forward simulation. This will generate a dataset with the ice thickness and surface velocities for each glacier at each time step. The dataset will be used to train the machine learning model. We define a synthetic law to generate the synthetic dataset. For this, we use some tabular data from Cuffey and Paterson (2010). The REPL shows that it maps the long term air temperature T to the creep coefficient A.\n\nA_law = CuffeyPaterson(scalar=true)\n\nThe model is initialized using the Model constructor:\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n)\n\nWe define the time snapshots for transient inversion, i.e. the time steps at which we want to save the results, which will be used to compute the adjoint in reverse mode.\n\ntstops = collect(2010:δt:2015)\n\nprediction = Prediction(model, glaciers, params)\n\nWe generate the synthetic dataset using the forward simulation. This will generate a dataset with the ice thickness and surface velocities for each glacier at each time step. The dataset will be used to train the machine learning model. This will  run under the hood a Prediction using Huginn.jl.\n\nglaciers = generate_ground_truth(glaciers, params, model, tstops)\n\nThe results of this simulation are stored in the thicknessData field of each glacier.","category":"section"},{"location":"functional_inversion/#Step-3:-Model-specification-to-perform-a-functional-inversion","page":"Functional inversion","title":"Step 3: Model specification to perform a functional inversion","text":"After this forward simulation, we define a new iceflow model to be ready for the inversions. The first step is to define a simple neural network that takes as input a scalar and returns a scalar.\n\nnn_model = NeuralNetwork(params)\n\nThen we define a law that uses this neural network to map the long term air temperature T to the creep coefficient A. ODINN comes with a set of already defined laws. Only a few of them support functional inversion as the computation of the gradient needs to be carefully handled. More information about these laws can be found in the laws tutorial.\n\nA_law = LawA(nn_model, params)\n\nThen we define an iceflow and ODINN tells us how the law is used in the iceflow equation.\n\niceflow = SIA2Dmodel(params; A=A_law)\n\nFinally we define the model which needs to know the iceflow and mass balance models, and in comparison to Huginn, there is a third argument regressors. This regressors argument tells how each regressor relates into the SIA. Although we already defined this in the iceflow model, this definition is mandatory for technical reasons. This argument will probably disappear in the future once the code becomes more mature. It must match how the laws are defined in the iceflow model.\n\nmodel = Model(\n    iceflow = iceflow,\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    regressors = (; A=nn_model)\n)","category":"section"},{"location":"functional_inversion/#Step-4:-Train-a-Universal-Differential-Equation-via-a-functional-inversion","page":"Functional inversion","title":"Step 4: Train a Universal Differential Equation via a functional inversion","text":"The next step is to specify the type of simulation we want to perform. In this case, we will use a Inversion simulation, which will use the synthetic dataset generated in the previous step to train a Universal Differential Equation (UDE) model.\n\nfunctional_inversion = Inversion(model, glaciers, params)\n\nAnd finally, we just run the simulation. This will run the adjoint method to compute the gradients and then use the ADAM optimizer to train the UDE model.\n\nrun!(functional_inversion)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"changes_plans/#Ongoing-changes-and-future-plans","page":"Ongoing changes and future plans","title":"Ongoing changes and future plans","text":"In this page we will attempt to document the main ongoing changes in terms of model development, and the main features we are planning for the future.\n\nWe are currently working on ensuring full end-to-end differentiability of the whole ODINN ecosystem with SciMLSensitivy.jl and Enzyme.jl to have automatic continuous adjoints. We are very close to achieving this. A new release, including other ongoing features will be announced once everything is properly integrated and tested.\nWe have plans to host all the preprocessed glacier directories in a server, so users can automatically download them without having to preprocess them using Gungnir. \nGPU compatibility is still not available. For now, we are focusing on having everything parallelized with multiprocessing while being compatible with automatic differentiation (AD). Once this codebase is stable, we might implement a GPU-compatible version. ","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"This is an exhaustive list of all the types and functions in ODINN.jl, Huginn.jl, Muninn.jl and Sleipnir.jl.","category":"section"},{"location":"api/#ODINN.AbstractAdjointMethod-api","page":"API","title":"ODINN.AbstractAdjointMethod","text":"AbstractAdjointMethod\n\nAbstract type representing the flavor of AD and adjoint to be used to compute the gradient of the cost function. There are two parts where one can play with how the gradient is propagated: the iceflow model VJP and the adjoint of the ODE solver. The VJP of the iceflow model can be computed using either AD (Zygote or Enzyme), the discrete, or the continuous adjoint of the iceflow model. As for the computation of the adjoint of the ODE solution, it can be handled by SciMLSensitivity, or computed using the adjoint implemented in ODINN.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.AbstractVJPMethod-api","page":"API","title":"ODINN.AbstractVJPMethod","text":"AbstractVJPMethod\n\nAbstract type representing the flavor of AD to be used to compute the VJP inside the gradient of the cost function.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.ContinuousAdjoint-api","page":"API","title":"ODINN.ContinuousAdjoint","text":"ContinuousAdjoint{\n    F <: AbstractFloat,\n    I <: Integer,\n    VJP <: AbstractVJPMethod,\n    MBVJP <: AbstractVJPMethod,\n} <: AbstractAdjointMethod\n\nContinuous adjoint of SIA2D with manual implementation of the backward in the ODE scheme.\n\nFields\n\nVJP_method::VJP: Type of AbstractVJPMethod used to compute VJPs inside adjoint   calculation.\nsolver::Any: The solver to be used for adjoint.\nreltol::F: Relative tolerance to be used in the ODE solver of the adjoint.\nabstol::F: Absolute tolerance to be used in the ODE solver of the adjoint.\ndtmax::F: Maximum time step to be used in the ODE solver of the adjoint.\ninterpolation: Interpolation method to be used to interpolate the variables in   the computation of the adjoint. Currently only :Linear is supported.\nn_quadrature::I: Number of nodes used in the Gauss quadrature for the numerical   integration of the loss function.\nMB_VJP::MBVJP: Type of AbstractVJPMethod used to compute the MB VJP inside adjoint   calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.ContinuousVJP-api","page":"API","title":"ODINN.ContinuousVJP","text":"ContinuousVJP{ADTYPE <: DI.AbstractADType} <: AbstractVJPMethod\n\nContinuous manual implementation of the VJP required inside the adjoint calculation. It relies in the continuous expresion for the adjoint operation based on the functional formula of the forward PDE.\n\nFields\n\nregressorADBackend::ADTYPE: Specifies the AD backend used for the laws when   their associated VJPs functions are not provided. The type parameter ADTYPE   must be a subtype of DI.AbstractADType.\n\nConstructor\n\nThe default constructor allows specifying the backend via the regressorADBackend   keyword argument, defaulting to DI.AutoMooncake().\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.DiffusivityRegularization-api","page":"API","title":"ODINN.DiffusivityRegularization","text":"DiffusivityRegularization(; reg = TikhonovRegularization())\n\nRegularization for diffusivity fields using a specified spatial operator.\n\nKeyword Arguments\n\nreg::AbstractSimpleRegularization = TikhonovRegularization(): Spatial regularization operator applied to diffusivity.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.DiscreteAdjoint-api","page":"API","title":"ODINN.DiscreteAdjoint","text":"DiscreteAdjoint{\n    VJP <: AbstractVJPMethod,\n    MBVJP <: AbstractVJPMethod,\n} <: AbstractAdjointMethod\n\nDiscrete adjoint of SIA2D with manual implementation of the backward in the ODE scheme.\n\nFields\n\nVJP_method: Type of AbstractVJPMethod used to compute VJPs inside adjoint   calculation.\nMB_VJP::MBVJP: Type of AbstractVJPMethod used to compute the MB VJP inside adjoint   calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.DiscreteVJP-api","page":"API","title":"ODINN.DiscreteVJP","text":"DiscreteVJP{ADTYPE <: DI.AbstractADType} <: AbstractVJPMethod\n\nDiscrete manual implementation of the VJP required inside the adjoint calculation. This implements the pullback function for the function to differentiate.\n\nFields\n\nregressorADBackend::ADTYPE: Specifies the AD backend used for the laws when   their associated VJPs functions are not provided. The type parameter ADTYPE   must be a subtype of DI.AbstractADType.\n\nConstructor\n\nThe default constructor allows specifying the backend via the regressorADBackend   keyword argument, defaulting to DI.AutoMooncake().\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.DummyAdjoint-api","page":"API","title":"ODINN.DummyAdjoint","text":"Struct to provide a dummy gradient. It does not have to be the true gradient. Mainly used to test that the optimization pileline works independenly of the gradient calculation.\n\nDummyAdjoint\n\nFields:\n\ngrad::Function: In-place function f(du, u; kwargs) that fills the first   argument du with the gradient values.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.EnzymeVJP-api","page":"API","title":"ODINN.EnzymeVJP","text":"Enzyme implementation of VJP used inside the adjoint calculation.\n\nEnzymeVJP\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.FunctionalModel-api","page":"API","title":"ODINN.FunctionalModel","text":"FunctionalModel <: TrainableModel\n\nAbstract type representing functional learnable components of the model. This is a subtype of TrainableModel. Typically used for functional inversions.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.GlacierWideInv-api","page":"API","title":"ODINN.GlacierWideInv","text":"GlacierWideInv{\n    ComponentVectorType <: ComponentVector\n} <: PerGlacierModel\n\nPer glacier invertible parameter container. GlacierWideInv wraps a ComponentVector (θ) that stores one scalar parameter per glacier and implements the PerGlacierModel interface used by the inversion machinery.\n\nFields\n\nθ::ComponentVectorType: The per glacier parameter vector (one scalar value per glacier).\n\nConstructor\n\nGlacierWideInv(\n    params::Sleipnir.Parameters,\n    glaciers::Vector{<: AbstractGlacier},\n    var::Symbol,\n)\n\nArguments\n\nparams::Sleipnir.Parameters: Parameters struct.\nglaciers::Vector{<: AbstractGlacier}: Vector of AbstractGlacier. The i-th entry in θ corresponds to glaciers[i].\nvar::Symbol: Symbol naming the field on each glacier to use as the initial value.\n\nExample\n\nGlacierWideInv(params, glaciers, :A)\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.GriddedInv-api","page":"API","title":"ODINN.GriddedInv","text":"GriddedInv{\n    ComponentVectorType <: ComponentVector\n} <: PerGlacierModel\n\nPer glacier invertible parameter container. GriddedInv wraps a ComponentVector (θ) that stores one matrix parameter per glacier and implements the PerGlacierModel interface used by the inversion machinery.\n\nFields\n\nθ::ComponentVectorType: The per glacier parameter vector (one matrix per glacier).\n\nConstructor\n\nGriddedInv(\n    params::Sleipnir.Parameters,\n    glaciers::Vector{<: AbstractGlacier},\n    var::Symbol,\n)\n\nArguments\n\nparams::Sleipnir.Parameters: Parameters struct.\nglaciers::Vector{<: AbstractGlacier}: Vector of AbstractGlacier. The i-th entry in θ corresponds to glaciers[i].\nvar::Symbol: Symbol naming the field on each glacier to use as the initial value.\n\nExample\n\nGriddedInv(params, glaciers, :A)\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.Hyperparameters-Tuple{}-api","page":"API","title":"ODINN.Hyperparameters","text":"Hyperparameters(; current_epoch::Int64 = 1, current_minibatch::Int64 = 1, loss_history::Vector{Float64} = Vector{Float64}(), optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule} = BFGS(initial_stepnorm=0.001), loss_epoch::Float64 = 0.0, epochs::Int64 = 50, batch_size::Int64 = 15)\n\nConstructs a Hyperparameters object with the specified parameters.\n\nArguments\n\ncurrent_epoch::Int64: The current epoch number. Defaults to 1.\ncurrent_minibatch::Int64: The current minibatch number. Defaults to 1.\nloss_history::Vector{Float64}: A vector to store the history of loss values. Defaults to an empty vector.\noptimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}: The optimizer to be used. Defaults to BFGS(initial_stepnorm=0.001).\nloss_epoch::Float64: The loss value for the current epoch. Defaults to 0.0.\nepochs::Int64: The total number of epochs. Defaults to 50.\nbatch_size::Int64: The size of each minibatch. Defaults to 15.\n\nReturns\n\nA Hyperparameters object initialized with the provided values.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Hyperparameters-api","page":"API","title":"ODINN.Hyperparameters","text":"mutable struct Hyperparameters{F <: AbstractFloat, I <: Integer} <: AbstractParameters\n\nA mutable struct that holds hyperparameters for training a machine learning model.\n\nKeyword arguments\n\ncurrent_epoch::I: The current epoch number.\ncurrent_minibatch::I: The current minibatch number.\nloss_history::Vector{F}: A vector storing the history of loss values.\noptimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}: The optimizer used for training.\nloss_epoch::F: The loss value for the current epoch.\nepochs::I: The total number of epochs for training.\nbatch_size::I: The size of each minibatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.InitialCondition-api","page":"API","title":"ODINN.InitialCondition","text":"InitialCondition{\n    ComponentVectorType <: ComponentVector\n} <: PerGlacierModel\n\nPer glacier initial condition container. InitialCondition wraps a ComponentVector (θ) that stores one matrix per glacier and implements the InitialCondition interface used by the inversion machinery.\n\nFields\n\nθ::ComponentVectorType: The per glacier matrix of initial condition.\n\nConstructor\n\nInitialCondition(\n    params::Sleipnir.Parameters,\n    glaciers::Vector{<: AbstractGlacier},\n    initialization::Symbol = :Farinotti2019,\n)\n\nArguments\n\nparams::Sleipnir.Parameters: Parameters struct.\nglaciers::Vector{<: AbstractGlacier}: Vector of AbstractGlacier. The i-th entry in θ corresponds to glaciers[i].\ninitialization::Symbol: Symbol providing the way the initial condition should be initialized.\n\nExample\n\n```julia InitialCondition(params, glaciers, :Farinotti2019)\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.InitialThicknessRegularization-api","page":"API","title":"ODINN.InitialThicknessRegularization","text":"InitialThicknessRegularization(; reg = TikhonovRegularization(), t₀ = 1994.0)\n\nA composite regularization type designed for initial ice thickness. It combines a simple spatial regularization (e.g., TikhonovRegularization) with a reference initial time.\n\nKeyword Arguments\n\nreg::AbstractSimpleRegularization = TikhonovRegularization(): The spatial regularization operator applied to the initial field. By default, a Tikhonov (Laplacian-based) regularization is used.\nt₀::AbstractFloat = 1994.0: The reference initial time (e.g., year) at which the regularization applies.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.Inversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G<:AbstractGlacier, M<:Sleipnir.Model, P<:Sleipnir.Parameters}-api","page":"API","title":"ODINN.Inversion","text":"function Inversion(\n    model::M,\n    glaciers::Vector{G},\n    parameters::P\n) where {G <: Sleipnir.AbstractGlacier, M <: Sleipnir.Model, P <: Sleipnir.Parameters}\n\nConstructor for Inversion struct with glacier model information, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{G}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\n\nReturns\n\nInversion: A new instance of the Inversion struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Inversion-api","page":"API","title":"ODINN.Inversion","text":"mutable struct Inversion{MODEL, CACHE, GLACIER, RES} <: Simulation\n\nAn object representing an inversion simulation. It can involve at the same time a classical inversion and a functional inversion (i.e. the inversion of a function using some data-driven regressor).\n\nFields\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\nresults::ODINN.Results: A ODINN.Results instance to store the results of the inversion and of the forward simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.InversionBinder-api","page":"API","title":"ODINN.InversionBinder","text":"InversionBinder{FI <: Inversion, CA <: ComponentArray}\n\nStruct used for the binding with SciMLSensitivity. It is defined as a SciMLStructure and it contains the inversion structure and the vector of parameters to differentiate.\n\nFields\n\nsimulation::FI: Inversion instance.\nθ::CA: ComponentArray that contains the parameters used to differentiate the iceflow.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"ODINN.InversionParameters","text":"InversionParameters{F<:AbstractFloat}(;\n    initial_conditions::Vector{F} = [1.0],\n    lower_bound::Vector{F} = [0.0],\n    upper_bound::Vector{F} = [Inf],\n    regions_split::Vector{Int} = [1, 1],\n    x_tol::F = 1.0e-3,\n    f_tol::F = 1.0e-3,\n    solver = BFGS()\n)\n\nInitialize the parameters for the inversion process.\n\nArguments\n\ninitial_conditions::Vector{F}: Starting point for optimization.\nlower_bound::Vector{F}: Lower bounds for optimization variables.\nupper_bound::Vector{F}: Upper bounds for optimization variables.\nregions_split::Vector{Int}: Defines the amount of region split based on altitude and distance to border for the inversion process.\nx_tol::F: Tolerance for variables convergence.\nf_tol::F: Tolerance for function value convergence.\nsolver: Optimization solver to be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.InversionParameters-api","page":"API","title":"ODINN.InversionParameters","text":"InversionParameters{F<:AbstractFloat}\n\nA mutable struct that holds parameters for inversion processes. This struct is a subtype of AbstractParameters.\n\nFields\n\ninitial_conditions::Vector{F}: A vector of initial conditions.\nlower_bound::Vector{F}: A vector specifying the lower bounds for the parameters.\nupper_bound::Vector{F}: A vector specifying the upper bounds for the parameters.\nregions_split::Vector{Int}: A vector indicating how the regions are split.\nx_tol::F: The tolerance for the solution's x-values.\nf_tol::F: The tolerance for the function values.\nsolver::Any: The solver to be used for the inversion process.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.L2Sum-api","page":"API","title":"ODINN.L2Sum","text":"L2Sum{I <: Integer} <: AbstractSimpleLoss\n\nStruct that defines an L2 sum loss. The sum is defined only on pixels inside the glacier. The parameter distance controls the pixels that should be used to compute the sum. In order for a pixel to be used, it should be at least at distance from the glacier border. The mask defining the glacier borders are computed using the ground truth ice thickness.\n\nloss(ab) = sum_iintextmask (ai-bi)^2  normalization\n\nFields\n\ndistance::I: Distance to border.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.LogSum-api","page":"API","title":"ODINN.LogSum","text":"LogSum{I <: Integer, F <: AbstractFloat} <: AbstractSimpleLoss\n\nStruct that defines a Logarithmic sum loss.\n\nloss(ab) = log^2( (a + ϵ)  (b + ϵ) )  normalization\n\nFields\n\ndistance::I: Distance to border.\nϵ::F: Epsilon used inside the loss function to handle division by zero and log(0).   It somehow represents the minimum value the loss function should be sensible to.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.LossH-api","page":"API","title":"ODINN.LossH","text":"LossH{L <: AbstractSimpleLoss} <: AbstractLoss\n\nStruct that defines the ice thickness loss.\n\nFields\n\nloss::L: Type of loss to use for the ice thickness. Default is L2Sum().\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.LossHV-api","page":"API","title":"ODINN.LossHV","text":"LossHV{\n    F <: AbstractFloat,\n    LH <: AbstractLoss,\n    LV <: AbstractLoss,\n} <: AbstractLoss\n\nStruct that defines the ice thickness and ice velocity loss. It consists of two fields that define the ice thickness and ice velocity loss. It also has a scaling coefficient that balances the ice velocity term in the loss.\n\nloss(hat HH) = loss_H(hat HH) + scaling * loss_V(hat VV)\n\nwith hat V computed from hat H for the SIA.\n\nFields\n\nhLoss::LH: Type of loss to use for the ice thickness. Default is LossH().\nvLoss::LV: Type of loss to use for the ice velocity. Default is LossV().\nscaling::F: Scaling of the ice velocity term. Default is 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.LossV-api","page":"API","title":"ODINN.LossV","text":"LossV{L <: AbstractSimpleLoss} <: AbstractLoss\n\nStruct that defines the ice velocity loss.\n\nFields\n\nloss::L: Type of loss to use for the ice velocity. Default is L2Sum().\ncomponent::Symbol: Component of the velocity field used in the loss.   Options include :xy for both x and y component, and :abs for the norm/magnitude of the velocity.\nscale_loss::Bool: Whether to scale the loss function with the reference ice   velocity magnitude.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.MatrixCacheGlacierId-api","page":"API","title":"ODINN.MatrixCacheGlacierId","text":"MatrixCacheGlacierId <: Cache\n\nA cache structure for storing a matrix value (Float64 2D array) along with their associated vector-Jacobian products (VJP). It also stores the glacier ID as an integer. This is typically used to invert a spatially varying field per glacier. Fields:\n\nvalue::Array{Float64, 2}: The cached matrix value.\nvjp_inp::Array{Float64, 2}: VJP with respect to inputs.\nvjp_θ::Vector{Float64}: VJP with respect to parameters.\nglacier_id::Int64: Glacier ID in the list of simulated glaciers.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.MatrixCacheInterp-api","page":"API","title":"ODINN.MatrixCacheInterp","text":"MatrixCacheInterp(nodes_H, nodes_∇S, interp_θ)\n\nA mutable cache structure for storing interpolation data on a 2D grid, used to efficiently evaluate and reuse interpolated matrices and their gradients. This interpolation makes complex inversions feasible since it allows the precomputation of all gradients before the solving the reverse PDE associated to the adjoint variable.\n\nFields\n\nvalue::Array{Float64, 2}: Matrix to store value of the diffusivity.\nnodes_H::Vector{Float64}: Grid nodes corresponding to the first interpolation dimension, typically representing values of ice thickness H.\nnodes_∇S::Vector{Float64}: Grid nodes corresponding to the second interpolation dimension, typically representing absolute values of slope ∇S.\ninterp_θ::Interpolations.GriddedInterpolation{Vector{Float64}, 2, Matrix{Vector{Float64}}, Interpolations.Gridded{InterPolations.Linear{InterPolations.Throw{OnGrid}}}, Tuple{Vector{Float64}, Vector{Float64}}}: A gridded linear interpolation object mapping (nodes_H, nodes_∇S) to parameter vectors θ. Used to compute interpolated parameters and enable fast evaluation during repeated model calls.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.MultiLoss-api","page":"API","title":"ODINN.MultiLoss","text":"MultiLoss(; losses = (L2Sum(),), λs = (1.0,))\n\nCombines multiple loss functions into a single weighted objective.\n\nMultiLoss enables composing several individual loss terms—each possibly representing a different physical constraint, data fidelity term, or regularization penalty—into a single differentiable loss function.\n\nKeyword Arguments (Constructor)\n\nlosses::Tuple = (L2Sum(),): A tuple of loss objects (each subtype of AbstractLoss) to be combined.\nλs::Tuple = (1.0,):  A tuple of scalar weights or hyperparameters corresponding to each loss term.\n\nFields (Struct)\n\nlosses::TL: Tuple of loss functions.\nλs::TS: Tuple of weighting coefficients.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.NeuralNetwork-api","page":"API","title":"ODINN.NeuralNetwork","text":"NeuralNetwork{\n    ChainType <: Lux.Chain,\n    ComponentVectorType <: ComponentVector,\n    NamedTupleType <: NamedTuple,\n} <: FunctionalModel\n\nFeed-forward neural network.\n\nFields\n\narchitecture::ChainType: Flux.Chain neural network architecture\nθ::ComponentVectorType: Neural network parameters\nst::NamedTupleType: Neural network status\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.NoVJP-api","page":"API","title":"ODINN.NoVJP","text":"No VJP flavor when the contribution of a given term should not be computed inside the adjoint calculation (e.g. MB).\n\nNoVJP\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.PerGlacierModel-api","page":"API","title":"ODINN.PerGlacierModel","text":"PerGlacierModel <: TrainableModel\n\nAbstract type representing per glacier optimizable components of the model. This is a subtype of TrainableModel. Typically used for classical inversions.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.Results-api","page":"API","title":"ODINN.Results","text":"mutable struct Results{RES <: Sleipnir.Results, STAT <: TrainingStats}\n\nMutable struct containing the results of an inversion. This object stores both the results of the optimization through TrainingStats and the simulation results of the forward evaluations using the optimized variables through Sleipnir.Results. It expands the functionalities offered by Sleipnir.Results to allow saving the results of an inversion. Multiple dispatch is used to select either Sleipnir.Results or ODINN.Results.\n\nFields\n\nsimulation::Vector{RES}: Vector of Sleipnir.Results representing the results of a forward evaluation for each glacier.\nstats::STAT: Training statistics gathered during the optimization.\nfunction Results(       simulation::Vector{<: Sleipnir.Results},       stats::TrainingStats,   )\n\nConstructor for the Results object used to track statistics during training and the results of the forward evaluations simulated with the optimized variables.\n\nArguments\n\nsimulation::Vector{<: Sleipnir.Results}: Vector of Sleipnir.Results associated to the forward simulation of each glacier.\nstats::TrainingStats: Training statistics.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.SIA2D_D_target-api","page":"API","title":"ODINN.SIA2D_D_target","text":"SIA2D_D_target(; interpolation=:None, n_interp_half=20,\n                 prescale=nothing, postscale=nothing)\n\nInversion of general diffusivity as a function of physical parameters.\n\nD(H, ∇S, θ) = H * NN(H, ∇S; θ)\n\nSo now we are learning the velocity field given by D * ∇S. This inversion is similar to learnign the velocity field assuming that this is parallel to the gradient in surface ∇S.\n\nArguments\n\ninterpolation::Symbol = :None: Specifies the interpolation method. Options include :Linear, :None.\nn_interp_half::Int = 20: Half-width of the interpolation stencil. Determines resolution of interpolation.\nprescale::Union{Fin, Nothing} = nothing: Optional prescaling function or factor applied before parametrization. Must be of type Fin or nothing.\npostscale::Union{Fout, Nothing} = nothing: Optional postscaling function or factor applied after parametrization. Must be of type Fout or nothing.\n\nType Parameters\n\nFin: Type of the prescale function or operator.\nFout: Type of the postscale function or operator.\n\nSupertype\n\nAbstractSIA2DTarget: Inherits from the abstract target type for 2D SIA modeling.\n\nReturns\n\nAn instance of SIA2D_D_target configured with optional scaling and interpolation parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.ScalarCacheGlacierId-api","page":"API","title":"ODINN.ScalarCacheGlacierId","text":"ScalarCacheGlacierId <: Cache\n\nA cache structure for storing a scalar value as a zero-dimensional array of Float64 along with their associated vector-Jacobian products (VJP). It also stores the glacier ID as an integer. This is typically used to invert a single scalar per glacier. Fields:\n\nvalue::Array{Float64, 0}: The cached scalar value.\nvjp_inp::Array{Float64, 0}: VJP with respect to inputs. Must be defined but never used in   practice since this cache is used for classical inversions and the law does not have inputs.\nvjp_θ::Vector{Float64}: VJP with respect to parameters.\nglacier_id::Int64: Glacier ID in the list of simulated glaciers.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.SciMLSensitivityAdjoint-api","page":"API","title":"ODINN.SciMLSensitivityAdjoint","text":"Struct that defines the SciMLSensitivity adjoint flavor. This is the default behavior in ODINN.\n\nSciMLSensitivityAdjoint\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.TikhonovRegularization-api","page":"API","title":"ODINN.TikhonovRegularization","text":"TikhonovRegularization(; operator = :laplacian, distance = 3)\n\nA simple regularization type implementing Tikhonov regularization (also known as ridge regularization) for inverse problems.\n\nThis struct includes both the forward and reverse (adjoint) operators, which are required for the computation of the gradients with respect to the model parameters.\n\nKeyword Arguments (Constructor)\n\noperator::Symbol = :laplacian: The regularization operator to use. Currently, only :laplacian is implemented, which penalizes large gradients by applying the Laplacian operator.\ndistance::Integer = 3: A width parameter to determine how far from the margin evaluate the loss.\n\nFields (Struct)\n\noperator_forward::Function: The forward regularization operator (e.g., ∇²).\noperator_reverse::Function: The reverse-mode (VJP) of the operator (e.g., VJP_λ_∂∇²a_∂a).\ndistance::Integer: The distance parameter controlling the extent of regularization.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer}-api","page":"API","title":"ODINN.TrainingStats","text":"TrainingStats(;\n    retcode::Union{String, Nothing} = nothing,\n    losses::Vector{F} = Float64[],\n    niter::I = 0,\n    θ::Union{ComponentVector, Nothing} = nothing,\n    θ_hist::Union{Vector{ComponentVector}, Nothing} = ComponentVector[],\n    ∇θ_hist::Union{Vector{ComponentVector}, Nothing} = ComponentVector[]\n) where {F <: AbstractFloat, I <: Integer}\n\nConstructor for TrainingStats object used to store important information during training.\n\nArguments\n\nretcode: Report code of the optimization.\nlosses: Vector storing the value of the loss function at each iteration.\nniter: Total number of iterations/epochs.\nθ: Parameters of neural network after training\nθ_hist: History of parameters of neural network during training\n∇θ_hist: History of gradients training\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.TrainingStats-api","page":"API","title":"ODINN.TrainingStats","text":"mutable struct TrainingStats{F <: AbstractFloat, I <: Integer}\n\nAn object with the information of the training.\n\nFields\n\nretcode::Union{String, Nothing}: Report code of the optimization.\nlosses::Vector{F}: Vector storing the value of the loss function at each iteration.\nniter::I: Total number of iterations/epochs.\nθ::Union{<: ComponentVector, Nothing}: Parameters of neural network after training\nθ_hist::Vector{<: ComponentVector}: History of parameters of neural network during training\n∇θ_hist::Vector{<: ComponentVector}: History of gradients training\nlastCall::DateTime: Last time the callback diagnosis was called.   This is used to compute the time per iteration.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ<:AbstractAdjointMethod-api","page":"API","title":"ODINN.UDEparameters","text":"UDEparameters(; sensealg, optim_autoAD, grad, optimization_method, empirical_loss_function, target) where {ADJ <: AbstractAdjointMethod}\n\nCreate a UDEparameters object for configuring the sensitivity analysis and optimization of a Universal Differential Equation (UDE).\n\nKeyword Arguments\n\nsensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm: The sensitivity algorithm to use for adjoint calculations. Defaults to GaussAdjoint(autojacvec=SciMLSensitivity.EnzymeVJP()).\noptim_autoAD::AbstractADType: The automatic differentiation type for optimization. Defaults to Optimization.AutoEnzyme().\ngrad::ADJ: The adjoint gradient computation method. Defaults to ContinuousAdjoint().\noptimization_method::String: The optimization method to use. Must be either \"AD+AD\" or \"AD+Diff\". Defaults to \"AD+AD\".\nempirical_loss_function::AbstractLoss: The loss function to use for optimization. Defaults to LossH().\ntarget::Union{Symbol, Nothing}: The target variable for optimization. Defaults to :A.\n\nReturns\n\nA UDEparameters object configured with the specified sensitivity, optimization, and loss settings.\n\nDescription\n\nThis function creates a UDEparameters object that encapsulates the configuration for sensitivity analysis, optimization, and loss computation in a Universal Differential Equation (UDE) framework. It verifies that the provided optimization_method is valid and constructs the solver parameters accordingly.\n\nNotes\n\nThe optimization_method must be either \"AD+AD\" (automatic differentiation for both forward and backward passes) or \"AD+Diff\" (automatic differentiation combined with finite differences).\nThe empirical_loss_function determines how the loss is computed during optimization.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.UDEparameters-api","page":"API","title":"ODINN.UDEparameters","text":"A mutable struct that holds parameters for a UDE (Universal Differential Equation).\n\nUDEparameters{ADJ <: AbstractAdjointMethod} <: AbstractParameters\n\nFields\n\nsensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm: The sensitivity algorithm used for adjoint sensitivity analysis.\noptimization_method::String: The optimization method to be used.\ntarget::Symbol: The target variable for the optimization.\n\n\n\n\n\n","category":"type"},{"location":"api/#ODINN.VJPsPrepLaw-api","page":"API","title":"ODINN.VJPsPrepLaw","text":"struct VJPsPrepLaw <: AbstractPrepVJP\n\nA container struct that holds all objects needed to compute vector-Jacobian products (VJPs) for a law using DifferentiationInterface.\n\nFields:\n\nf_θ_first: Function to evaluate the law with parameters θ as the first argument.\nf_inp_first: Function to evaluate the law with inputs as the first argument.\nprep_θ: Precomputed gradient preparation for parameters θ.\nprep_inp: Precomputed gradient preparation for inputs.\n\nThis struct is used to prepare the VJP computation with DifferentiationInterface (DI). Depending on the AD backend, DI might require to precompile code and this struct stores the results. This allows each VJP call to be fast in the adjoint PDE by reusing the preparation results.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.copyto!-Union{Tuple{CA}, Tuple{FI}, Tuple{InversionBinder{FI, CA}, InversionBinder{FI, CA}}} where {FI<:Inversion, CA<:ComponentArrays.ComponentArray}-api","page":"API","title":"Base.copyto!","text":"Base.copyto!(\n    dest::InversionBinder{FI, CA},\n    src::InversionBinder{FI, CA},\n) where {FI <: Inversion, CA <: ComponentArray}\n\nOverload Base.copyto! as we need a way to copy the SciMLStructure. It is used in SciMLSensitivity to differentiate the callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.zero-Union{Tuple{InversionBinder{FI, CA}}, Tuple{CA}, Tuple{FI}} where {FI<:Inversion, CA<:ComponentArrays.ComponentArray}-api","page":"API","title":"Base.zero","text":"Base.zero(\n    p::InversionBinder{FI, CA},\n) where {FI <: Inversion, CA <: ComponentArray}\n\nOverload Base.zero as we need a way to copy the SciMLStructure. It is used in SciMLSensitivity to differentiate the callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.precompute_all_VJPs_laws!-Tuple{SIA2Dmodel, SIA2DCache, Inversion, Integer, Real, Any}-api","page":"API","title":"Huginn.precompute_all_VJPs_laws!","text":"precompute_all_VJPs_laws!(\n    SIA2D_model::SIA2Dmodel,\n    SIA2D_cache::SIA2DCache,\n    simulation::Inversion,\n    glacier_idx::Integer,\n    t::Real,\n    θ,\n)\n\nPrecomputes the vector-Jacobian products (VJPs) for all laws used in the SIA2D ice flow model for a given glacier, time, and model parameters.\n\nDepending on which target (U, Y, or neither) is provided in SIA2D_model, this function checks if the corresponding law supports VJP precomputation and, if so, triggers the appropriate precompute routine for that law. If neither U nor Y is provided, precomputes VJPs for the A, C, and n laws.\n\nArguments\n\nSIA2D_model::SIA2Dmodel: The model containing the configuration and   laws used for SIA2D ice flow.\nSIA2D_cache::SIA2DCache: A cache object holding intermediate values   and storage relevant for precomputations.\nsimulation::Inversion: Simulation object containing global simulation parameters.\nglacier_idx::Integer: Index of the glacier being simulated.\nt::Real: Current time in the simulation.\nθ: Model parameters or state variables for the simulation step.\n\nNotes\n\nThis routine is intended as a preparatory step for manual adjoint.\nOnly laws supporting VJP precomputation are processed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.run!-Tuple{Inversion}-api","page":"API","title":"Huginn.run!","text":"run!(simulation::Inversion)\n\nRun the training process for a given Inversion simulation.\n\nArguments\n\nsimulation::Inversion: The simulation object containing the parameters and settings for the inversion process.\n\nDescription\n\nThis function initiates the training of a Universal Differential Equation (UDE) for the provided simulation. It prints a message indicating the start of the training process, calls the train_UDE! function to perform the training, and collects the results in results_list. The results are intended to be saved using Sleipnir.save_results_file!, but this step is currently commented out and will be enabled once the optimization is working. Finally, the garbage collector is triggered to free up memory.\n\nNotes\n\nThe Sleipnir.save_results_file! function call is currently commented out and should be enabled once the optimization process is confirmed to be working.\nThe garbage collector is explicitly run using GC.gc() to manage memory usage.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.CallbackOptimizationSet-Tuple{Any, Any}-api","page":"API","title":"ODINN.CallbackOptimizationSet","text":"CallbackOptimizationSet(θ, l; callbacks)\n\nHelper to combine callbacks for Optimization function. This executes the action of each callback.   (equivalent to CallbackSet for DifferentialEquations.jl)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.ComponentVector2Vector-Tuple{ComponentArrays.ComponentVector}-api","page":"API","title":"ODINN.ComponentVector2Vector","text":"ComponentVector2Vector(cv::ComponentVector)\n\nTransform a ComponentVector into a Vector of same length. This function creates a new Vector and does not mutate the original ComponentVector.\n\nArguments:\n\ncv::ComponentVector: Input ComponentVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Diffusivity-Tuple{SIA2D_D_target}-api","page":"API","title":"ODINN.Diffusivity","text":"Diffusivity(target::SIA2D_D_target; H, ∇S, θ, iceflow_model, glacier, params)\n\nCompute the effective diffusivity field for a 2D shallow ice model using the diagnostic target and  a predicted velocity matrix U.\n\nThis function uses a learned or specified model to estimate the velocity matrix U, then calculates the diffusivity as either H .* U (if dimensions match) or the averaged H times U if dimensions differ by one grid cell (staggered grid). Errors if dimensions are incompatible.\n\nArguments\n\ntarget::SIA2D_D_target: Diagnostic target object defining interpolation and scaling rules.\n\nKeyword Arguments\n\nH: Ice thickness.\n∇S: Ice surface slope.\nθ: Parameters of the model.\niceflow_model: Iceflow model used for simulation.\nglacier: Glacier data.\nparams: Model parameters.\n\nReturns\n\nA matrix of diffusivity values with the same shape as H or staggered by one cell, depending on U.\n\nThrows\n\nAn error if the dimensions of U and H are not compatible for diffusivity calculation.\n\nNotes\n\nSupports both grid-matched and staggered configurations by averaging H where necessary.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.GaussQuadrature-Tuple{Any, Any, Int64}-api","page":"API","title":"ODINN.GaussQuadrature","text":"Gauss Quadratrue for numerical integration\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.LawA-Tuple{NeuralNetwork, Sleipnir.Parameters}-api","page":"API","title":"ODINN.LawA","text":"function LawA(\n    nn_model::NeuralNetwork,\n    params::Sleipnir.Parameters;\n    precompute_VJPs::Bool = true,\n)\n\nConstructs a law object for the creep coefficient A in the SIA based on a neural network that takes as input the long term air temperature. The creep coefficient A with this law is a scalar. See also SIA2D_A_target.\n\nArguments\n\nnn_model::NeuralNetwork: A neural network model containing the architecture   archi and state st used for evaluation of the law.\nparams::Sleipnir.Parameters: Parameters struct used to retrieve the minimum and   maximum values of A for scaling of the neural network output.\nprecompute_VJPs::Bool: If true, enables precomputation of vector-Jacobian   products before solving the adjoint PDE for efficient autodiff.\n\nReturns\n\nA_law: A Law{ScalarCache} instance that computes the creep coefficient A   based on an input temperature using the neural network. The law scales the   output to the physical bounds defined by params.\n\nNotes\n\nThe VJP is computed automatically using DifferentiationInterface.\n\nDetails\n\nThe function wraps the architecture and state of the neural network in aStatefulLuxLayer.\nThe resulting law takes input variables, applies the neural network, and scales its output   to be between params.physical.minA and params.physical.maxA.\nThe in-place assignment to cache is ignored in differentiation to allow gradient   computation with Zygote when using DifferentiationInterface.\nThe init_cache function initializes the cache with a scalar zero for the forward   placeholder, and with a vector of zeros for the VJP placeholder.\n\nExample\n\nnn_model = NeuralNetwork(params)\nA_law = LawA(nn_model, params; precompute_VJPs=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.LawA-Tuple{Sleipnir.Parameters}-api","page":"API","title":"ODINN.LawA","text":"LawA(params::Sleipnir.Parameters; scalar::Bool=true)\n\nConstruct a law that defines an ice rheology A per glacier to invert. This can be either a spatially varying A or a scalar value per glacier based on the value of scalar.\n\nArguments\n\nparams::Sleipnir.Parameters: Parameters struct used to retrieve the minimum and   maximum values of A for scaling the parameter to invert.\nscalar::Bool: Whether the ice rheology to invert is a scalar per glacier, or a   spatially varying A per glacier (matrix to invert).\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.LawU-Tuple{NeuralNetwork, Sleipnir.Parameters}-api","page":"API","title":"ODINN.LawU","text":"LawU(\n    nn_model::NeuralNetwork,\n    params::Sleipnir.Parameters;\n    max_NN::Union{F, Nothing} = 50.0,\n    prescale_bounds::Union{Vector{Tuple{F,F}}, Nothing} = [(0.0, 300.0), (0.0, 0.5)],\n) where {F <: AbstractFloat}\n\nConstructs a law object for the diffusive velocity U in the SIA based on a neural network that takes as input the ice thickness H̄ and the surface slope ∇S. The diffusive velocity U with this law is a matrix and the diffusivity in the SIA is obtained through D = U * H̄. See also SIA2D_D_target.\n\nArguments\n\nnn_model::NeuralNetwork: A neural network model containing the architecture   archi and state st used for evaluation of the law.\nparams::Sleipnir.Parameters: Parameters struct. Not used for the moment but kept   as an argument to keep consistency with other equivalent functions LawA and   LawY.\nmax_NN::Union{F, Nothing}: Expected maximum value of the neural network output.   If set to nothing, no postscaling is applied.\nprescale_bounds::Union{Vector{Tuple{F,F}}, Nothing}: Vector of tuples where each   tuple defines the lower and upper bounds of the input for scaling.   If set to nothing, no prescaling is applied.\nprecompute_interpolation::Bool: Determines which cache to use depending if interpolation   is used or not for the evaluation of gradients.\nprecompute_VJPs::Bool: Determines is VJPs are stored in the cache during the reverse   step.\n\nReturns\n\nU_law: A Law{Array{Float64, 2}} instance that computes the diffusive velocity U   based on the ice thickness H̄ and the surface slope ∇S using the neural network.   The law scales the output using the max_NN argument.\n\nNotes\n\nThe computation is compatible with Zygote for automatic differentiation.\n\nDetails\n\nThe function wraps the architecture and state of the neural network in aStatefulLuxLayer.\nThe resulting law takes input variables, applies the neural network, and scales its output   to match max_NN.\nThe in-place assignment to cache is ignored in differentiation to allow gradient   computation with Zygote.\nThe init_cache function initializes the cache with a zero matrix.\n\nExample\n\nnn_model = NeuralNetwork(params)\nbounds_H = (0.0, 300.0)\nbounds_∇S = (0.0, 0.5)\nU_law = LawU(nn_model, params; max_NN = 50.0, prescale_bounds = [bounds_H, bounds_∇S])\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.LawY-Union{Tuple{F}, Tuple{NeuralNetwork, Sleipnir.Parameters}} where F<:AbstractFloat-api","page":"API","title":"ODINN.LawY","text":"LawY(\n    nn_model::NeuralNetwork,\n    params::Sleipnir.Parameters;\n    max_NN::Union{F, Nothing} = nothing,\n    prescale_bounds::Vector{Tuple{F,F}} = [(-25.0, 0.0), (0.0, 500.0)],\n) where {F <: AbstractFloat}\n\nConstructs a law object for the hybrid diffusivity Y in the SIA based on a neural network that takes as input the long term air temperature and the ice thickness H̄. The hybrid diffusivity Y with this law is a matrix as it depends on the ice thickness. This law is used in an hybrid setting where the n exponent in the mathematical expression of the diffusivity is different from the one used to generate the ground truth. The goal of this law is to retrieve the missing part of the diffusivity. Please refer to SIA2D_D_hybrid_target for a mathematical definition.\n\nArguments\n\nnn_model::NeuralNetwork: A neural network model containing the architecture   archi and state st used for evaluation of the law.\nparams::Sleipnir.Parameters: Parameters struct used to retrieve the maximum   value of A for scaling of the neural network output.\nmax_NN::Union{F, Nothing}: Expected maximum value of the neural network output.   If not specified, the law takes as an expected maximum value params.physical.maxA.\nprescale_bounds::Vector{Tuple{F,F}}: Vector of tuples where each tuple defines   the lower and upper bounds of the input for scaling.\n\nReturns\n\nY_law: A Law{Array{Float64, 2}} instance that computes the hybrid diffusivity Y   based on an input temperature and ice thickness using the neural network. The   law scales the output to the physical bounds defined by params.\n\nNotes\n\nThe computation is compatible with Zygote for automatic differentiation.\n\nDetails\n\nThe function wraps the architecture and state of the neural network in aStatefulLuxLayer.\nThe resulting law takes input variables, applies the neural network, and scales its output   to match the maximum value which is either max_NN or params.physical.maxA.\nThe in-place assignment to cache is ignored in differentiation to allow gradient   computation with Zygote.\nThe init_cache function initializes the cache with a zero matrix.\n\nExample\n\nnn_model = NeuralNetwork(params)\nbounds_T = (-25.0, 0.0)\nbounds_H = (0.0, 500.0)\nY_law = LawY(nn_model, params; prescale_bounds = [bounds_T, bounds_H])\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.LuxFunction-Tuple{Function, Union{SubArray, Vector}}-api","page":"API","title":"ODINN.LuxFunction","text":"This function allows to extend the Wrapper layers define in Lux to matrices operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Model-Union{Tuple{}, Tuple{TAR}, Tuple{MBM}, Tuple{IFM}} where {IFM<:IceflowModel, MBM<:MBmodel, TAR<:AbstractTarget}-api","page":"API","title":"ODINN.Model","text":"Model(;\n    iceflow::Union{IFM, Nothing} = nothing,\n    mass_balance::Union{MBM, Nothing} = nothing,\n    regressors::Union{NamedTuple, Nothing} = nothing,\n    target::Union{TAR, Nothing} = nothing,\n) where {IFM <: IceflowModel, MBM <: MBmodel, TAR <: AbstractTarget}\n\nCreates a new model instance using the provided iceflow, mass balance, and machine learning components.\n\nArguments\n\niceflow::Union{IFM, Nothing}: The iceflow model to be used. Can be a single model or nothing.\nmass_balance::Union{MBM, Nothing}: The mass balance model to be used. Can be a single model or nothing.\nregressors::Union{NamedTuple, Nothing}: The regressors to be used in the laws.\n\nReturns\n\nmodel: A new instance of Sleipnir.Model initialized with the provided components.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Parameters-Tuple{}-api","page":"API","title":"ODINN.Parameters","text":"Constructor for the Parameters type. Since some of the subtypes of parameters are defined in different packages of the ODINN ecosystem, this constructor will call the constructors of the different subtypes and return a Parameters object with the corresponding subtypes.  The Parameters mutable struct is defined in Sleipnir.jl using abstract types, which are later on defined in the different packages of the ODINN ecosystem.\n\nParameters(;\n        physical::PhysicalParameters = PhysicalParameters(),\n        simulation::SimulationParameters = SimulationParameters(),\n        solver::SolverParameters = SolverParameters(),\n        hyper::Hyperparameters = Hyperparameters(),\n        UDE::UDEparameters = UDEparameters()\n        inversion::InversionParameters = InversionParameters()\n        )\n\nKeyword arguments\n\nphysical::PhysicalParameters: Physical parameters for the simulation.\nsimulation::SimulationParameters: Parameters related to the simulation setup.\nsolver::SolverParameters: Parameters for the solver configuration.\nhyper::Hyperparameters: Hyperparameters for the model.\nUDE::UDEparameters: Parameters specific to the UDE (Universal Differential Equation).\ninversion::InversionParameters: Parameters for inversion processes.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.SIA2D_UDE!-Tuple{Matrix{<:Real}, Matrix{<:Real}, InversionBinder, Real}-api","page":"API","title":"ODINN.SIA2D_UDE!","text":"Currently just used for Enzyme\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.SIA2D_grad!-Tuple{Any, Any, Inversion}-api","page":"API","title":"ODINN.SIA2D_grad!","text":"Inverse with batch\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.SIA2D_grad_batch!-Tuple{Any, Inversion}-api","page":"API","title":"ODINN.SIA2D_grad_batch!","text":"Compute gradient glacier per glacier\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.T_A_Alaw-Tuple{Simulation, Integer, Any, AbstractFloat}-api","page":"API","title":"ODINN.T_A_Alaw","text":"T_A_Alaw(simulation::Simulation, glacier_idx::Integer, θ, t::AbstractFloat)\n\nEvaluate the A law when it defines a mapping between the long term air temperature and the creep coefficient A and return both the input temperature T and the computed creep coefficient A.\n\nArguments\n\nsimulation::Simulation: The simulation object containing model data and parameters.\nglacier_idx::Integer: Index specifying which glacier to evaluate.\nθ: Model parameters to be used in the law.\nt::AbstractFloat: The time at which to evaluate the law. For this law it is useless   but in the general setting, a law needs a time t in order to retrieve the inputs.   For the sake of consistency, this input was kept.\n\nReturns\n\n(T, A): A tuple containing:\nT: The input long term air temperature for the specified glacier.\nA: The evaluated creep coefficient for the specified glacier.\n\nDetails\n\nThe function checks that the inputs of the A law are exactly as expected (long term air temperature only).\nRetrieves the long term air temperature for the specific glacier.\nEvaluates the creep coefficient using the law.\nReturns both the temperature and creep coefficient as a tuple. Since the cache of A is a zero dimensional array, it is converted to float before returning the value.\n\nExample\n\nT, A = T_A_Alaw(simulation, glacier_idx, θ, 2010.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R<:Real, SIM<:Simulation}-api","page":"API","title":"ODINN.VJP_λ_∂SIA∂H_continuous","text":"VJP_λ_∂SIA∂H_continuous(\n    λ::Matrix{R},\n    H::Matrix{R},\n    θ,\n    simulation::SIM,\n    t::R,\n) where {R <: Real, SIM <: Simulation}\n\nImplementation of the continuous VJP of the SIA2D equation with respect to H. Given λ and H, it returns the VJP of λ^T * ∂(SIA2D)/∂H (H).\n\nArguments:\n\nλ::Matrix{R}: Adjoint state, also called output gradient in reverse-mode AD.\nH::Matrix{R}: Ice thickness which corresponds to the input state of the SIA2D.\nsimulation::SIM: Simulation parameters.\nt::R: Time value, not used as SIA2D is time independent.\n\nReturns:\n\ndλ::Matrix{R}: Jacobian vector product, also called input gradient in reverse-mode AD.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.VJP_λ_∂SIA∂H_discrete-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R<:Real, SIM<:Simulation}-api","page":"API","title":"ODINN.VJP_λ_∂SIA∂H_discrete","text":"VJP_λ_∂SIA∂H_discrete(\n    λ::Matrix{R},\n    H::Matrix{R},\n    θ,\n    simulation::SIM,\n    t::R,\n) where {R <:Real, SIM <: Simulation}\n\nImplementation of the discrete VJP of the SIA2D equation with respect to H. Given λ and H, it returns the VJP of λ^T * ∂(SIA2D)/∂H (H).\n\nArguments:\n\nλ::Matrix{R}: Adjoint state, also called output gradient in reverse-mode AD.\nH::Matrix{R}: Ice thickness which corresponds to the input state of the SIA2D.\nsimulation::SIM: Simulation parameters.\nt::R: Time value, not used as SIA2D is time independent.\n\nReturns:\n\ndλ::Matrix{R}: Jacobian vector product, also called input gradient in reverse-mode AD.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R<:Real, SIM<:Simulation}-api","page":"API","title":"ODINN.VJP_λ_∂SIA∂θ_continuous","text":"VJP_λ_∂SIA∂θ_continuous(\n    λ::Matrix{R},\n    H::Matrix{R},\n    θ,\n    simulation::SIM,\n    t::R,\n) where {R <: Real, SIM <: Simulation}\n\nImplementation of the continuous VJP of the SIA2D equation with respect to θ. Given λ, H and θ, it returns the VJP of λ^T * ∂(SIA2D)/∂θ (θ).\n\nArguments:\n\nθ: Vector of parameters\nλ::Matrix{R}: Adjoint state, also called output gradient in reverse-mode AD.\nH::Matrix{R}: Ice thickness which corresponds to the input state of the SIA2D.\nsimulation::SIM: Simulation parameters.\nt::R: Time value, not used as SIA2D is time independent.\n\nReturns:\n\n∂θ: Jacobian vector product with respect to θ, also called input gradient in   reverse-mode AD. It has the same type as θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.VJP_λ_∂SIA∂θ_discrete-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R<:Real, SIM<:Simulation}-api","page":"API","title":"ODINN.VJP_λ_∂SIA∂θ_discrete","text":"VJP_λ_∂SIA∂θ_discrete(\n    λ::Matrix{R},\n    H::Matrix{R},\n    θ,\n    simulation::SIM,\n    t::R,\n) where {R <: Real, SIM <: Simulation}\n\nImplementation of the discrete VJP of the SIA2D equation with respect to θ. Given λ, H and θ, it returns the VJP of λ^T * ∂(SIA2D)/∂θ (θ).\n\nArguments:\n\nθ: Vector of parameters\nλ::Matrix{R}: Adjoint state, also called output gradient in reverse-mode AD.\nH::Matrix{R}: Ice thickness which corresponds to the input state of the SIA2D.\nsimulation::SIM: Simulation parameters.\nt::R: Time value, not used as SIA2D is time independent.\n\nReturns:\n\n∂θ: Jacobian vector product with respect to θ, also called input gradient in   reverse-mode AD. It has the same type as θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.VJP_λ_∂∇²a_∂a-Union{Tuple{R}, Tuple{Matrix{R}, Matrix{R}, R, R}} where R<:Real-api","page":"API","title":"ODINN.VJP_λ_∂∇²a_∂a","text":"VJP_λ_∂∇²a_∂a(λ::Matrix{R}, a::Matrix{R}, Δx::R, Δy::R) where {R<:Real}\n\nComputes the vector-Jacobian product (VJP) of the Laplacian operator ∇² with respect to its input field a. This function effectively propagates sensitivities (adjoints) λ backward through the Laplacian, as required in adjoint or reverse-mode differentiation.\n\nArguments\n\nλ::Matrix{R}: Adjoint field associated with the Laplacian output.\na::Matrix{R}: Input scalar field to the Laplacian operator.\nΔx::R: Grid spacing in the x-direction.\nΔy::R: Grid spacing in the y-direction.\n\nReturns\n\nMatrix{R}: The adjoint (VJP) with respect to a, i.e. ∂⟨λ, ∇²a⟩/∂a.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Vector2ComponentVector-Tuple{Vector, ComponentArrays.ComponentVector}-api","page":"API","title":"ODINN.Vector2ComponentVector","text":"Vector2ComponentVector(v::Vector, cv_template::ComponentVector)\n\nTransform a vector v to a ComponentVector that has the same structure as cv_template. This function creates a new ComponentVector and copies the values of v explicitly. The arguments v and cv_template must be of the same length.\n\nArguments:\n\nv::Vector: Vector whose values are copied.\ncv_template::ComponentVector: ComponentVector whose structure is used to create a new ComponentVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.Velocityꜛ-Tuple{SIA2D_D_target}-api","page":"API","title":"ODINN.Velocityꜛ","text":"Function to evaluate derivatives of ice surface velocity in D inversion.\n\nTODO: This functions right now just make a call to the regular functions used for the calculation of the adjoint. This is not correct, but we keep it as this for now until we figure out how to do this in the case of the D inversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN._batch_iceflow_UDE-Tuple{InversionBinder, Integer, SciMLBase.ODEProblem}-api","page":"API","title":"ODINN._batch_iceflow_UDE","text":"_batch_iceflow_UDE(\n    container::InversionBinder,\n    glacier_idx::Integer,\n    iceflow_prob::ODEProblem,\n)\n\nDefine the callbacks to be called by the ODE solver, solve the ODE and create the results.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN._ml_model_postscale-Tuple{Union{SubArray, Vector}, Any}-api","page":"API","title":"ODINN._ml_model_postscale","text":"_ml_model_postscale(\n    Y::Vector,\n    max_NN,\n)\n\nApplies an exponential transformation to each element in Y, then rescales the result by multiplying with max_NN. For each element, the transformation is: max_NN * exp((Y - 1.0) / Y)\n\nArguments\n\nY::Vector: Values to be post-processed.\nmax_NN: Scalar representing the maximum value for rescaling.\n\nReturns\n\nThe rescaled values after applying the exponential transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN._ml_model_prescale-Union{Tuple{F}, Tuple{Vector, Array{Tuple{F, F}, 1}}} where F<:AbstractFloat-api","page":"API","title":"ODINN._ml_model_prescale","text":"_ml_model_prescale(\n    X::Vector,\n    prescale_bounds::Vector{Tuple{F, F}},\n) where {F <: AbstractFloat}\n\nScales each element of the input vector X using the corresponding bounds from prescale_bounds. For each index i, X[i] is normalized based on the interval specified in prescale_bounds[i] using the normalize function. This function is typically used to ensure that the scales of the inputs of a neural network are comparable to each other.\n\nArguments\n\nX::Vector: A vector of input values to be normalized.\nprescale_bounds::Vector{Tuple{F, F}}: A vector of tuples specifying the lower and upper bounds   for normalization of each corresponding element in X.\n\nReturns\n\nA vector where each element is the normalized value of the corresponding input, using the   specified bounds.\n\nNotes\n\nThe length of X and prescale_bounds must be equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN._pred_NN-Union{Tuple{F}, Tuple{Vector{F}, Vararg{Any, 4}}} where F<:AbstractFloat-api","page":"API","title":"ODINN._pred_NN","text":"_pred_NN(inp::Vector{F}, smodel, θ, prescale, postscale) where {F <: AbstractFloat}\n\nCompute the output of a neural network model on the input vector inp.\n\nArguments\n\ninp::Vector{F}: Input vector of floats.\nsmodel: The neural network model.\nθ: Parameters for the neural network model.\nprescale: Function to scale the input vector before passing it to the model.\npostscale: Function to scale the model output.\n\nReturns\n\nThe single (scalar) output value from the neural network after applying prescale   to the input, evaluating the model, and then applying postscale. The result is   extracted via only.\n\nNotes\n\nThe function assumes that the neural network, when evaluated, returns an iterable with exactly one element.\nUsing only will throw an error if the output is not exactly one element.\n\nExample\n\nmymodel = StatefulLuxLayer{true}(archi, nothing, st)\ny = _pred_NN([1.0, 2.0], mymodel, θ, prescale_fn, postscale_fn)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.aggregate∇θ-Tuple{Vector{<:ComponentArrays.ComponentArray}, Any, ODINN.MachineLearning}-api","page":"API","title":"ODINN.aggregate∇θ","text":"aggregate∇θ(∇θ::Vector{<: ComponentArray}, θ, ml::MachineLearning)\n\nAggregate the vector of gradients ∇θ as a single ComponentArray. The argument ∇θ is the vector of all the gradients computed for each glacier. This function aggregates them based on the optimizable components of ml.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.backward_loss-Union{Tuple{F}, Tuple{MultiLoss, Matrix{F}, Any, Any, Any, Any, F, Integer, Any, Any, F, Any}} where F<:AbstractFloat-api","page":"API","title":"ODINN.backward_loss","text":"backward_loss(\n    lossType::MultiLoss,\n    H_pred::Matrix{F},\n    H_ref,\n    V_ref, Vx_ref, Vy_ref,\n    t::F,\n    glacier_idx::Integer,\n    θ,\n    simulation,\n    normalization::F,\n    Δt,\n) where {F <: AbstractFloat}\n\nComputes the gradient of a composite loss defined by a MultiLoss object with respect to both the predicted field H_pred and model parameters θ.\n\nEach sub-loss's backward gradient is weighted by its corresponding coefficient in lossType.λs and summed to form the total gradient.\n\nArguments\n\nlossType::MultiLoss: Composite loss object containing individual losses and weights.\nH_pred::Matrix{F}: Predicted ice thickness.\nH_ref::Matrix{F}: Reference ice thickness.\nt::F: Current time or simulation step.\nglacier_idx::Integer: Glacier id in the list of glaciers in simulation.\nθ: Model parameters used in the simulation.\nsimulation: Simulation object providing necessary context for gradient computation.\nnormalization::F: Normalization factor applied within each individual loss.\nΔt: Named tuple containing the time step to use for the approximation of continuous in time loss terms.   For example if LossH is used, there must be a term Δt.H containing the time step since the last   computation of the ice thickness loss term. If the current time t where the loss is evaluated does not   correspond to a time step of the LossH term, then the value of Δt.H has no impact.\n\nReturns\n\n(∂L∂H, ∂L∂θ): Tuple containing:\n∂L∂H::Matrix{F}: Gradient of the composite loss with respect to H_pred.\n∂L∂θ: Gradient of the composite loss with respect to model parameters θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.batch_loss_iceflow_transient-Tuple{InversionBinder, Integer, SciMLBase.ODEProblem}-api","page":"API","title":"ODINN.batch_loss_iceflow_transient","text":"batch_loss_iceflow_transient(\n    container::InversionBinder,\n    glacier_idx::Integer,\n    iceflow_prob::ODEProblem,\n)\n\nSolve the ODE, retrieve the results and compute the loss.\n\nArguments:\n\ncontainer::InversionBinder: SciMLStruct that contains the simulation structure and the vector of parameters to optimize.\nglacier_idx::Integer: Index of the glacier.\niceflow_prob::ODEProblem: Iceflow problem defined as an ODE with respect to time.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.callback_diagnosis-Tuple{Any, Any, Any}-api","page":"API","title":"ODINN.callback_diagnosis","text":"callback_diagnosis(θ, l, simulation; save::Bool = false, tbLogger::Union{<: TBLogger, Nothing} = nothing)\n\nCallback function to track and diagose training. It includes print and updates in simulation::Simulation. It also logs training statistics with tensorboard if tbLogger is provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.callback_plots_A-Tuple{Any, Any, Any}-api","page":"API","title":"ODINN.callback_plots_A","text":"callback_plots_A(θ, l, simulation)\n\nCallback function to generate plots during training.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.cap_D-Tuple{Any}-api","page":"API","title":"ODINN.cap_D","text":"Normalization of D to cap at a maximum physical value\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.create_interpolation-Union{Tuple{Matrix}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"ODINN.create_interpolation","text":"create_interpolation(A::Matrix; n_interp_half::Int) -> Vector{Float64}\n\nConstruct a one-dimensional interpolation grid from the elements of a matrix A by flattening it and delegating to create_interpolation(::Vector). This is a  convenience method that allows users to pass a 2D array to the function create_interpolation(A::Vector) directly without manually reshaping it.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.create_interpolation-Union{Tuple{Vector}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"ODINN.create_interpolation","text":"create_interpolation(\n    A::Vector;\n    n_interp_half::Int,\n    dilation_factor = 1.0,\n    minA_unif::Union{F, Nothing} = nothing,\n    minA_quantile::Union{F, Nothing} = nothing,\n    maxA_unif::Union{F, Nothing} = nothing,\n    maxA_quantile::Union{F, Nothing} = nothing\n    ) where {F <: AbstractFloat}\n\nConstruct a one-dimensional interpolation grid from the data in A, combining uniformly spaced and quantile-based sampling points.\n\nThis hybrid interpolation grid provides both coverage of the entire range of values and higher resolution in regions where A has dense data, making it useful for interpolation or machine learning applications that need balanced sampling.\n\nArguments\n\nA::Vector: Input data vector (typically containing positive values).\nn_interp_half::Int: Number of points used for both the uniform and quantile-based subsets of the interpolation grid.\ndilation_factor::Real = 1.0: Optional multiplier applied to maximum(A) to slightly extend the grid beyond the data range (useful to avoid extrapolation issues).\nminA_unif::Union{F, Nothing} = nothing: Minimum value used for the uniform interpolation\nminA_quantile::Union{F, Nothing} = nothing: Maximum value used for the uniform interpolation\nmaxA_unif::Union{F, Nothing} = nothing: Minimum value used for the quantile interpolation\nmaxA_quantile::Union{F, Nothing} = nothing: Maximum value used for the quantile interpolation\n\nReturns\n\nA sorted, unique vector of interpolation nodes combining:\n\nn_interp_half uniformly spaced values between 0 and dilation_factor * maximum(A)\nn_interp_half quantile-based values computed from the positive entries of A\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.create_results-Tuple{Any, Inversion, Any}-api","page":"API","title":"ODINN.create_results","text":"create_results(θ, simulation::Inversion, mappingFct)\n\nGiven the parameters θ, solve the iceflow problem for all the glaciers and aggregate the results for all of them. This function is typically used at the end of a training once θ has been optimized and one wants to run one last forward simulation in order to retrieve statistics about each of the iceflow problems.\n\nArguments:\n\nθ: Parameters to use for the forward simulation.\nsimulation::Inversion: Simulation structure that contains all the required information about the inversion.\nmappingFct: Function to use to process the glaciers. Either map for a sequential processing or pmap for multiprocessing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.define_iceflow_prob-Tuple{Any, Inversion, Integer}-api","page":"API","title":"ODINN.define_iceflow_prob","text":"define_iceflow_prob(\n    simulation::Inversion,\n    glacier_idx::Integer,\n)\n\nGiven a simulation struct and a glacier_idx, build the iceflow problem that has to be solved in the ODE solver. In practice, the returned iceflow problem is used inside simulate_iceflow_UDE! through remake. The definition of the iceflow problem has to be done outside of the gradient computation, otherwise Zygote fails at differentiating it.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}-api","page":"API","title":"ODINN.enable_multiprocessing","text":"enable_multiprocessing(params::Sleipnir.Parameters) -> Int\n\nConfigures and enables multiprocessing based on the provided simulation parameters.\n\nArguments\n\nparams::Sleipnir.Parameters: A parameter object containing simulation settings, including the number of workers (params.simulation.workers) and whether multiprocessing is enabled (params.simulation.multiprocessing).\n\nBehavior\n\nIf multiprocessing is enabled (params.simulation.multiprocessing == true) and the specified number of workers (params.simulation.workers) is greater than 0:\nAdds the required number of worker processes if the current number of processes (nprocs()) is less than the specified number of workers.\nSuppresses precompilation output on the worker processes and ensures the ODINN module is loaded on all workers.\nIf the specified number of workers is 1, removes all worker processes.\n\nReturns\n\nThe number of worker processes (nworkers()) after configuration.\n\nNotes\n\nThis function uses @eval to dynamically add or remove worker processes.\nPrecompilation output is suppressed on workers to reduce noise in the console.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.eval_law-Tuple{AbstractLaw, Simulation, Integer, NamedTuple, Any}-api","page":"API","title":"ODINN.eval_law","text":"eval_law(law::AbstractLaw, simulation::Simulation, glacier_idx::Integer, inputs::NamedTuple, θ)\n\nEvaluates a law on the specified glacier within a simulation context and for a user defined input.\n\nArguments\n\nlaw::AbstractLaw: The law object to be evaluated. Must provide a function f and an init_cache method.\nsimulation::Simulation: The simulation context, containing model parameters and machine learning components.\nglacier_idx::Integer: Index identifying which glacier in the simulation to evaluate the law for.\ninput_values::NamedTuple: Input data required by the law and provided by the user.\nθ: Weights used in the law to make inference. This can be nothing when the law has no parameter.\n\nReturns\n\nThe updated cache after evaluating the law. The cache contains the result of the law's computation for the specified glacier and inputs.\n\nDetails\n\nThe function initializes a cache for the law using init_cache.\nIf the simulation has a machine learning model, the model's parameters (θ) are updated in-place with the provided θ.\nThe law's function is then called with the cache, inputs, and parameters. The result is stored in the cache and the cache is returned.\nIn future versions, the design may change so that only inputs and θ are needed, with the cache handled separately so that no simulation is required.\n\nExample\n\nresult = eval_law(simulation.model.iceflow.A, simulation, glacier_idx, (; T=273.15), θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.evaluate_H₀-Tuple{ComponentArrays.ComponentArray, Glacier2D, Symbol, Integer}-api","page":"API","title":"ODINN.evaluate_H₀","text":"evaluate_H₀(\n    θ::ComponentArray,\n    glacier::Glacier2D,\n    filter::Symbol,\n    glacier_id::Integer,\n)\n\nEvaluate the initial ice thickness H₀ for a given glacier, optionally applying a smooth thresholding function.\n\nArguments\n\nθ::ComponentArray: A ComponentArray containing glacier parameters.\nglacier::Glacier2D: Glacier for which to evaluate H₀.\nfilter::Symbol: Specifies the smoothing function to apply to the raw initial condition:\n:identity: applies the identity function (no change).\n:softplus: applies the softplus function log(1 + exp(x)) to ensure positivity.\n:Zang1980: applies the σ_zang function (Zang 1980) as a smooth positivity threshold.\nglacier_id::Integer: Index of the glacier in order to retrieve the parameters of the IC in θ.\n\nReturns\n\nA numeric value or array representing the filtered initial ice thickness for the specified glacier.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.evaluate_∂H₀-Tuple{ComponentArrays.ComponentArray, Glacier2D, Symbol, Integer}-api","page":"API","title":"ODINN.evaluate_∂H₀","text":"evaluate_∂H₀(\n    θ::ComponentArray,\n    glacier::Glacier2D,\n    filter::Symbol,\n    glacier_id::Integer,\n)\n\nEvaluate the derivative of the initial ice thickness H₀ for a given glacier, optionally applying a smooth thresholding function.\n\nArguments\n\nθ::ComponentArray: A ComponentArray containing glacier parameters.\nglacier::Glacier2D: Glacier for which to evaluate ∂H₀.\nfilter::Symbol: Specifies the smoothing function to apply to the raw initial condition:\n:identity: applies the identity function (no change).\n:softplus — applies the softplus function log(1 + exp(x)) to ensure positivity.\n:Zang1980 — applies the σ_zang function (Zang 1980) as a smooth positivity threshold.\nglacier_id::Integer: Index of the glacier in order to retrieve the parameters of the IC in θ.\n\nReturns\n\nA numeric value or array representing the filtered initial ice thickness for the specified glacier.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.feed_input_cache!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Any, Any}-api","page":"API","title":"ODINN.feed_input_cache!","text":"feed_input_cache!(\n    SIA2D_model::SIA2Dmodel,\n    SIA2D_cache::SIA2DCache,\n    simulation,\n    glacier_idx::Integer,\n    θ,\n    result\n)\n\nPopulate the input cache of an SIA2DCache instance with interpolation nodes for ice thickness (H) and surface slope (∇S), based on the results of a previous forward simulation. This function is required just when results of the forward pass are required to evaluate the elements of the cache in the reverse step.\n\nThis function prepares the interpolation knots used later by the reverse evaluation of the adjoint SIA2D model.\n\nRight now, this function is just required for the inversion w.r.t to D, which is indicated by the boolean variable SIA2D_model.U_is_provided. Other inversions may not required the definition of this function.\n\nArguments\n\nSIA2D_model::SIA2Dmodel: The 2D shallow-ice approximation model instance.\nSIA2D_cache::SIA2DCache: The cache object that stores precomputed interpolation nodes.\nsimulation: The simulation object containing glacier configurations and model settings.\nglacier_idx::Integer: Index of the glacier within simulation.glaciers for which the cache is being populated.\nθ: Model parameters (not directly used in this function but included for interface consistency).\nresult: Output of a previous forward run containing ice thickness fields H.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.fourier_feature-api","page":"API","title":"ODINN.fourier_feature","text":"fourier_feature(v, n::Integer=10, random=false, σ=5.0)\n\nGenerates a Fourier feature embedding of a vector v, optionally using randomized projections.\n\nArguments\n\nv: Input vector to be transformed (typically a coordinate or feature vector).\nn::Integer=10: Number of Fourier features to generate (default is 10).\nrandom::Bool=false: Whether to use random Fourier features (default is false).\nσ::Float64=5.0: Standard deviation of the normal distribution used for random feature projection (only used if random=true).\n\nReturns\n\nA 2n-dimensional vector consisting of sine and cosine features of the transformed input vector.\n\nNotes\n\nFourier features help to overcome spectral bias in neural networks and can further help to learn higher frequncy components of the function faster. For more information, see Tancik et. al (2020), \"Fourier Features Let Networks Learn High Frequency Functions in Low Dimensional Domains\".\n\nExample\n\nv = [0.5, 1.0]\nfeatures = fourier_feature(v, n=4, random=true, σ=2.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#ODINN.generate_batches-Tuple{S} where S<:Simulation-api","page":"API","title":"ODINN.generate_batches","text":"generate_batches(simulation::S; shuffle=false) where {S <: Simulation}\n\nGenerate a data loader for batching simulations, optionally shuffling the batches.\n\nArguments\n\nsimulation::S: A Simulation object (or subtype of Simulation) containing the data to be batched.\nshuffle::Bool=false: A flag indicating whether to shuffle the batches. Defaults to false.\n\nReturns\n\nA DataLoader object that provides batched access to the simulation data.\n\nDescription\n\nThis function creates a DataLoader for batching the provided simulation object. The DataLoader allows for efficient iteration over the simulation data in batches. The batch size is set to 1 by default, and the shuffle flag determines whether the batches are shuffled. If shuffle is enabled, a warning is logged to indicate that the batches used for parallelization are being shuffled.\n\nNotes\n\nThe batch size is fixed at 1 in this implementation. To modify the batch size, you may need to adjust the DataLoader initialization.\nShuffling the batches may affect reproducibility and parallelization behavior.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.generate_simulation_batches-Tuple{Inversion}-api","page":"API","title":"ODINN.generate_simulation_batches","text":"generate_simulation_batches(simulation::Inversion)\n\nGenerate batches of simulations from a Inversion object for parallel or batched processing.\n\nArguments\n\nsimulation::Inversion: A Inversion object containing the model, glaciers, parameters, results, and statistics for the simulation.\n\nReturns\n\nA vector of Inversion objects, each representing a batch of simulations. Each batch contains a subset of glaciers, models, and results from the original simulation.\n\nDescription\n\nThis function splits the glaciers and associated data in the simulation object into smaller batches for processing. Each batch is represented as a new Inversion object. The number of batches is determined by the nbatches variable (currently set to 1). If the simulation results are empty, the function creates batches with empty results. Otherwise, it includes the corresponding results for each glacier in the batches.\n\nNotes\n\nThe number of glaciers (ninstances) must be divisible by the number of batches (nbatches). An assertion is used to enforce this condition.\nThe function currently defaults to nbatches = 1, meaning no actual batching is performed. This can be updated to use simulation.parameters.hyper.batchsize for dynamic batching.\nIf the simulation results are empty, the function creates batches with empty results objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.get_default_NN-Tuple{Any, Any}-api","page":"API","title":"ODINN.get_default_NN","text":"get_NN(θ_trained, ft; lightNN=false)\n\nGenerates a neural network.\n\nArguments\n\nθ_trained: Pre-trained neural network parameters (optional).\nft: Float type used.\nlightNN: Boolean that determines if a light architecture is returned or not.\n\nReturns\n\nUA: Lux.Chain neural network architecture.\nθ: Neural network parameters.\nst: Lux state.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.grad_loss_iceflow!-Tuple{Any, Any, Inversion, Any}-api","page":"API","title":"ODINN.grad_loss_iceflow!","text":"grad_loss_iceflow!(dθ, θ, simulation::Inversion, mappingFct)\n\nCompute the gradient with respect to θ for all the glaciers and assign the result in-place to dθ.\n\nArguments:\n\ndθ: Gradient of the parameters where the computed gradient should be stored.\nθ: Parameters to differentiate.\nsimulation::Inversion: Simulation structure that contains all the required information about the inversion.\nmappingFct: Function to use to process the glaciers. Either map for a sequential processing or pmap for multiprocessing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.grad_loss_iceflow!-Tuple{Any, Inversion, Any}-api","page":"API","title":"ODINN.grad_loss_iceflow!","text":"grad_loss_iceflow!(θ, simulation::Inversion, mappingFct)\n\nCompute the gradient with respect to θ for all the glaciers and return the result out-of-place. See the in-place implementation for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.grad_parallel_loss_iceflow!-Tuple{Any, Inversion, Integer}-api","page":"API","title":"ODINN.grad_parallel_loss_iceflow!","text":"grad_parallel_loss_iceflow!(θ, simulation::Inversion, glacier_idx::Integer)\n\nCompute the gradient with respect to θ for a particular glacier and return the computed gradient. This function defines the iceflow problem and then calls Zygote to differentiate batch_loss_iceflow_transient with respect to θ. It uses the SciMLSensitivity implementation under the hood to compute the adjoint of the ODE.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.loss-Union{Tuple{F}, Tuple{LogSum, Matrix{F}, Matrix{F}, BitMatrix, F}} where F<:AbstractFloat-api","page":"API","title":"ODINN.loss","text":"function loss(\n    lossType::LogSum,\n    a::Matrix{F},\n    b::Matrix{F},\n    mask::BitMatrix,\n    normalization::F,\n) where {F <: AbstractFloat}\n\nCompute logarithmic loss function for ice velocity fields following Morlighem, M. et al., \"Spatial patterns of basal drag inferred using control methods from a full-Stokes and simpler models for Pine Island Glacier, West Antarctica\". Geophys. Res. Lett. 37, (2010). Given a minimum velocity ϵ the absolute velocity given by a and b, it computes the sum of\n\nlog^2( (a + ϵ) / (b + ϵ) )\n\nIt has been shown that this loss function enables robust estimation of drag coefficient.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.loss-Union{Tuple{F}, Tuple{MultiLoss, Matrix{F}, Any, Any, Any, Any, F, Integer, Any, Any, F, Any}} where F<:AbstractFloat-api","page":"API","title":"ODINN.loss","text":"loss(\n    lossType::MultiLoss,\n    H_pred::Matrix{F},\n    H_ref,\n    V_ref, Vx_ref, Vy_ref,\n    t::F,\n    glacier_idx::Integer,\n    θ,\n    simulation,\n    normalization::F,\n    Δt,\n) where {F <: AbstractFloat}\n\nComputes the weighted composite loss for a prediction H_pred against a reference H_ref using a MultiLoss object.\n\nEach individual loss in lossType.losses is evaluated and multiplied by its corresponding weight in lossType.λs. The final loss is the sum of these weighted contributions.\n\nArguments\n\nlossType::MultiLoss: Composite loss object containing individual losses and weights.\nH_pred::Matrix{F}: Predicted ice thickness.\nH_ref::Matrix{F}: Reference ice thickness.\nt::F: Current time or simulation step.\nglacier_idx::Integer: Glacier id in the list of glaciers in simulation.\nθ: Model parameters used in the simulation.\nsimulation: Simulation object providing necessary context for loss evaluation.\nnormalization::F: Normalization factor applied within each individual loss.\nΔt: Named tuple containing the time step to use for the approximation of continuous in time loss terms.   For example if LossH is used, there must be a term Δt.H containing the time step since the last   computation of the ice thickness loss term. If the current time t where the loss is evaluated does not   correspond to a time step of the LossH term, then the value of Δt.H has no impact.\n\nReturns\n\nF: The total scalar loss, computed as the sum of weighted individual losses.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.loss_iceflow_transient-Tuple{Any, Inversion, Any}-api","page":"API","title":"ODINN.loss_iceflow_transient","text":"loss_iceflow_transient(θ, simulation::Inversion, mappingFct)\n\nGiven the parameters θ, this function:\n\nSolves the iceflow problem for all the glaciers.\nComputes the loss function defined as the sum of the loss functions for each of the glaciers.  The loss function of each glacier depends on the type of loss. Refer to empirical_loss_function in  the UDE parameters for more information. The loss function is transient meaning that the state of the  glacier is compared to a reference at different time steps over the simulated period.\nReturn the value of the loss function.\n\nArguments:\n\nθ: Parameters to use for the forward simulation.\nsimulation::Inversion: Simulation structure that contains all the required information about the inversion.\nmappingFct: Function to use to process the glaciers. Either map for a sequential processing or pmap for multiprocessing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.merge_batches-Tuple{Vector}-api","page":"API","title":"ODINN.merge_batches","text":"merge_batches(results::Vector)\n\nMerge simulation results from multiple batches into a single collection.\n\nArguments\n\nresults::Vector: A vector where each element is a collection of results (e.g., arrays or vectors) from a batch.\n\nReturns\n\nA single collection containing all the merged results from the input batches.\n\nDescription\n\nThis function takes a vector of results from multiple simulation batches and merges them into a single collection using vertical concatenation (vcat). It is useful for combining results that were processed in parallel or in separate batches.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.normalize-Union{Tuple{Any}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"ODINN.normalize","text":"normalize(X; lims::Tuple{F, F}; method = :shift) where {F <: AbstractFloat}\n\nNormalize a variable by using an affine transformation defined by some input lower and upper bounds (m, M) and transforming to O(1) scale.\n\nArguments\n\nX: Input value.\nlims::Tuple{F, F}: Lower and upper bounds to use in the affine transformation.\nmethod::Symbol: Method to scale data.\n\nReturns\n\nThe input variable scaled by the affine transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.parallel_loss_iceflow_transient-Tuple{Any, Inversion}-api","page":"API","title":"ODINN.parallel_loss_iceflow_transient","text":"parallel_loss_iceflow_transient(θ, simulation::Inversion)\n\nLoop over a list of glaciers to process. When multiprocessing is enabled, each call of this function has a dedicated process. This function calls batch_loss_iceflow_transient which returns both the loss and the result structure. The function keeps only the loss.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.pretraining-Tuple{Lux.Chain}-api","page":"API","title":"ODINN.pretraining","text":"pretraining(architecture::Lux.Chain;\n            X::Matrix,\n            Y::Matrix,\n            nepochs::Int=3000,\n            lossfn::GenericLossFunction=MSLELoss(; agg=mean, epsilon=1e-10),\n            rng::AbstractRNG=Random.default_rng())\n\nPretrains a neural network model using a input and output.\n\nArguments\n\narchitecture::Lux.Chain: The neural network architecture to be trained.\nX::Matrix: Input feature matrix where each column is a feature vector.\nY::Matrix: Target output matrix corresponding to the inputs in X.\nnepochs::Int=3000: Number of training epochs (default is 3000).\nlossfn::GenericLossFunction=MSLELoss(...): Loss function used for training. Defaults to Mean Squared Logarithmic Error.\nrng::AbstractRNG=Random.default_rng(): Random number generator used for parameter initialization.\n\nReturns\n\narchitecture: The trained neural network architecture.\nθ_pretrain: Trained parameters of the neural network.\nst_pretrain: Internal states of the trained model.\n\nNotes\n\nPretrainign helps to reduce the number of total epochs required to train the UDE by selecting a physical meaningful initialization for the model. The function initializes the model parameters and states using Lux.setup, then performs training using a custom train_model! function with ADAM optimizer. Loss values are printed every 100 epochs during training.\n\nExample\n\nusing Lux, Random\narch = Chain(Dense(10 => 20, relu), Dense(20 => 1))\nX = rand(10, 100)\nY = rand(1, 100)\nmodel, params, state = pretraining(arch; X=X, Y=Y)\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.printProgressLoss-NTuple{4, Any}-api","page":"API","title":"ODINN.printProgressLoss","text":"printProgressLoss(iter, total_iters, loss, improvement)\n\nPrint function to track training.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.random_matrix-Tuple{Any, Any, Any}-api","page":"API","title":"ODINN.random_matrix","text":"random_matrix(mean, std, corr_length)\n\nGenerate a random matrix with entries drawn from a multivariate normal distribution whose mean is given by mean and whose covariance decays exponentially with grid distance.\n\nArguments\n\nmean::AbstractMatrix{<:Real}: Matrix specifying the spatial mean values at each grid point.   Entries equal to 0.0 are treated as inactive and skipped in sampling.\nstd::Real: Standard deviation scaling factor for the covariance kernel.\ncorr_length::Real: Correlation length parameter controlling how fast correlations   decay with Euclidean distance between grid points.\n\nReturns\n\nH_sample::Matrix{Float64}: A random realization of the same size as mean, with correlated entries    drawn from MvNormal(mean, Σ), where   Σ[i,j] = std * exp(-‖coords[i] - coords[j]‖ / corr_length).\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.safe_slice-Tuple{Any, Integer}-api","page":"API","title":"ODINN.safe_slice","text":"safe_slice(obj, ind::Integer)\n\nReturn a sliced object obj if ind > 0, otherwise return 0.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.save_inversion_file!-Union{Tuple{SIM}, Tuple{Any, SIM}} where SIM<:Simulation-api","page":"API","title":"ODINN.save_inversion_file!","text":"This function saves the results of an inversion to a file in JLD2 format. If the path argument is not provided, the function will create a default path based on the current project directory. The results are saved in a file named prediction_<nglaciers>glaciers_<tspan>.jld2, where <nglaciers> is the number of glaciers in the simulation and <tspan> is the simulation time span.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.simulate_iceflow_UDE!-Tuple{InversionBinder, SciMLBase.DECallback, SciMLBase.ODEProblem, Any}-api","page":"API","title":"ODINN.simulate_iceflow_UDE!","text":"simulate_iceflow_UDE!(\n    container::InversionBinder,\n    cb::SciMLBase.DECallback,\n    iceflow_prob::ODEProblem,\n    tstops,\n)\n\nMake a forward simulation of the iceflow UDE.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.splitθ-Tuple{Any, Integer, ODINN.TrainableModel}-api","page":"API","title":"ODINN.splitθ","text":"splitθ(θ, glacier_idx::Integer, optimizableComponent::TrainableModel)\n\nGiven a ComponentVector θ, a glacier_idx and an optimizableComponent, extract the content of θ relevant for the given optimizableComponent and glacier ID glacier_idx.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.train_UDE!-Tuple{Inversion, Optim.FirstOrderOptimizer}-api","page":"API","title":"ODINN.train_UDE!","text":"BFGS optim\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.train_UDE!-Tuple{Inversion}-api","page":"API","title":"ODINN.train_UDE!","text":"train_UDE!(\n    simulation::Inversion;\n    save_every_iter::Bool = false,\n    logger::Union{<: TBLogger, Nothing} = nothing\n)\n\nTrains UDE based on the current Inversion.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.train_UDE!-Union{Tuple{AR}, Tuple{Inversion, AR}} where AR<:Optimisers.AbstractRule-api","page":"API","title":"ODINN.train_UDE!","text":"ADAM optim\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S<:Simulation-api","page":"API","title":"ODINN.update_training_state!","text":"update_training_state!(simulation::S, l) where {S <: Simulation}\n\nUpdate the training state to determine if the training has completed an epoch. If an epoch is completed, reset the minibatches, update the history loss, and increment the epoch count.\n\nArguments\n\nsimulation: The current state of the simulation or training process.\nl: The current loss value or other relevant metric.\n\nReturns\n\nNone. This function updates the state in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.σ_zang-Tuple{Any}-api","page":"API","title":"ODINN.σ_zang","text":"σ_zang(x; β = 2.0)\n\nSmooth thresholding function for enforcing non-negativity and zero values for negative values following I. Zang, \"A smoothing-out technique for min—max optimization\" (1980).\n\nArguments\n\nx::Real: Input value to be thresholded.\nβ::Real: (optional) Parameter controlling the transition zone width. Default is 2.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.∂σ_zang-Tuple{Any}-api","page":"API","title":"ODINN.∂σ_zang","text":"∂σ_zang(x; β = 2.0)\n\nDerivative of the smooth thresholding function σ_zang.\n\nArguments\n\nx::Real: Input value to be thresholded.\nβ::Real: (optional) Parameter controlling the transition zone width. Default is 2.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ODINN.∇²-Union{Tuple{F}, Tuple{Matrix{F}, F, F}} where F<:AbstractFloat-api","page":"API","title":"ODINN.∇²","text":"∇²(a::Matrix{F}, Δx::F, Δy::F) where {F<:AbstractFloat}\n\nComputes the 2D Laplacian operator of a scalar field a on a regular grid using finite differences and staggered (dual–primal) averaging.\n\nArguments\n\na::Matrix{F}: 2D scalar field to differentiate.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\n\nReturns\n\nMatrix{F}: Approximation of the Laplacian ∇²a with boundary values set to 0.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.HalfarParameters-api","page":"API","title":"Huginn.HalfarParameters","text":"HalfarParameters(; λ=0.0, H₀=3600.0, R₀=750000.0, n=3.0, A=1e-16, f=0.0, ρ=910.0, g=9.81)\n\nHolds parameters for the Halfar similarity solution of the shallow ice approximation (SIA).\n\nParameters\n\nλ::AbstractFloat=0.0: Mass balance coefficient (used to model accumulation/ablation).\nH₀::AbstractFloat=3600.0: Dome height at initial time t₀ [m].\nR₀::AbstractFloat=750000.0: Ice sheet margin radius at t₀ [m].\nn::AbstractFloat=3.0: Glen flow law exponent.\nA::AbstractFloat=1e-16: Flow rate factor in Glen's law [Pa⁻ⁿ yr⁻¹].\nf::AbstractFloat=0.0: Fraction of isostatic bed depression (0 for fully grounded ice).\nρ::AbstractFloat=910.0: Ice density [kg/m³].\ng::AbstractFloat=9.81: Gravitational acceleration [m/s²].\n\nNotes\n\nDefault parameters set as in Bueler (2005) \"Exact solutions and verification of numerical models for isothermalice sheets\", experiment B.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.IceflowModel-api","page":"API","title":"Huginn.IceflowModel","text":"IceflowModel\n\nAn abstract type representing the base model for ice flow simulations. All specific ice flow models should subtype this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier-api","page":"API","title":"Huginn.Prediction","text":"Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G <: Sleipnir.AbstractGlacier}\n\nCreate a Prediction object using the given model, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for prediction.\nglaciers::Vector{G}: A vector of glacier objects, where each glacier is a subtype of Sleipnir.AbstractGlacier.\nparameters::Sleipnir.Parameters: The parameters used for the prediction.\n\nReturns\n\nPrediction: A Prediction object based on the input values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.Prediction-api","page":"API","title":"Huginn.Prediction","text":"Prediction{CACHE} <: Simulation\n\nA mutable struct that represents a prediction simulation.\n\nFields\n\nmodel::Sleipnir.Model: The model used for the prediction.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the prediction.\nparameters::Sleipnir.Parameters: The parameters used for the prediction.\nresults::Vector{Results}: A vector of results obtained from the prediction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.SIA2DCache-api","page":"API","title":"Huginn.SIA2DCache","text":"SIA2DCache{\n    R <: Real,\n    I <: Integer,\n    A_CACHE,\n    C_CACHE,\n    n_CACHE,\n    p_CACHE,\n    q_CACHE,\n    n_H_CACHE,\n    n_∇S_CACHE,\n    Y_CACHE,\n    U_CACHE\n} <: SIAmodel\n\nStore and preallocated all variables needed for running the 2D Shallow Ice Approximation (SIA) model efficiently.\n\nType Parameters\n\nR: Real number type used for physical fields.\nI: Integer type used for indexing glaciers.\nA_CACHE, C_CACHE, n_CACHE: Types used for caching A, C, and n, which can be scalars, vectors, or matrices.\nY_CACHE: Type used for caching Y which is a matrix.\nU_CACHE: Type used for caching U which is a matrix.\n\nFields\n\nA::A_CACHE: Flow rate factor.\nC::C_CACHE: Sliding coefficient.\nn::n_CACHE: Flow law exponent.\np::n_CACHE: Sliding law exponent.\nq::n_CACHE: Sliding law exponent.\nn_H::n_CACHE: Exponent used for the power of H when using the Y law.\nn_∇S::n_CACHE: Exponent used for the power of ∇S when using the Y law.\nY::Y_CACHE: Hybrid diffusivity.\nU::U_CACHE: Diffusive velocity.\nH₀::Matrix{R}: Initial ice thickness.\nH::Matrix{R}: Ice thickness.\nH̄::Matrix{R}: Averaged ice thickness.\nS::Matrix{R}: Surface elevation.\ndSdx::Matrix{R}: Surface slope in the x-direction.\ndSdy::Matrix{R}: Surface slope in the y-direction.\nD::Matrix{R}: Diffusivity.\nDx::Matrix{R}: Diffusivity in the x-direction.\nDy::Matrix{R}: Diffusivity in the y-direction.\ndSdx_edges::Matrix{R}: Surface slope at edges in the x-direction.\ndSdy_edges::Matrix{R}: Surface slope at edges in the y-direction.\n∇S::Matrix{R}: Norm of the surface gradient.\n∇Sy::Matrix{R}: Surface gradient component in the y-direction.\n∇Sx::Matrix{R}: Surface gradient component in the x-direction.\nFx::Matrix{R}: Flux in the x-direction.\nFy::Matrix{R}: Flux in the y-direction.\nFxx::Matrix{R}: Second derivative of flux in the x-direction.\nFyy::Matrix{R}: Second derivative of flux in the y-direction.\nV::Matrix{R}: Velocity magnitude.\nVx::Matrix{R}: Velocity in the x-direction.\nVy::Matrix{R}: Velocity in the y-direction.\nΓ::A_CACHE: Basal shear stress.\nMB::Matrix{R}: Mass balance.\nMB_mask::BitMatrix: Boolean mask for applying the mass balance.\nMB_total::Matrix{R}: Total mass balance field.\nglacier_idx::I: Index of the glacier for use in simulations with multiple glaciers.\nA_prep_vjps, C_prep_vjps, n_prep_vjps, Y_prep_vjps and U_prep_vjps: Structs   that contain the prepared VJP functions for the adjoint computation and for the   different laws. Useful mainly when the user does not provide the VJPs and they are   automatically inferred using DifferentiationInterface.jl which requires to store   precompiled functions. When no gradient is computed, these structs are nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.SIA2Dmodel-api","page":"API","title":"Huginn.SIA2Dmodel","text":"SIA2Dmodel(A, C, n, Y, U, n_H, n_∇S)\nSIA2Dmodel(params; A, C, n, Y, U, n_H, n_∇S)\n\nCreate a SIA2Dmodel, representing a two-dimensional Shallow Ice Approximation (SIA) model.\n\nThe SIA model describes glacier flow under the assumption that deformation and basal sliding dominate the ice dynamics. It relies on:\n\nGlen's flow law for internal deformation, with flow rate factor A and exponent n,\nA sliding law governed by coefficient C,\nOptionally the user can provide either:\nA specific diffusive velocity U such that D = U * H\nA modified creep coefficient Y that takes into account the ice thickness   such that D = (C + Y * 2/(n+2)) * (ρ*g)^n * H^(n_H+1) * |∇S|^(n_∇S-1)   where n_H and n_∇S are optional parameters that control if the SIA   should use the n law or not.   This formulation is denoted as the hybrid diffusivity in the code.\n\nThis struct stores the laws used to compute these three parameters during a simulation. If not provided, default constant laws are used based on glacier-specific values.\n\nArguments\n\nA: Law for the flow rate factor. Defaults to a constant value from the glacier.\nC: Law for the sliding coefficient. Defaults similarly.\nn: Law for the flow law exponent. Defaults similarly.\np: Law for the sliding law exponent (basal drag). Defaults similarly.\nq: Law for the sliding law exponent (normal stress). Defaults similarly.\nY: Law for the hybrid diffusivity. Providing a law for Y discards the laws of A, C and n.\nU: Law for the diffusive velocity. Defaults behavior is to disable it and in such a case it is computed from A, C and n. Providing a law for U discards the laws of A, C, n and Y.\nn_H::F: The exponent to use for H in the SIA equation when using the Y law (hybrid diffusivity). It should be nothing when this law is not used.\nn_∇S::F: The exponent to use for ∇S in the SIA equation when using the Y law (hybrid diffusivity). It should be nothing when this law is not used.\nY_is_provided::Bool: Whether the diffusivity is provided by the user through the hybrid diffusivity Y or it has to be computed from the SIA formula from A, C and n.\nU_is_provided::Bool: Whether the diffusivity is provided by the user through the diffusive velocity U or it has to be computed from the SIA formula from A, C and n.\nn_H_is_provided::Bool: Whether the H exponent is prescribed by the user, or the one of the n law has to be used. This flag is used only when a law for Y is used.\nn_∇S_is_provided::Bool: Whether the ∇S exponent is prescribed by the user, or the one of the n law has to be used. This flag is used only when a law for Y is used.\napply_A_in_SIA::Bool: Whether the value of the A law should be computed each time the SIA is evaluated.\napply_C_in_SIA::Bool: Whether the value of the C law should be computed each time the SIA is evaluated.\napply_n_in_SIA::Bool: Whether the value of the n law should be computed each time the SIA is evaluated.\napply_p_in_SIA::Bool: Whether the value of the p law should be computed each time the SIA is evaluated.\napply_q_in_SIA::Bool: Whether the value of the q law should be computed each time the SIA is evaluated.\napply_Y_in_SIA::Bool: Whether the value of the Y law should be computed each time the SIA is evaluated.\napply_U_in_SIA::Bool: Whether the value of the U law should be computed each time the SIA is evaluated.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.SIAmodel-api","page":"API","title":"Huginn.SIAmodel","text":"SIAmodel\n\nAn abstract type representing the Shallow Ice Approximation (SIA) models. This type is a subtype of IceflowModel and serves as a base for all SIA-specific models.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer}-api","page":"API","title":"Huginn.SolverParameters","text":"Constructs a SolverParameters object with the specified parameters or using default values.\n\nSolverParameters(;\n    solver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),\n    reltol::F = 1e-12,\n    step::F = 1.0/12.0,\n    tstops::Vector{Sleipnir.Float} = Vector{Sleipnir.Float}(),\n    save_everystep = false,\n    progress::Bool = true,\n    progress_steps::I = 10,\n    maxiters::I = Int(1e5),\n) where {F <: AbstractFloat, I <: Integer}\n\nArguments\n\nsolver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm: The ODE solver algorithm to use. Defaults to RDPK3Sp35().\nreltol::F: The relative tolerance for the solver. Defaults to 1e-12.\nstep::F: The step size that controls at which frequency the solution should be computed and returned in the results.   Defaults to 1.0/12.0 (i.e. a month).\ntstops::Vector{Sleipnir.Float}: Optional vector of time points where the solver should stop. Defaults to an empty vector.\nsave_everystep::Bool: Whether to save the solution at every step computed by the solver. Defaults to false.\nprogress::Bool: Whether to show progress during the solving process. Defaults to true.\nprogress_steps::I: The number of steps between progress updates. Defaults to 10.\nmaxiters::I: Maximum number of iterations to perform in the iceflow solver. Defaults to 1e5.\n\nReturns\n\nsolver_parameters: A SolverParameters object constructed with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.SolverParameters-api","page":"API","title":"Huginn.SolverParameters","text":"A mutable struct that holds parameters for the solver.\n\nSolverParameters{F <: AbstractFloat, I <: Integer}\n\nFields\n\nsolver::OrdinaryDiffEqCore.OrdinaryDiffEqAdaptiveAlgorithm: The algorithm used for solving differential equations.\nreltol::F: The relative tolerance for the solver.\nstep::F: The step size that controls at which frequency the results must be saved.\ntstops::Vector{F}: Optional vector of time points where the solver should stop to store the results.\nsave_everystep::Bool: Flag indicating whether to save the solution at every step computed by the solver.\nprogress::Bool: Flag indicating whether to show progress during the solving process.\nprogress_steps::I: The number of steps between progress updates.\nmaxiters::I: Maximum number of iterations to perform in the iceflow solver.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.iAvgGriddedTemp-api","page":"API","title":"Huginn.iAvgGriddedTemp","text":"iAvgGriddedTemp <: AbstractInput\n\nInput that represents the long term air temperature over the glacier grid. It is computed using the OGGM climate data over a period predefined in Gungnir (i.e. around 30 years).\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.iAvgScalarTemp-api","page":"API","title":"Huginn.iAvgScalarTemp","text":"iAvgScalarTemp <: AbstractInput\n\nInput that represents the long term air temperature over the whole glacier. It is computed using the OGGM climate data over a period predefined in Gungnir (i.e. around 30 years).\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.iCPDD-api","page":"API","title":"Huginn.iCPDD","text":"iCPDD <: AbstractInput\n\nInput that represents the cumulative positive degree days (PDD) over the last time window window. It is computed by summing the daily PDD values from t - window to t using the glacier's climate data.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.iH̄-api","page":"API","title":"Huginn.iH̄","text":"iH̄ <: AbstractInput\n\nInput that represents the ice thickness in the SIA. It is the averaged ice thickness computed on the dual grid, that is H̄ = avg(H) which is different from the ice thickness solution H.\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.iTopoRough-api","page":"API","title":"Huginn.iTopoRough","text":"iTopoRough{F<:AbstractFloat} <: AbstractInput\n\nInput that represents the topographic roughness of the glacier. It is computed as the curvature of the glacier bed (or surface) over a specified window size. The curvature can be calculated in different directions (flow, cross-flow, or both) and using different curvature types (scalar or variability).\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.i∇S-api","page":"API","title":"Huginn.i∇S","text":"i∇S <: AbstractInput\n\nInput that represents the surface slope in the SIA. It is computed using the bedrock elevation and the ice thickness solution H. The spatial differences are averaged over the opposite axis:\n\nS = B + H\n∇S = (avg_y(diff_x(S) / Δx).^2 .+ avg_x(diff_y(S) / Δy).^2).^(1/2)\n\n\n\n\n\n","category":"type"},{"location":"api/#Huginn.ConstantA-Tuple{F} where F<:AbstractFloat-api","page":"API","title":"Huginn.ConstantA","text":"ConstantA(A::F) where {F <: AbstractFloat}\n\nLaw that represents a constant A in the SIA.\n\nArguments:\n\nA::F: Rheology factor A.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.CuffeyPaterson-Tuple{}-api","page":"API","title":"Huginn.CuffeyPaterson","text":"CuffeyPaterson(; scalar::Bool = true)\n\nCreate a rheology law for the flow rate factor A. The created law maps the long term air temperature to A using the values from Cuffey & Peterson through polyA_PatersonCuffey that returns a polynomial which is then evaluated at a given temperature in the law.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.Halfar-Tuple{HalfarParameters}-api","page":"API","title":"Huginn.Halfar","text":"Halfar(halfar_params::HalfarParameters) -> (_halfar::Function, t₀_years::Float64)\n\nConstructs the Halfar similarity solution to the SIA for a radially symmetric ice sheet dome following Bueler (2005) \"Exact solutions and verification of numerical models for  isothermalice sheets\"\n\nArguments\n\nhalfar_params::HalfarParameters: A struct containing physical and geometric parameters for the Halfar solution, including dome height, margin radius, Glen exponent, and other constants.\n\nReturns\n\n_halfar::Function: A function (x, y, t) -> H that evaluates the ice thickness H at position (x, y) and time t (in years).\nt₀_years::Float64: The characteristic timescale t₀ (in years) of the solution, based on the specified parameters.\n\nDescription\n\nThe solution has the form:\n\n```math H(r, t) = H₀ (t / t₀)^(-α) [1 - ((t / t₀)^(-β) (r / R₀))^((n+1)/n)]^{n / (2n + 1)}\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.Halfar_velocity-Tuple{HalfarParameters}-api","page":"API","title":"Huginn.Halfar_velocity","text":"Halfar_velocity(halfar_params::HalfarParameters)\n\nSame as Halfar(halfar_params), but instead of returning a function that gives the ice thickness as a function of space and time, this returns the ice surface velocity according to the Shallow Ice Approximation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R, Any}} where {R<:Real, SIM<:Simulation}-api","page":"API","title":"Huginn.SIA2D!","text":"SIA2D!(\n    dH::Matrix{R},\n    H::Matrix{R},\n    simulation::SIM,\n    t::R,\n    θ,\n) where {R <:Real, SIM <: Simulation}\n\nSimulates the evolution of ice thickness in a 2D shallow ice approximation (SIA) model. Works in-place.\n\nArguments\n\ndH::Matrix{R}: Matrix to store the rate of change of ice thickness.\nH::Matrix{R}: Matrix representing the ice thickness.\nsimulation::SIM: Simulation object containing model parameters and state.\nt::R: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nDetails\n\nThis function updates the ice thickness H and computes the rate of change dH using the shallow ice approximation in 2D. It retrieves necessary parameters from the simulation object, enforces positive ice thickness values, updates glacier surface altimetry and computes surface gradients. It then applies the necessary laws that are not updated via callbacks (A, C, n or U depending on the use-case) and computes the flux components, and flux divergence.\n\nNotes\n\nThe function operates on a staggered grid for computing gradients and fluxes.\nSurface elevation differences are capped using upstream ice thickness to impose boundary conditions.\nThe function modifies the input matrices dH and H in-place.\n\nSee also SIA2D\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.SyntheticC-Tuple{Sleipnir.Parameters}-api","page":"API","title":"Huginn.SyntheticC","text":"SyntheticC(params::Sleipnir.Parameters)\n\nCreates a synthetic law for calculating the parameter C using a nonlinear sigmoid transformation based on the ratio of CPDD (cumulative positive degree days) to topo_roughness (topographic roughness). The law is parameterized by minimum and maximum values (Cmin, Cmax) from params.physical, and applies a sigmoid scaling to smoothly interpolate between these bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.V_from_H-Union{Tuple{SIM}, Tuple{F}, Tuple{SIM, Matrix{F}, Real, Any}} where {F<:AbstractFloat, SIM<:Simulation}-api","page":"API","title":"Huginn.V_from_H","text":"V_from_H(\n    simulation::SIM,\n    H::Matrix{F},\n    t::Real,\n    θ,\n) where {F <: AbstractFloat, SIM <: Simulation}\n\nCompute surface velocity from ice thickness using the SIA model. It relies on surface_V to compute Vx and Vy and it additionally computes the magnitude of the velocity V.\n\nArguments:\n\nsimulation::SIM: The simulation structure used to retrieve the physical   parameters.\nH::Matrix{F}: The ice thickness matrix.\nt::R: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nReturns:\n\nVx: x axis component of the surface velocity.\nVy: y axis component of the surface velocity.\nV: Magnitude velocity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.apply_MB_mask!-Tuple{Any, SIA2DCache}-api","page":"API","title":"Huginn.apply_MB_mask!","text":"apply_MB_mask!(H, ifm::SIA2DCache)\n\nApply the mass balance (MB) mask to the iceflow model in-place. This function ensures that no MB is applied on the borders of the glacier to prevent overflow.\n\nArguments:\n\nH: Ice thickness.\nifm::SIA2DCache: Iceflow cache of the SIA2D that provides the mass balance information and that is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg!-Tuple{Any, Any}-api","page":"API","title":"Huginn.avg!","text":"avg!(O, I)\n\nCompute the average of adjacent elements in the input array I and store the result in the output array O.\n\nArguments\n\nO: Output array where the averaged values will be stored.\nI: Input array from which the adjacent elements will be averaged.\n\nDetails\n\nThis function uses the @views macro to avoid creating temporary arrays and the @. macro to broadcast the operations. The averaging is performed by taking the mean of each 2x2 block of elements in I and storing the result in the corresponding element in O.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg-Tuple{Any}-api","page":"API","title":"Huginn.avg","text":"avg(A::AbstractArray)\n\nCompute the average of each 2x2 block in the input array A. The result is an array where each element is the average of the corresponding 2x2 block in A.\n\nArguments\n\nA::AbstractArray: A 2D array of numerical values.\n\nReturns\n\nA 2D array of the same type as A, where each element is the average of a 2x2 block from A.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_surface_V!-Union{Tuple{R}, Tuple{SIM}, Tuple{SIM, R, Any}} where {SIM<:Simulation, R<:Real}-api","page":"API","title":"Huginn.avg_surface_V!","text":"avg_surface_V!(simulation::SIM, t::R, θ) where {SIM <: Simulation, R <: Real}\n\nCalculate the average surface velocity for a given simulation.\n\nArguments\n\nsimulation::SIM: A simulation object of type SIM which is a subtype of Simulation.\nt::R: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nDescription\n\nThis function computes the average surface velocity components (Vx and Vy) and the resultant velocity (V) for the ice flow model within the given simulation. It first calculates the surface velocities at the initial and current states, then averages these velocities and updates the ice flow model's velocity fields.\n\nNotes\n\nThe function currently uses a simple averaging method and may need more datapoints for better interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_x!-Tuple{Any, Any}-api","page":"API","title":"Huginn.avg_x!","text":"avg_x!(O, I)\n\nCompute the average of adjacent elements along the first dimension of array I and store the result in array O.\n\nArguments\n\nO: Output array where the averaged values will be stored.\nI: Input array from which adjacent elements will be averaged.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_x-Tuple{Any}-api","page":"API","title":"Huginn.avg_x","text":"avg_x(A::AbstractArray)\n\nCompute the average of adjacent elements along the first dimension of the array A.\n\nArguments\n\nA::AbstractArray: Input array.\n\nReturns\n\nAn array of the same type as A with one less element along the first dimension, containing the averages of adjacent elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_y!-Tuple{Any, Any}-api","page":"API","title":"Huginn.avg_y!","text":"avg_y!(O, I)\n\nCompute the average of adjacent elements along the second dimension of array I and store the result in array O.\n\nArguments\n\nO: Output array where the averaged values will be stored.\nI: Input array from which the adjacent elements will be averaged.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.avg_y-Tuple{Any}-api","page":"API","title":"Huginn.avg_y","text":"avg_y(A::AbstractArray)\n\nCompute the average of adjacent elements along the second dimension of the input array A.\n\nArguments\n\nA::AbstractArray: An array of numeric values.\n\nReturns\n\nAn array of the same type as A containing the averages of adjacent elements along the second dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I<:Integer-api","page":"API","title":"Huginn.batch_iceflow_PDE!","text":"batch_iceflow_PDE!(glacier_idx::I, simulation::Prediction) where {I <: Integer}\n\nSolve the Shallow Ice Approximation iceflow PDE in-place for a given set of laws prescribed in the simulation object. It creates the iceflow problem, the necessary callbacks and solve the PDE.\n\nArguments:\n\nglacier_idx::I: Integer ID of the glacier.\nsimulation::Prediction: Simulation object that contains all the necessary information to solve the iceflow.\n\nReturns\n\nA Results instance that stores the iceflow solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.build_callback-Tuple{SIA2Dmodel, SIA2DCache, Real, Any, Any}-api","page":"API","title":"Huginn.build_callback","text":"build_callback(model::SIA2Dmodel, cache::SIA2DCache, glacier_idx::Real, θ, tspan) -> CallbackSet\n\nReturn a CallbackSet that updates the cached values of A, C, n and U at provided time intervals.\n\nEach law can optionally specify a callback frequency via callback_freq.\n\nIf callback_freq > 0, a PeriodicCallback is used to update the corresponding component at regular intervals.\nIf callback_freq == 0, a PresetTimeCallback is used to trigger the update only at the initial time\n\n(taken from tspan[1]).\n\nIf no callback is specified for a component, a dummy CallbackSet is returned.\n\nArguments:\n\nmodel::SIA2Dmodel: The ice flow model definition.\ncache::SIA2DCache: Model cache for efficient component access and updates.\nglacier_idx::Real: Index of the glacier in the simulation.\nθ: Optional parameter for law evaluation.\ntspan: Tuple or floats specifying the simulation time span. Used to determine initial callback time when freq == 0.\n\nReturns:\n\nA CallbackSet containing all the callbacks for periodic or preset updates of model components.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.d2dx-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64}} where T<:Real-api","page":"API","title":"Huginn.d2dx","text":"d2dx(f::Matrix{T}, i::Int, j::Int, Δx::Float64) where T <: Real\n\nCompute the second central difference in the x-direction at (i,j).\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.d2dxy-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64, Float64}} where T<:Real-api","page":"API","title":"Huginn.d2dxy","text":"d2dxy(f::Matrix{T}, i::Int, j::Int, Δx::Float64, Δy::Float64) where T <: Real\n\nCompute the mixed second central difference (∂²f/∂x∂y) at (i,j).\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.d2dy-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Int64, Float64}} where T<:Real-api","page":"API","title":"Huginn.d2dy","text":"d2dy(f::Matrix{T}, i::Int, j::Int, Δy::Float64) where T <: Real\n\nCompute the second central difference in the y-direction at (i,j).\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F<:AbstractFloat-api","page":"API","title":"Huginn.define_callback_steps","text":"define_callback_steps(tspan::Tuple{F, F}, step::F) where {F <: AbstractFloat}\n\nDefines the times to stop for the DiscreteCallback given a step and a timespan.\n\nArguments\n\ntspan::Tuple{F, F}: A tuple representing the start and end times.\nstep::F: The step size for generating the callback steps.\n\nReturns\n\nVector{F}: A vector of callback steps within the specified time span.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.diff_x!-Tuple{Any, Any, Any}-api","page":"API","title":"Huginn.diff_x!","text":"diff_x!(O, I, Δx)\n\nCompute the finite difference of array I along the first dimension and store the result in array O. The difference is computed using the spacing Δx.\n\nArguments\n\nO: Output array to store the finite differences.\nI: Input array from which finite differences are computed.\nΔx: Spacing between points in the first dimension.\n\nNotes\n\nThe function uses @views to avoid copying data when slicing arrays.\nThe operation is performed in-place, modifying the contents of O.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.diff_x-Tuple{Any}-api","page":"API","title":"Huginn.diff_x","text":"diff_x(A::AbstractArray)\n\nCompute the difference along the first dimension of the array A.\n\nArguments\n\nA::AbstractArray: Input array.\n\nReturns\n\nAn array of the same type as A containing the differences along the first dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.diff_y!-Tuple{Any, Any, Any}-api","page":"API","title":"Huginn.diff_y!","text":"diff_y!(O, I, Δy)\n\nCompute the finite difference along the y-axis and store the result in O.\n\nArguments\n\nO: Output array where the result will be stored.\nI: Input array from which the finite difference is computed.\nΔy: The spacing between points in the y-direction.\n\nDescription\n\nThis function calculates the finite difference along the y-axis for the input array I and stores the result in the output array O. The calculation is performed using the formula:\n\nO = (I[:,begin+1:end] - I[:,1:end - 1]) / Δy\n\nThe @views macro is used to avoid copying data when slicing the array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.diff_y-Tuple{Any}-api","page":"API","title":"Huginn.diff_y","text":"diff_y(A::AbstractArray)\n\nCompute the difference between adjacent elements along the second dimension (columns) of the input array A.\n\nArguments\n\nA::AbstractArray: An array of numeric values.\n\nReturns\n\nAn array of the same type as A containing the differences between adjacent elements along the second dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G<:AbstractGlacier, F<:AbstractFloat}-api","page":"API","title":"Huginn.generate_ground_truth","text":"generate_ground_truth(\n    glaciers::Vector{G},\n    params::Sleipnir.Parameters,\n    model::Sleipnir.Model,\n    tstops::Vector{F};\n    store::Tuple=(:H, :V),\n) where {G <: Sleipnir.AbstractGlacier, F <: AbstractFloat}\n\nGenerate ground truth data for a glacier simulation by using the laws specified in the model and running a forward model. It returns a new vector of glaciers with updated thicknessData and velocityData fields based on the store argument.\n\nArguments\n\nglaciers::Vector{G}: A vector of glacier objects of type G, where G is a subtype of Sleipnir.AbstractGlacier.\nparams::Sleipnir.Parameters: Simulation parameters.\nmodel::Sleipnir.Model: The model to use for the simulation.\ntstops::Vector{F}: A vector of time steps at which the simulation will be evaluated.\nstore::Tuple: Which generated simulation products to store. It can include :H and/or :V.\n\nDescription\n\nRuns a forward model simulation for the glaciers using the provided laws, parameters, model, and time steps.\nBuild a new vector of glaciers and store the simulation results as ground truth in the glaciers struct.\n\nFor each glacier it populates the thicknessData field if store contains :H and it populates velocityData if store contains :V.\n\nExample\n\nglaciers = [glacier1, glacier2] # dummy example\nparams = Huginn.Parameters(...) # to be filled\nmodel = Huginn.Model(...) # to be filled\ntstops = 0.0:1.0:10.0\n\nglaciers = generate_ground_truth(glaciers, params, model, tstops)\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.generate_ground_truth_prediction-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G<:AbstractGlacier, F<:AbstractFloat}-api","page":"API","title":"Huginn.generate_ground_truth_prediction","text":"generate_ground_truth_prediction(\n    glaciers::Vector{G},\n    params::Sleipnir.Parameters,\n    model::Sleipnir.Model,\n    tstops::Vector{F},\n) where {G <: Sleipnir.AbstractGlacier, F <: AbstractFloat}\n\nWrapper for generate_ground_truth that also updates the glaciers field of the Prediction object.\n\nArguments\n\nglaciers::Vector{G}: A vector of glacier objects of type G, where G is a subtype of Sleipnir.AbstractGlacier.\nparams::Sleipnir.Parameters: Simulation parameters.\nmodel::Sleipnir.Model: The model to use for the simulation.\ntstops::Vector{F}: A vector of time steps at which the simulation will be evaluated.\n\nDescription\n\nThis function calls generate_ground_truth to generate ground truth data for the glaciers using the provided laws, parameters, model, and time steps. In addition, it updates the glaciers field of the Prediction object with the newly generated glaciers containing the ground truth data.\n\nExample\n\nglaciers = [glacier1, glacier2] # dummy example\nparams = Huginn.Parameters(...) # to be filled\nmodel = Huginn.Model(...) # to be filled\ntstops = 0.0:1.0:10.0\n\nprediction = generate_ground_truth_prediction(glaciers, params, model, tstops)\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.generate_result-Union{Tuple{SIM}, Tuple{SIM, Any, Any}} where SIM<:Simulation-api","page":"API","title":"Huginn.generate_result","text":"generate_result(placeholder_sim::SIM, A, n) where {SIM <: Simulation}\n\nGenerate the result of a simulation by initializing the model with the specified parameters and running the simulation.\n\nArguments\n\nsimulation::SIM: An instance of a type that is a subtype of Simulation.\nA: The parameter to set for simulation.model.iceflow.A.\nn: The parameter to set for simulation.model.iceflow.n.\n\nReturns\n\nresult: The first result from the simulation's results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.inn-Tuple{Any}-api","page":"API","title":"Huginn.inn","text":"inn(A::AbstractArray)\n\nExtracts the inner part of a 2D array A, excluding the first and last rows and columns.\n\nArguments\n\nA::AbstractArray: A 2D array from which the inner part will be extracted.\n\nReturns\n\nA subarray of A containing all elements except the first and last rows and columns.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.inn1-Tuple{Any}-api","page":"API","title":"Huginn.inn1","text":"inn1(A::AbstractArray)\n\nReturns a view of the input array A excluding the last row and the last column.\n\nArguments\n\nA::AbstractArray: The input array from which a subarray view is created.\n\nReturns\n\nA view of the input array A that includes all elements except the last row and the last column.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.polyA_PatersonCuffey-Tuple{}-api","page":"API","title":"Huginn.polyA_PatersonCuffey","text":"polyA_PatersonCuffey()\n\nReturns a function of the coefficient A as a polynomial of the temperature. The values used to fit the polynomial come from Cuffey & Peterson.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.precompute_all_VJPs_laws!-Tuple{SIA2Dmodel, SIA2DCache, Prediction, Integer, Real, Any}-api","page":"API","title":"Huginn.precompute_all_VJPs_laws!","text":"precompute_all_VJPs_laws!(\n    SIA2D_model::SIA2Dmodel,\n    SIA2D_cache::SIA2DCache,\n    simulation::Prediction,\n    glacier_idx::Integer,\n    t::Real,\n    θ,\n)\n\nFunction that does nothing and its existence is just to support multiple dispatch. The implementation that is useful is available in ODINN when simulation is a Inversion object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.project_curvatures-Tuple{Any, Any, Any}-api","page":"API","title":"Huginn.project_curvatures","text":"project_curvatures(H, eₚ, eₛ)\n\nComputes the scalar second derivative of the surface in a specific direction.\n\nArguments\n\nH: Hessian matrix (2x2).\neₚ: Principal direction vector 1 (2x1).\neₛ: Principal direction vector 2 (2x1). \n\nReturns\n\nKₚ: Curvature in the direction of eₚ.\nKₛ: Curvature in the direction of eₛ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.run!-Tuple{Prediction}-api","page":"API","title":"Huginn.run!","text":"run!(simulation::Prediction)\n\nIn-place run of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.simulate_iceflow_PDE!-Union{Tuple{F}, Tuple{SIM}, Tuple{SIM, SciMLBase.DECallback, Any, Vector{F}}} where {SIM<:Simulation, F<:AbstractFloat}-api","page":"API","title":"Huginn.simulate_iceflow_PDE!","text":"simulate_iceflow_PDE!(\n    simulation::SIM,\n    cb::SciMLBase.DECallback,\n    du,\n    tstops::Vector{F},\n) where {SIM <: Simulation, F <: AbstractFloat}\n\nMake forward simulation of the iceflow PDE determined in du in-place and create the results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.surface_V!-Union{Tuple{R}, Tuple{SIM}, Tuple{Matrix{<:Real}, SIM, R, Any}} where {SIM<:Simulation, R<:Real}-api","page":"API","title":"Huginn.surface_V!","text":"surface_V!(H::Matrix{<:Real}, simulation::SIM, t::R, θ) where {SIM <: Simulation, R <: Real}\n\nCompute the surface velocities of a glacier using the Shallow Ice Approximation (SIA) in 2D.\n\nArguments\n\nH::Matrix{<:Real}: The ice thickness matrix.\nsimulation::SIM: The simulation object containing parameters and model information.\nt::R: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nReturns\n\nVx: The x-component of the surface velocity.\nVy: The y-component of the surface velocity.\n\nDescription\n\nThis function updates the glacier surface altimetry and computes the surface gradients on edges using a staggered grid. It then calculates the surface velocities based on the Shallow Ice Approximation (SIA) model.\n\nDetails\n\nparams: The simulation parameters.\niceflow_model: The ice flow model from the simulation.\nglacier: The glacier object from the simulation.\nB: The bedrock elevation matrix.\nH̄: The average ice thickness matrix.\ndSdx, dSdy: The surface gradient matrices in x and y directions.\n∇S, ∇Sx, ∇Sy: The gradient magnitude and its components.\nΓꜛ: The surface stress.\nD: The diffusivity matrix.\nA: The flow rate factor.\nn: The flow law exponent.\nC: The sliding coefficient.\nΔx, Δy: The grid spacing in x and y directions.\nρ: The ice density.\ng: The gravitational acceleration.\n\nThe function computes the surface gradients, averages the ice thickness, and calculates the surface stress and diffusivity. Finally, it computes the surface velocities Vx and Vy based on the gradients and diffusivity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{Matrix{R}, SIM, Real, Any}} where {R<:Real, SIM<:Simulation}-api","page":"API","title":"Huginn.surface_V","text":"surface_V(\n    H::Matrix{R},\n    simulation::SIM,\n    t::Real,\n    θ,\n) where {R <: Real, SIM <: Simulation}\n\nCompute the surface velocities of a glacier using the Shallow Ice Approximation (SIA) in 2D.\n\nArguments\n\nH::Matrix{R}: Ice thickness matrix.\nsimulation::SIM: Simulation object containing parameters and model information.\nt::R: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nReturns\n\nVx: Matrix of surface velocities in the x-direction.\nVy: Matrix of surface velocities in the y-direction.\n\nDetails\n\nThis function computes the surface velocities of a glacier by updating the glacier surface altimetry and calculating the surface gradients on the edges. It uses a staggered grid approach to compute the gradients and velocities.\n\nNotes\n\nThe function assumes that the simulation object contains the necessary parameters and model information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.thickness_velocity_data-Union{Tuple{F}, Tuple{Prediction, Vector{F}}} where F<:AbstractFloat-api","page":"API","title":"Huginn.thickness_velocity_data","text":"thickness_velocity_data(\n    prediction::Prediction,\n    tstops::Vector{F};\n    store::Tuple=(:H, :V),\n) where {F <: AbstractFloat}\n\nReturn a new vector of glaciers with the simulated thickness and ice velocity data for each of the glaciers.\n\nArguments\n\nprediction::Prediction: A Prediction object containing the simulation results and associated glaciers.\ntstops::Vector{F}: A vector of time steps (of type F <: AbstractFloat) at which the simulation was evaluated.\nstore::Tuple: Which generated simulation products to store. It can include :H and/or :V.\n\nDescription\n\nThis function iterates over the glaciers in the Prediction object and generates the simulated data based on the store argument at corresponding time steps (t). If store includes :H, then the ice thickness is stored. If store includes :V, then it computes the surface ice velocity data and store it. A new vector of glaciers is created and each glacier is a copy with an updated thicknessData and velocityData fields.\n\nNotes\n\nThe function asserts that the time steps (ts) in the simulation results match the provided tstops. If they do not match, an error is raised.\n\nReturns\n\nA new vector of glaciers where each glacier is a copy of the original one with the updated thicknessData and velocityData based on the values provided in store.\n\n\n\n\n\n","category":"method"},{"location":"api/#Huginn.∇slope-Union{Tuple{T}, Tuple{Matrix{T}, T, T}} where T<:Real-api","page":"API","title":"Huginn.∇slope","text":"∇slope(S::Matrix{T}, Δx::T, Δy::T) where T <: Real\n\nCompute the magnitude of the surface slope ∇S for a scalar field S defined on a rectilinear grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_all_callback_laws!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Real, Any}-api","page":"API","title":"Sleipnir.apply_all_callback_laws!","text":"apply_all_callback_laws!(\n    SIA2D_model::SIA2Dmodel,\n    SIA2D_cache::SIA2DCache,\n    simulation,\n    glacier_idx::Integer,\n    t::Real,\n    θ,\n)\n\nApplies the different laws required by the SIA2D glacier model for a given glacier and simulation state. If U_is_provided is true in SIA2D_model and U is a callback law, it applies the law for U only. Otherwise if Y_is_provided and Y is a callback law, it applies the law for Y only. Finally, if U_is_provided and Y_is_provided are false, the function checks and applies the laws for A, C, and n, if they are defined as \"callback\" laws (i.e., handled as callbacks by the ODE solver). Results are written in-place to the cache for subsequent use in the simulation step.\n\nArguments\n\nSIA2D_model: The model object containing the laws (A, C, n, Y and U).\nSIA2D_cache: A cache object to store the evaluated values of the laws (A, C, n, Y and U) for the current step.\nsimulation: The simulation object.\nglacier_idx::Integer: Index of the glacier being simulated, used to select data for multi-glacier simulations.\nt::Real: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nNotes\n\nThe function mutates the contents of SIA2D_cache.\nOnly \"callback\" laws are applied.\nThis function is typically used in the manual adjoint and in the tests where only portions of the code are applied and we need to apply all the laws used in the iceflow model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_all_non_callback_laws!-Tuple{SIA2Dmodel, SIA2DCache, Any, Integer, Real, Any}-api","page":"API","title":"Sleipnir.apply_all_non_callback_laws!","text":"function apply_all_non_callback_laws!(\n    SIA2D_model::SIA2Dmodel,\n    SIA2D_cache::SIA2DCache,\n    simulation,\n    glacier_idx::Integer,\n    t::Real,\n    θ,\n)\n\nApplies the different laws required by the SIA2D glacier model for a given glacier and simulation state. If U_is_provided is true in SIA2D_model and U is not a callback law, it applies the law for U only. Otherwise if Y_is_provided and Y is not a callback law, it applies the law for Y only. Finally, if U_is_provided and Y_is_provided are false, the function checks and applies the laws for A, C, and n, unless they are defined as \"callback\" laws (i.e., handled as callbacks by the ODE solver). Results are written in-place to the cache for subsequent use in the simulation step.\n\nArguments\n\nSIA2D_model: The model object containing the laws (A, C, n, Y and U).\nSIA2D_cache: A cache object to store the evaluated values of the laws (A, C, n, Y and U) for the current step.\nsimulation: The simulation object.\nglacier_idx::Integer: Index of the glacier being simulated, used to select data for multi-glacier simulations.\nt::Real: Current simulation time.\nθ: Parameters of the laws to be used in the SIA. Can be nothing when no learnable laws are used.\n\nNotes\n\nThe function mutates the contents of SIA2D_cache.\n\"Callback\" laws are skipped, as they are expected to be handled outside this function.\nThis function is typically called at each simulation time step for each glacier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.init_cache-Tuple{SIA2Dmodel, Any, Int64, Any}-api","page":"API","title":"Sleipnir.init_cache","text":"function initcache(     iceflowmodel::SIA2Dmodel,     glacier::AbstractGlacier,     glacier_idx::I,     θ, ) where {IF <: IceflowModel, I <: Integer}\n\nInitialize iceflow model data structures to enable in-place mutation.\n\nKeyword arguments\n\niceflow_model: Iceflow model used for simulation.\nglacier_idx: Index of glacier.\nglacier: Glacier to provide basic initial state of the ice flow model.\nθ: Optional parameters of the laws.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.MBmodel-api","page":"API","title":"Muninn.MBmodel","text":"MBmodel <: AbstractModel\n\nAn abstract type representing a mass balance model in the Muninn package. This serves as a base type for all specific mass balance models, ensuring they adhere to a common interface and can be used interchangeably within the ODINN framework.\n\n\n\n\n\n","category":"type"},{"location":"api/#Muninn.TImodel-api","page":"API","title":"Muninn.TImodel","text":"TImodel <: MBmodel\n\nAn abstract type representing a temperature index mass balance models within the ODINN framework. This type serves as a parent type for more specialized mass balance models, ensuring they adhere to a common interface defined by the MBmodel abstract type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"Muninn.TImodel1","text":"TImodel1(params::Sleipnir.Parameters; DDF::F = 7.0/1000.0, acc_factor::F = 1.0/1000.0) where {F <: AbstractFloat}\n\nCreate a temperature index model with one degree-day factor (DDF) with the given parameters.\n\nArguments\n\nparams::Sleipnir.Parameters: The simulation parameters.\nDDF::F: Degree-day factor (default is 7.0/1000.0).\nacc_factor::F: Accumulation factor (default is 1.0/1000.0).\n\nReturns\n\nTI1_model: An instance of TImodel1 with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.TImodel1-api","page":"API","title":"Muninn.TImodel1","text":"TImodel1{F <: AbstractFloat}\n\nA structure representing a temperature index model with degree-day factor and accumulation factor.\n\nKeyword arguments\n\nDDF::F: Degree-day factor, which is a coefficient used to convert temperature into melt.\nacc_factor::F: Accumulation factor, which is a coefficient used to adjust the accumulation of mass.\n\nType Parameters\n\nF: A subtype of AbstractFloat representing the type of the factors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"Muninn.TImodel2","text":"TImodel2(params::Sleipnir.Parameters; DDF_snow::F = 3.0/1000.0, DDF_ice::F = 6.0/1000.0, acc_factor::F = 1.0/1000.0) where {F <: AbstractFloat}\n\nCreate a temperature-index model with two degree-day factors (TImodel2) for mass balance calculations.\n\nArguments\n\nparams::Sleipnir.Parameters: The parameters object containing simulation settings.\nDDF_snow::F: Degree-day factor for snow (default: 3.0/1000.0).\nDDF_ice::F: Degree-day factor for ice (default: 6.0/1000.0).\nacc_factor::F: Accumulation factor (default: 1.0/1000.0).\n\nReturns\n\nTI2_model: An instance of the TImodel2 with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.TImodel2-api","page":"API","title":"Muninn.TImodel2","text":"TImodel2{F <: AbstractFloat}\n\nA type representing a temperature-index model with parameters for snow and ice degree-day factors, and an accumulation factor.\n\nKeyword arguments\n\nDDF_snow::F: Degree-day factor for snow, which determines the melt rate of snow per degree above the melting point.\nDDF_ice::F: Degree-day factor for ice, which determines the melt rate of ice per degree above the melting point.\nacc_factor::F: Accumulation factor, which scales the accumulation of snow.\n\nType Parameters\n\nF: A subtype of AbstractFloat, representing the numeric type used for the model parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{Any, Sleipnir.Model, G, F, Any}} where {F<:AbstractFloat, G<:AbstractGlacier}-api","page":"API","title":"Muninn.MB_timestep!","text":"MB_timestep!(cache, model::Model, glacier::G, step::F, t) where {F <: AbstractFloat, G <: AbstractGlacier}\n\nSimulates a mass balance timestep for a given glacier model.\n\nArguments\n\ncache: The model cache to update.\nmodel::Model: The glacier model containing iceflow and mass balance information.\nglacier::G: The glacier object containing climate and DEM data.\nstep::F: The timestep duration.\nt: The current time.\n\nDescription\n\nThis function performs the following steps:\n\nComputes the period from the previous timestep to the current time.\nRetrieves cumulative climate data for the specified period.\nDownscales the climate dataset to a 2D grid based on the glacier's DEM.\nComputes the mass balance for the glacier and updates the model's iceflow mass balance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F<:AbstractFloat, G<:AbstractGlacier}-api","page":"API","title":"Muninn.MB_timestep","text":"MB_timestep(model::Model, glacier::G, step::F, t::F) where {F <: AbstractFloat, G <: AbstractGlacier}\n\nCalculate the mass balance (MB) for a glacier over a given timestep.\n\nKeyword arguments\n\nmodel::Model: The model containing mass balance parameters.\nglacier::G: The glacier object containing climate and DEM data.\nstep::F: The timestep duration.\nt::F: The current time.\n\nReturns\n\nMB::Matrix{F}: The computed mass balance matrix for the given timestep.\n\nDetails\n\nComputes the period between the current time t and the previous step t - step.\nRetrieves cumulative climate data for the specified period.\nDownscales the climate data to a 2D grid based on the glacier's DEM.\nComputes the mass balance using the downscaled climate data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep, AbstractFloat}-api","page":"API","title":"Muninn.compute_MB","text":"compute_MB(\n    mb_model::TImodel1,\n    climate_2D_period::Climate2Dstep,\n    step::AbstractFloat,\n)\n\nCompute the mass balance (MB) for a given mass balance model and climate period.\n\nArguments\n\nmb_model::TImodel1: The mass balance model containing parameters such as accumulation factor (acc_factor) and degree-day factor (DDF).\nclimate_2D_period::Climate2Dstep: The climate data for a specific period, including snow accumulation (snow) and positive degree days (PDD).\nstep::AbstractFloat: The step used to update MB. This scales the MB so that the accumulation and degree-day factors are scaled monthly.\n\nReturns\n\nA numerical array representing the computed mass balance, calculated as the difference between the product of the accumulation factor and snow, and the product of the degree-day factor and positive degree days.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.AbstractData-api","page":"API","title":"Sleipnir.AbstractData","text":"AbstractData\n\nAbstract type that represents data. Used to implement ThicknessData and SurfaceVelocityData.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.AbstractGlacier-api","page":"API","title":"Sleipnir.AbstractGlacier","text":"AbstractGlacier\n\nAn abstract type representing a glacier. This serves as a base type for different glacier implementations in the Sleipnir package.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.AbstractInput-api","page":"API","title":"Sleipnir.AbstractInput","text":"AbstractInput\n\nAbstract type representing an input source for a Law. Concrete subtypes must implement:\n\ndefault_name(::ConcreteInput): returns the default field name (as a Symbol) under which this input will be accessed in the law's input NamedTuple.\nget_input(::ConcreteInput, simulation, glacier_idx, t): retrieves the actual input value given the simulation context, glacier index, and time t.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.AbstractLaw-api","page":"API","title":"Sleipnir.AbstractLaw","text":"AbstractLaw\n\nAbstract type representing a synthetic law. Currently it's only used for testing by making easier to create dumb laws, but in the future it may be cleaner to use different concrete type of laws (for example CallbackLaw, ContinuousLaw, or LearnableLaw)\n\nConcrete subtypes must implement:\n\napply_law!(::ConcreteLaw, state, simulation, glacier_idx, t, θ)\ninit_cache(::ConcreteLaw, glacier, glacier_idx)\nlaw_VJP_input(::ConcreteLaw, cache, simulation, glacier_idx, t, θ)\nlaw_VJP_θ(::ConcreteLaw, cache, simulation, glacier_idx, t, θ)\nprecompute_law_VJP(::ConcreteLaw, cache, vjpsPrepLaw, simulation, glacier_idx, t, θ)\ncache_type(::ConcreteLaw)\nis_callback_law(::ConcreteLaw)\nis_precomputable_law_VJP(::ConcreteLaw)\ncallback_freq(::ConcreteLaw)\ninputs(::ConcreteLaw)\ninputs_defined(::ConcreteLaw)\napply_law_in_model(::ConcreteLaw)\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.AbstractModel-api","page":"API","title":"Sleipnir.AbstractModel","text":"AbstractModel\n\nAn abstract type that serves as a base for all model types in ODINN.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.AbstractParameters-api","page":"API","title":"Sleipnir.AbstractParameters","text":"AbstractParameters\n\nAn abstract type that serves as a base for all parameter-related types in the ODINN ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.AbstractPrepVJP-api","page":"API","title":"Sleipnir.AbstractPrepVJP","text":"AbstractPrepVJP\n\nAbstract type representing the preparation of Vector-Jacobian Product (VJP) computations for the laws. Subtypes of AbstractPrepVJP are used to handle any precomputations or setup required before evaluating VJPs, such as configuring automatic differentiation backends or precompiling code. This type provides a flexible interface for implementing custom VJP preparation strategies for different laws. It is for internal use only and not exposed to the user.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Cache-api","page":"API","title":"Sleipnir.Cache","text":"Cache\n\nAbstract type for defining a cache struct of a law.\n\nMandatory field:\n\nvalue: Store the result of a forward evaluation.\n\nOptional fields:\n\nvjp_inp: Store the result of the evaluation of the vector-Jacobian product (VJP) with respect to the inputs.\nvjp_θ: Store the result of the evaluation of the vector-Jacobian product (VJP) with respect to the parameters θ.\n\nNotes:\n\nIf a concrete subtype does not implement vjp_inp and vjp_θ, the law should not be used for gradient computation, and therefore for inversions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Climate2D-api","page":"API","title":"Sleipnir.Climate2D","text":"A mutable struct representing a 2D climate for a glacier with various buffers and datasets.\n\nClimate2D{CLIMRAW <: RasterStack, CLIMRAWSTEP <: RasterStack, CLIMSTEP <: ClimateStep, CLIM2DSTEP <: Climate2Dstep, F <: AbstractFloat}\n\nFields\n\nraw_climate::CLIMRAW: Raw climate dataset for the whole simulation.\nclimate_raw_step::CLIMRAWSTEP: Raw climate trimmed for the current step to avoid memory allocations.\nclimate_step::ClimateStep: Climate data for the current step.\nclimate_2D_step::Climate2Dstep: 2D climate data for the current step to feed to the mass balance (MB) model.\nlongterm_temps::Vector{F}: Long-term temperatures for the ice rheology.\navg_temps::F: Intermediate buffer for computing average temperatures.\navg_gradients::F: Intermediate buffer for computing average gradients.\nref_hgt::F: Reference elevation of the raw climate data.\nClimate2D(       rgi_id,       params::Parameters,       S::Matrix{<: AbstractFloat},       Coords::Dict,   )\n\nInitialize the climate data given a RGI ID, a matrix of surface elevation and glacier coordinates.\n\nArguments\n\nrgi_id: The glacier RGI ID.\nparams::Parameters: The parameters containing simulation settings and paths.\nS::Matrix{<: AbstractFloat}: Matrix of surface elevation used to initialize the downscaled climate data.\nCoords::Dict: Coordinates of the glacier.\n\nDescription\n\nThis function initializes the climate data for a glacier by:\n\nCreating a dummy period based on the simulation time span and step.\nLoading the raw climate data from a NetCDF file.\nCalculating the cumulative climate data for the dummy period.\nDownscaling the cumulative climate data to a 2D grid.\nRetrieving long-term temperature data for the glacier.\nReturning the climate data, including raw climate data, cumulative climate data, downscaled 2D climate data, long-term temperatures, average temperatures, and average gradients.\nClimate2D(      rawclimate::RasterStack,      climaterawstep::RasterStack,      climatestep::ClimateStep,      climate2Dstep::Climate2Dstep,      longtermtemps::Vector{<: AbstractFloat},      avgtemps::AbstractFloat,      avggradients::AbstractFloat,      refhgt::AbstractFloat,  )\n\nInitialize the climate data with the fields provided as arguments. Refer to the list of fields for a complete description of the arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Climate2Dstep-api","page":"API","title":"Sleipnir.Climate2Dstep","text":"Climate2Dstep{F <: AbstractFloat}\n\nA mutable struct representing a 2D climate time step with various climate-related parameters.\n\nKeyword arguments\n\ntemp::Matrix{F}: Temperature matrix.\nPDD::Matrix{F}: Positive Degree Days matrix.\nsnow::Matrix{F}: Snowfall matrix.\nrain::Matrix{F}: Rainfall matrix.\ngradient::F: Gradient value.\navg_gradient::F: Average gradient value.\nx::Vector{F}: X-coordinates vector.\ny::Vector{F}: Y-coordinates vector.\nref_hgt::F: Reference height.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.ClimateStep-api","page":"API","title":"Sleipnir.ClimateStep","text":"ClimateStep{F <: AbstractFloat}\n\nMutable struct that represents a climate step before downscaling.\n\nKeyword arguments\n\nprcp::F: Cumulative precipitation for the given period.\ntemp::F: Cumulative temperature at the reference elevation for the given period.\ngradient::F: Cumulative temperature gradient for the given period.\navg_temp::F: Average temperature over the time step.\navg_gradient::F: Average temperature gradient over the time step.\nref_hgt::F: Reference elevation of the raw climate data.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.ConstantLaw-api","page":"API","title":"Sleipnir.ConstantLaw","text":"ConstantLaw{CACHE_TYPE}(init_cache)\n\nCreates a constant law of type ConstantLaw{CACHE_TYPE} that holds a fixed value for the entire simulation.\n\nThis is useful to inject glacier-specific or global constants into the simulation without modifying them over time. The update function is a no-op, and only the init_cache function matters.\n\nArguments\n\ninit_cache::Function: A function init_cache(simulation, glacier_idx, θ)::T that provides the constant value.\n\nType Parameters\n\nCACHE_TYPE: The type of the cache. Must be specified manually and should match the return type of init_cache.\n\nExamples\n\n# Same value for all glaciers\nn_law = ConstantLaw{Float64}(Returns(4.))\n\n# Value depending on the glacier\nn_law = ConstantLaw{Float64}((sim, i, θ) -> sim.glaciers[i].n)\n\n# Learned value\nn_law = ConstantLaw{Float64}((sim, i, θ) -> θ.n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Container-api","page":"API","title":"Sleipnir.Container","text":"Container\n\nAbstract type that defines a container to be used in the PDE solver. It is useful to retrieve the simulation object when applying callback laws.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.CustomVJP-api","page":"API","title":"Sleipnir.CustomVJP","text":"CustomVJP <: VJPType\n\nIndicates that a law uses a custom-defined function for VJP computation. This is used when the VJP is provided manually rather than computed automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.DIVJP-api","page":"API","title":"Sleipnir.DIVJP","text":"DIVJP <: VJPType\n\nIndicates that a law uses the default VJP computation provided by DifferentiationInterface.jl. This is used when no custom VJP function is provided, and the Vector-Jacobian Product (VJP) is computed automatically using DifferentiationInterface.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.GenInputsAndApply-api","page":"API","title":"Sleipnir.GenInputsAndApply","text":"GenInputsAndApply{IN, F}\n\nGiven a tuple of AbstractInputs and a function f, returns a callable struct. This struct with_input_f can be evaluated as a function that generates the inputs and then applies the function's law with_input_f.f. It is for internal use only and it isn't exposed to the user.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer}-api","page":"API","title":"Sleipnir.Glacier1D","text":"function Glacier1D(;     rgiid::String = \"\",     climate::Union{Climate1D, Nothing} = nothing,     H₀::Vector{F} = Vector{Sleipnir.Float}([]),     S::Vector{F} = Vector{Sleipnir.Float}([]),     B::Vector{F} = Vector{Sleipnir.Float}([]),     V::Vector{F}= Vector{Sleipnir.Float}([]),     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     w₀::Union{Vector{F}, Nothing} = nothing,     λ::Union{Vector{F}, Nothing} = nothing,     slope::Vector{F} = Vector{Sleipnir.Float}([]),     distborder::Vector{F} = Vector{Sleipnir.Float}([]),     Coords::Dict{String, Vector{Float64}} = Dict{String, Vector{Float64}}(\"lon\" => [], \"lat\" => []),     Δx::F = 0,     Δy::F = 0,     nx::I = 0,     ny::I = 0,     ) where {F <: AbstractFloat, I <: Integer}\n\nConstructor for empty 2D Glacier object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Glacier2D-Tuple{Glacier2D}-api","page":"API","title":"Sleipnir.Glacier2D","text":"Glacier2D(\n    glacier::Glacier2D;\n    thicknessData::Union{<: ThicknessData, Nothing} = nothing,\n    velocityData::Union{<: SurfaceVelocityData, Nothing} = nothing,\n)\n\nCopies a Glacier2D object and updates the thickness and/or surface velocity data.\n\nArguments\n\nglacier::Glacier2D: The original glacier struct.\nthicknessData::Union{<: ThicknessData, Nothing}: Thickness data structure that is used to store the reference values. Default is nothing which keeps the existing thickness data.\nvelocityData::Union{<: SurfaceVelocityData, Nothing}: Surface velocity data structure that is used to store the reference values. Default is nothing which keeps the existing surface velocity data.\n\nReturns\n\nA Glacier2D object that is a copy of the original one with the thickness and/or surface velocity data updated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Glacier2D-Tuple{String, Sleipnir.Parameters}-api","page":"API","title":"Sleipnir.Glacier2D","text":"Glacier2D(\n    rgi_id::String,\n    params::Parameters;\n    masking::Union{Int, Nothing, BitMatrix} = 2,\n    smoothing=false\n)\n\nBuild glacier object for a given RGI ID and parameters.\n\nArguments\n\nrgi_id::String: The RGI ID of the glacier.\nparams::Parameters: A Parameters object containing simulation parameters.\nmasking::Union{Int, Nothing, BitMatrix}: Type of mask applied to the glacier to determine regions with no ice.\nWhen masking is an Int, the mask is based on the initial ice thickness H₀ and it is set to true for pixels outside at a distance of the glacier borders greater than the value of masking.\nWhen masking is set to nothing, the mask is set to a BitMatrix full of falses.\nWhen masking is a BitMatrix, this matrix is used for the mask.\nDefaults to 2.\nsmoothing::Bool=false: Optional; whether to apply smoothing to the initial ice thickness. Default is false.\ntest::Bool=false: Optional; test flag. Default is false.\n\nReturns\n\nglacier::Glacier2D: A Glacier2D object initialized with the glacier data.\n\nDescription\n\nThis function loads and initializes the glacier data for a given RGI ID. It retrieves the initial ice thickness conditions based on the specified source in the parameters, applies optional smoothing, and initializes the glacier's topographical and velocity data. The function also handles Mercator projection for the glacier coordinates and filters glacier borders in high elevations to avoid overflow problems.\n\nNotes\n\nThe function reverses the matrices for ice thickness, bedrock, and other data to match the required orientation.\nIf the Mercator projection includes latitudes larger than 80°, a warning is issued.\nIf the glacier data is missing, the function updates a list of missing glaciers and issues a warning.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Glacier2D-Union{Tuple{}, Tuple{SURFVELDATA}, Tuple{THICKDATA}, Tuple{I}, Tuple{F}} where {F<:AbstractFloat, I<:Integer, THICKDATA<:(Union{Nothing, var\"#s119\"} where var\"#s119\"<:ThicknessData), SURFVELDATA<:(Union{Nothing, var\"#s118\"} where var\"#s118\"<:SurfaceVelocityData)}-api","page":"API","title":"Sleipnir.Glacier2D","text":"Glacier2D(;\n    rgi_id::String = \"\",\n    name::String = \"\",\n    climate::Climate2D = nothing,\n    H₀::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    H_glathida::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    S::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    B::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    V::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    Vx::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    Vy::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    A::F = 0.0,\n    C::F = 0.0,\n    n::F = 0.0,\n    p::F = 0.0,\n    q::F = 0.0,\n    slope::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    dist_border::Matrix{F} = Matrix{Sleipnir.Float}([;;]),\n    mask::BitMatrix = BitMatrix([;;]),\n    Coords::Dict{String, Vector{Float64}} = Dict{String, Vector{Float64}}(\"lon\" => [], \"lat\" => []),\n    Δx::F = 0.0,\n    Δy::F = 0.0,\n    nx::I = 0,\n    ny::I = 0,\n    cenlon::F = NaN,\n    cenlat::F = NaN,\n    params_projection::Dict{String, Float64} = Dict{String, Float64}(),\n    thicknessData::THICKDATA = nothing,\n    velocityData::SURFVELDATA = nothing,\n) where {\n    F <: AbstractFloat,\n    I <: Integer,\n    THICKDATA <: Union{<: ThicknessData, Nothing},\n    SURFVELDATA <: Union{<: SurfaceVelocityData, Nothing},\n}\n\nConstructs a Glacier2D object with the given parameters, including default ones.\n\nArguments\n\nrgi_id::String: The RGI identifier for the glacier.\nname::String: The name of the glacier if available.\nclimate::Climate2D: The climate data associated with the glacier.\nH₀::Matrix{F}: Initial ice thickness matrix.\nH_glathida::Matrix{F}: Ice thickness matrix from GLATHIDA.\nS::Matrix{F}: Surface elevation matrix.\nB::Matrix{F}: Bed elevation matrix.\nV::Matrix{F}: Ice velocity magnitude matrix.\nVx::Matrix{F}: Ice velocity in the x-direction matrix.\nVy::Matrix{F}: Ice velocity in the y-direction matrix.\nA::F: Flow law parameter.\nC::F: Sliding law parameter.\nn::F: Flow law exponent.\np::F: Power law exponent associated to Weertman sliding law (Power associated to basal drag).\nq::F: Power law exponent associated to Weertman sliding law (Power associated to normal pressure).\nslope::Matrix{F}: Slope matrix.\ndist_border::Matrix{F}: Distance to border matrix.\nmask::BitMatrix: Boolean matrix representing the glacier mask, where true values indicate regions constrained by the mask (i.e., no-ice zones)\nCoords::Dict{String, Vector{Float64}}: Coordinates dictionary with keys \"lon\" and \"lat\".\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ncenlon::F: Central longitude of the glacier.\ncenlat::F: Central latitude of the glacier.\nparams_projection::Dict{String, Float64}: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.\nthicknessData::THICKDATA: Thickness data structure that is used to store the reference values.\nvelocityData::SURFVELDATA: Surface velocity data structure that is used to store the reference values.\n\nReturns\n\nA Glacier2D object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Glacier2D-api","page":"API","title":"Sleipnir.Glacier2D","text":"A mutable struct representing a 2D glacier. Notice that all fields can be empty by providing nothing as the default value.\n\n/!\\ WARNING /!\\ Glacier objects should not be constructed manually, but rather through the initialize_glaciers function.\n\nGlacier2D{F <: AbstractFloat, I <: Integer, CLIM <: Climate2D, THICKDATA <: Union{<: ThicknessData, Nothing}, SURFVELDATA <: Union{<: SurfaceVelocityData, Nothing}}\n\nFields\n\nrgi_id::String: The RGI (Randolph Glacier Inventory) identifier for the glacier.\nname::String: The name of the glacier if available.\nclimate::CLIM: The climate data associated with the glacier.\nH₀::Matrix{F}: Initial ice thickness matrix.\nH_glathida::Matrix{F}: Ice thickness matrix from the GLATHIDA dataset.\nS::Matrix{F}: Surface elevation matrix.\nB::Matrix{F}: Bedrock elevation matrix.\nV::Matrix{F}: Ice velocity magnitude matrix.\nVx::Matrix{F}: Ice velocity in the x-direction matrix.\nVy::Matrix{F}: Ice velocity in the y-direction matrix.\nA::F: Flow law parameter.\nC::F: Sliding law parameter.\nn::F: Flow law exponent.\np::F: Power law exponent associated to Weertman sliding law (Power associated to basal drag).\nq::F: Power law exponent associated to Weertman sliding law (Power associated to normal pressure).\nslope::Matrix{F}: Surface slope matrix.\ndist_border::Matrix{F}: Distance to the glacier border matrix.\nmask::BitMatrix: Boolean matrix representing the glacier mask, where true values indicate regions constrained by the mask (i.e., no-ice zones)\nCoords::Dict{String, Vector{Float64}}: Coordinates dictionary with keys as coordinate names and values as vectors of coordinates.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ncenlon::F: Longitude of the glacier center.\ncenlat::F: Latitude of the glacier center.\nparams_projection::Dict{String, Float64}: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.\nthicknessData::THICKDATA: Thickness data structure that is used to store the reference values.\nvelocityData::SURFVELDATA: Surface velocity data structure that is used to store the reference values.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.IntegratedTrajectoryMapping-api","page":"API","title":"Sleipnir.IntegratedTrajectoryMapping","text":"IntegratedTrajectoryMapping <: VelocityMapping\n\nIntegrated trajectory mapping. This mapping is closer to reality as it consists in integrating over time the instantaneous ice surface velocities along ice flow trajectories in a Lagrangian way. This integrated velocity is then compared to the velocity of the datacube. It has not been implemented yet but its computational cost will likely be expensive.\n\nFields\n\nspatialInterp::Symbol: The spatial interpolation to use to map the ice surface   velocity grid to the glacier grid. For the moment only :nearest is supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Law-api","page":"API","title":"Sleipnir.Law","text":"Law{T}(;\n    inputs = nothing,\n    f!, f_VJP_input! = nothing, f_VJP_θ! = nothing,\n    init_cache, callback_freq = nothing,\n    p_VJP! = nothing,\n    max_value = NaN, min_value = NaN, name = :unknown,\n) where{T}\n\nDefines a physical or empirical law applied to a glacier model that mutates an internal state T at each simulation time step.\n\nwarning: Warning\nThe type T must be mutable, since f! is expected to update cache::T in-place. Using an immutable type (like Float64) will silently fail or raise an error.\n\n# ❌ Will not work: Float64 is immutable, so cache .= ... has no effect\nLaw{Float64}(;\n    f! = (cache, _, _, t, θ) -> cache = θ.scale * sin(2π * t + θ.shift),\n    init_cache = (_, _, _) -> 0.0,\n)\n\n# ✅ Correct: using a 0-dimensional array allows in-place mutation\nLaw{Array{Float64, 0}}(;\n    f! = (cache, _, _, t, θ) -> cache .= θ.scale * sin(2π * t + θ.shift) + θ.bias,\n    init_cache = (_, _, _) -> zeros(),\n)\n\nArguments\n\nf!::Function: A function with signature f!(cache::T, simulation, glacier_idx, t, θ) that updates the internal state.   If inputs are provided, the function instead takes the form f!(cache::T, inputs, θ).\ninit_cache::Function: A function init_cache(simulation, glacier_idx, θ)::T that initializes the internal state for a given glacier.\ncallback_freq::Union{Nothing, Real, Period, Month}: Optional. If provided, the law is treated as a callback law and is only applied every callback_freq time units.   If callback_freq is set to zero, then the law is applied only once at the beginning of the simulation.   If callback_freq is set to nothing (default), then the law is applied at every iteration.   If callback_freq is provided as a Period or Month, it is converted to a float value in a yearly basis.\nf_VJP_input!: A function with signature (cache::T, simulation, glacier_idx, t, θ) that updates cache.vjp_inp which is the VJP with respect to the inputs.\nf_VJP_θ!: A function with signature (cache::T, simulation, glacier_idx, t, θ) that updates cache.vjp_θ which is the VJP with respect to the parameters θ.\np_VJP!: A function with signature (cache::T, vjpsPrepLaw, simulation, glacier_idx, t, θ) that performs the precomputation of the VJPs.\ninputs::Union{Nothing, Tuple{<:AbstractInput}}: Optional. Provides automatically generated inputs passed to f! at runtime.\nmax_value::Float64: Optional. The maximum value that the law can take, used for plotting and capping the function output.\nmin_value::Float64: Optional. The minimum value that the law can take, used for plotting and capping the function output.\nname::Symbol: A name for the law, used for identification and plotting.\n\nType Parameters\n\nT: The type of the internal state. Must be specified manually and should match the return type of init_cache.\n\nNotes\n\nRefer to the tutorials in the documentation for a complete description of the VJP options.\n\nExamples\n\n# A law applied at every timestep, storing a scalar value\nLaw{Array{Float64, 0}}(;\n    f! = (cache, _, _, t, θ) -> cache .= θ.scale * sin(2π * t + θ.shift) + θ.bias,\n    init_cache = (_, _, _) -> zeros(),\n)\n\n# A callback law applied once per month (assuming time in years)\nLaw{Array{Float64, 0}}(;\n    f! = (cache, _, _, t, θ) -> cache .= θ.scale * sin(2π * t + θ.shift) + θ.bias,\n    init_cache = (_, _, _) -> zeros(),\n    callback_freq = 1 / 12,\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.MatrixCache-api","page":"API","title":"Sleipnir.MatrixCache","text":"MatrixCache <: Cache\n\nA cache structure for storing a two-dimensional array of Float64 values along with their associated vector-Jacobian products (VJP). This is typically used for spatially varying laws. Fields:\n\nvalue::Array{Float64, 2}: The cached matrix.\nvjp_inp::Array{Float64, 2}: VJP with respect to inputs.\nvjp_θ::Vector{Float64}: VJP with respect to parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.MatrixCacheNoVJP-api","page":"API","title":"Sleipnir.MatrixCacheNoVJP","text":"MatrixCacheNoVJP <: Cache\n\nA mutable cache structure for storing a two-dimensional array of Float64 values. This is typically used for spatially varying laws. This struct is intended for use cases where the law is not differentiated, and hence the vector-Jacobian products (VJP) are not required. Fields:\n\nvalue::Array{Float64, 2}: The cached matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.MeanDateVelocityMapping-api","page":"API","title":"Sleipnir.MeanDateVelocityMapping","text":"MeanDateVelocityMapping <: VelocityMapping\n\nMean date velocity mapping. It is the most simple mapping one can build and it consists in taking the 2D vector field of ice velocity associated to a given mean date and compare it to the instantaneous ice surface velocity obtained from the ice flow model. It is valid only for ice surface velocities estimated from short time windows since the velocity can vary within this time window.\n\nFields\n\nspatialInterp::Symbol: The spatial interpolation to use to map the ice surface   velocity grid to the glacier grid. For the moment only :nearest is supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Model-api","page":"API","title":"Sleipnir.Model","text":"Model{IFM <: AbstractEmptyModel, MBM <: AbstractEmptyModel, MLM <: AbstractEmptyModel}\n\nA mutable struct that represents a model with three components: iceflow, mass balance, and machine learning.\n\nModel(\n    iceflow::IFM,\n    mass_balance::MBM,\n    machine_learning::MLM,\n) where {IFM <: AbstractEmptyModel, MBM <: AbstractEmptyModel, MLM <: AbstractEmptyModel}\n\nModel(;iceflow, mass_balance) = Model(iceflow, mass_balance, nothing)\n\nInitialize Model (no machine learning model).\n\nKeyword arguments\n\niceflow::IFM}: Represents the iceflow component, which is an instance of IFM.\nmass_balance::Union{MBM, Vector{MBM}}: Represents the mass balance component, which is an instance of MBM.\nmachine_learning::MLM: Represents the machine learning component, which is an instance of MLM.\n\nType Parameters\n\nIFM: A subtype of AbstractEmptyModel representing the type of the iceflow model.\nMBM: A subtype of AbstractEmptyModel representing the type of the mass balance model.\nMLM: A subtype of AbstractEmptyModel representing the type of the machine learning model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.ModelCache-api","page":"API","title":"Sleipnir.ModelCache","text":"ModelCache{IFC, MBC}\n\nCache struct that holds the internal state or memory buffers for the components of a Model.\n\nTypically used to store per-glacier preallocated buffers or intermediate results that persist across time steps during simulation.\n\nFields\n\niceflow::IFC: Cache associated with the iceflow model.\nmass_balance::MBC: Cache associated with the mass balance model.\n\nType Parameters\n\nIFC: Cache type for the iceflow model.\nMBC: Cache type for the mass balance model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.NullLaw-api","page":"API","title":"Sleipnir.NullLaw","text":"NullLaw <: AbstractLaw\n\nThis struct represents a law that is not used in the iceflow model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Parameters-Tuple{}-api","page":"API","title":"Sleipnir.Parameters","text":"Parameters(; physical::PhysicalParameters = PhysicalParameters(), simulation::SimulationParameters = SimulationParameters())\n\nConstructs a Parameters object with the given physical and simulation parameters.\n\nArguments\n\nphysical::PhysicalParameters: An instance of PhysicalParameters (default: PhysicalParameters()).\nsimulation::SimulationParameters: An instance of SimulationParameters (default: SimulationParameters()).\n\nReturns\n\nA Parameters object initialized with the provided physical and simulation parameters.\n\nNotes\n\nIf simulation.multiprocessing is enabled, multiprocessing is configured with the specified number of workers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Parameters-api","page":"API","title":"Sleipnir.Parameters","text":"mutable struct Parameters{PPHY <: AbstractEmptyParams, PSIM <: AbstractEmptyParams, PHY <: AbstractEmptyParams,\n    PSOL <: AbstractEmptyParams, PUDE <: AbstractEmptyParams, PINV <: AbstractEmptyParams}\n\nA mutable struct that holds various parameter sets for different aspects of a simulation or model.\n\nFields\n\nphysical::PPHY: Physical parameters.\nsimulation::PSIM: Simulation parameters.\nhyper::PHY: Hyperparameters.\nsolver::PSOL: Solver parameters.\nUDE::PUDE: Universal Differential Equation (UDE) parameters.\ninversion::PINV: Inversion parameters.\n\nType Parameters\n\nPPHY: Type of the physical parameters, must be a subtype of AbstractEmptyParams.\nPSIM: Type of the simulation parameters, must be a subtype of AbstractEmptyParams.\nPHY: Type of the hyperparameters, must be a subtype of AbstractEmptyParams.\nPSOL: Type of the solver parameters, must be a subtype of AbstractEmptyParams.\nPUDE: Type of the UDE parameters, must be a subtype of AbstractEmptyParams.\nPINV: Type of the inversion parameters, must be a subtype of AbstractEmptyParams.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.PhysicalParameters","text":"Initialize the physical parameters of a model.\n\nPhysicalParameters(;\n    ρ::Float64 = 900.0,\n    g::Float64 = 9.81,\n    ϵ::Float64 = 1e-10,\n    η₀::F = 1.0,\n    maxA::Float64 = 8e-17,\n    minA::Float64 = 8.5e-20,\n    maxC::Float64 = 8e-17, # TODO: to be revised\n    minC::Float64 = 8.5e-20,\n    maxTlaw::Float64 = 1.0,\n    minTlaw::Float64 = -25.0,\n    noise_A_magnitude::Float64 = 5e-18\n    )\n\nKeyword arguments\n\n- `ρ`: Ice density\n- `g`: Gravitational acceleration.\n- `ϵ`: Regularization used in the square root of norms for AD numerical stability.\n- `η₀`: Factor to cap surface elevation differences with the upstream ice thickness to impose boundary condition in the iceflow equation\n- `maxA`: Maximum value for `A` (Glen's coefficient)\n- `minA`: Minimum value for `A` (Glen's coefficient)\n- `maxC`: Maximum value of sliding coefficient `C`\n- `minC`: Minimum value of sliding coefficient `C`\n- `maxTlaw`: Maximum value of Temperature used in simulations on fake law\n- `minTlaw`: Minimum value of Temperature used in simulations on fake law\n- `noise_A_magnitude`: Magnitude of noise added to A\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.PhysicalParameters-api","page":"API","title":"Sleipnir.PhysicalParameters","text":"A structure representing physical parameters used in simulations.\n\nPhysicalParameters{F <: AbstractFloat}\n\nFields\n\nρ::F: Density of ice.\ng::F: Gravitational acceleration.\nϵ::F: Regularization used in the square root of norms for AD numerical stability.\nη₀::F: Initial viscosity.\nmaxA::F: Maximum A.\nminA::F: Minimum A.\nmaxC::F: Maximum C.\nminC::F: Minimum C.\nmaxTlaw::F: Maximum temperature according to some law.\nminTlaw::F: Minimum temperature according to some law.\nnoise_A_magnitude::F: Magnitude of noise in A.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G<:AbstractGlacier, F<:AbstractFloat, IF<:AbstractModel, I<:Integer}-api","page":"API","title":"Sleipnir.Results","text":"Results(glacier::G, ifm::IF;\n    rgi_id::String = glacier.rgi_id,\n    H::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    H_glathida::Matrix{F} = glacier.H_glathida,\n    H_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    S::Matrix{F} = zeros(Sleipnir.Float, size(ifm.S)),\n    B::Matrix{F} = zeros(Sleipnir.Float, size(glacier.B)),\n    V::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vx::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vy::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    V_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vx_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    Vy_ref::Vector{Matrix{F}} = Vector{Matrix{Sleipnir.Float}}([[;;]]),\n    date_Vref::Vector{F} = Vector{Sleipnir.Float}([]),\n    date1_Vref::Vector{F} = Vector{Sleipnir.Float}([]),\n    date2_Vref::Vector{F} = Vector{Sleipnir.Float}([]),\n    Δx::F = glacier.Δx,\n    Δy::F = glacier.Δy,\n    lon::F = glacier.cenlon,\n    lat::F = glacier.cenlat,\n    nx::I = glacier.nx,\n    ny::I = glacier.ny,\n    t::Vector{F} = Vector{Sleipnir.Float}([]),\n    tspan::Tuple{F, F} = (NaN, NaN),\n) where {G <: AbstractGlacier, F <: AbstractFloat, IF <: AbstractModel, I <: Integer}\n\nConstruct a Results object for a glacier simulation.\n\nArguments\n\nglacier::G: The glacier object, subtype of AbstractGlacier.\nifm::IF: The model object, subtype of AbstractModel.\nrgi_id::String: The RGI identifier for the glacier. Defaults to glacier.rgi_id.\nH::Vector{Matrix{F}}: Ice thickness matrices. Defaults to an empty vector.\nH_glathida::Matrix{F}: Ice thickness from GlaThiDa. Defaults to glacier.H_glathida.\nH_ref::Vector{Matrix{F}}: Reference ice thickness. Defaults to an empty vector.\nS::Matrix{F}: Surface elevation matrix. Defaults to a zero matrix of the same size as ifm.S.\nB::Matrix{F}: Bed elevation matrix. Defaults to a zero matrix of the same size as glacier.B.\nV::Vector{Matrix{F}}: Velocity magnitude matrix. Defaults to an empty vector.\nVx::Vector{Matrix{F}}: Velocity in the x-direction matrix. Defaults to an empty vector.\nVy::Vector{Matrix{F}}: Velocity in the y-direction matrix. Defaults to an empty vector.\nV_ref::Vector{Matrix{F}}: Reference velocity magnitude matrix. Defaults to an empty vector.\nVx_ref::Vector{Matrix{F}}: Reference velocity in the x-direction matrix. Defaults to an empty vector.\nVy_ref::Vector{Matrix{F}}: Reference velocity in the y-direction matrix. Defaults to an empty vector.\ndate_Vref::Vector{F}: Date of velocity observation (mean of date1 and date2). Defaults to an empty vector.\ndate1_Vref::Vector{F}: First date of velocity acquisition. Defaults to an empty vector.\ndate2_Vref::Vector{F}: Second date of velocity acquisition. Defaults to an empty vector.\nΔx::F: Grid spacing in the x-direction. Defaults to glacier.Δx.\nΔy::F: Grid spacing in the y-direction. Defaults to glacier.Δy.\nlon::F: Longitude of the glacier grid center. Defaults to glacier.cenlon.\nlat::F: Latitude of the glacier grid center. Defaults to glacier.cenlat.\nnx::I: Number of grid points in the x-direction. Defaults to glacier.nx.\nny::I: Number of grid points in the y-direction. Defaults to glacier.ny.\ntspan::Tuple(F, F): Timespan of the simulation.\nθ::Union{Nothing, ComponentArray{F}}: Model parameters. Defaults to nothing.\nloss::Union{Nothing, Vector{F}}: Loss values. Defaults to nothing.\n\nReturns\n\nresults::Results: A Results object containing the simulation results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.Results-api","page":"API","title":"Sleipnir.Results","text":"mutable struct Results{F <: AbstractFloat, I <: Integer}\n\nA mutable struct to store the results of simulations.\n\nFields\n\nrgi_id::String: Identifier for the RGI (Randolph Glacier Inventory).\nH::Vector{Matrix{F}}: Vector of matrices representing glacier ice thickness H over time.\nH_glathida::Matrix{F}: Optional matrix for Glathida ice thicknesses.\nH_ref::Vector{Matrix{F}}: Reference data for ice thickness.\nS::Matrix{F}: Glacier surface altimetry.\nB::Matrix{F}: Glacier bedrock.\nV::Matrix{F}: Glacier ice surface velocities.\nVx::Matrix{F}: x-component of the glacier ice surface velocity V.\nVy::Matrix{F}: y-component of the glacier ice surface velocity V.\nV_ref::Matrix{F}: Reference data for glacier ice surface velocities V.\nVx_ref::Matrix{F}: Reference data for the x-component of the glacier ice surface velocity Vx.\nVy_ref::Matrix{F}: Reference data for the y-component of the glacier ice surface velocity Vy.\ndate_Vref::Vector{F}: Date of velocity observation (mean of date1 and date2).\ndate1_Vref::Vector{F}: First date of velocity acquisition.\ndate2_Vref::Vector{F}: Second date of velocity acquisition.\nΔx::F: Grid spacing in the x-direction.\nΔy::F: Grid spacing in the y-direction.\nlon::F: Longitude of the glacier grid center.\nlat::F: Latitude of the glacier grid center.\nnx::I: Number of grid points in the x-direction.\nny::I: Number of grid points in the y-direction.\ntspan::Vector{F}: Time span of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.ScalarCache-api","page":"API","title":"Sleipnir.ScalarCache","text":"ScalarCache <: Cache\n\nA cache structure for storing a scalar value as a zero-dimensional array of Float64 along with their associated vector-Jacobian products (VJP). This is typically used for constant per glacier laws. Fields:\n\nvalue::Array{Float64, 0}: The cached scalar value.\nvjp_inp::Array{Float64, 0}: VJP with respect to inputs.\nvjp_θ::Vector{Float64}: VJP with respect to parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.ScalarCacheNoVJP-api","page":"API","title":"Sleipnir.ScalarCacheNoVJP","text":"ScalarCacheNoVJP <: Cache\n\nA mutable cache structure for storing a scalar value as a zero-dimensional array of Float64. This is typically used for constant per glacier laws. This struct is intended for use cases where the law is not differentiated, and hence the vector-Jacobian products (VJP) are not required. Fields:\n\nvalue::Array{Float64, 0}: The cached scalar value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.Simulation-api","page":"API","title":"Sleipnir.Simulation","text":"Simulation\n\nAn abstract type representing a generic simulation. This type is intended to be  subclassed by specific simulation types to provide a common interface and shared  functionality for all simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{VM}, Tuple{F}, Tuple{I}} where {I<:Integer, F<:AbstractFloat, VM<:Sleipnir.VelocityMapping}-api","page":"API","title":"Sleipnir.SimulationParameters","text":"Constructor for SimulationParameters type, including default values.\n\nSimulationParameters(;\n    use_MB::Bool = true,\n    use_iceflow::Bool = true,\n    plots::Bool = true,\n    use_velocities::Bool = true,\n    f_surface_velocity_factor::F = 1.0,\n    overwrite_climate::Bool = false,\n    use_glathida_data::Bool = false,\n    tspan::Tuple{F, F} = (2010.0, 2015.0),\n    step_MB::F = 1/12,\n    multiprocessing::Bool = true,\n    workers::I = 4,\n    working_dir::String = \"\",\n    test_mode::Bool = false,\n    rgi_paths::Dict{String, String} = Dict{String, String}(),\n    ice_thickness_source::String = \"Farinotti19\",\n    mapping::VM = MeanDateVelocityMapping(),\n    gridScalingFactor::I = 1,\n) where {I <: Integer, F <: AbstractFloat, VM <: VelocityMapping}\n\nKeyword arguments\n\nuse_MB::Bool: Whether to use mass balance (default: true).\nuse_iceflow::Bool: Whether to use ice flow (default: true).\nplots::Bool: Whether to generate plots (default: true).\nuse_velocities::Bool: Whether to calculate velocities (default: true).\nf_surface_velocity_factor::F: Numerical factor representing the ratio between depth integrated ice velocity and surface velocity (default: 1.0).\noverwrite_climate::Bool: Whether to overwrite climate data (default: false).\nuse_glathida_data::Bool: Whether to use GLATHIDA data (default: false).\nfloat_type::DataType: Data type for floating point numbers (default: Float64).\nint_type::DataType: Data type for integers (default: Int64).\ntspan::Tuple{F, F}: Time span for the simulation (default: (2010.0, 2015.0)).\nstep_MB::F: Time step for the MB simulation (default: 1/12).\nmultiprocessing::Bool: Whether to use multiprocessing (default: true).\nworkers::I: Number of workers for multiprocessing (default: 4).\nworking_dir::String: Working directory for the simulation (default: \"\").\ntest_mode::Bool: Whether to run in test mode (default: false).\nrgi_paths::Dict{String, String}: Dictionary of RGI paths (default: Dict{String, String}()).\nice_thickness_source::String: Source of ice thickness data, either \"Millan22\" or \"Farinotti19\" (default: \"Farinotti19\").\nmapping::VM: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.\ngridScalingFactor::I: Grid downscaling factor, used to speed-up the tests.   Default value is 1 which means no downscaling is applied.\n\nReturns\n\nsimulation_parameters: A new SimulationParameters object.\n\nThrows\n\nAssertionError: If ice_thickness_source is not \"Millan22\" or \"Farinotti19\".\n\nNotes\n\nIf the global variable ODINN_OVERWRITE_MULTI is set to true, multiprocessing is   is enabled in any case and the number of workers specified in the simulation   parameters must correspond to the number of processes with which Julia has been   started. This is to allow the documentation to build successfully in ODINN as we   cannot change the number of process in the CI.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.SimulationParameters-api","page":"API","title":"Sleipnir.SimulationParameters","text":"A structure to hold simulation parameters for a simulation in ODINN.\n\nstruct SimulationParameters{I <: Integer, F <: AbstractFloat, VM <: VelocityMapping} <: AbstractParameters\n\nFields\n\nuse_MB::Bool: Flag to indicate whether mass balance should be used.\nuse_iceflow::Bool: Flag to indicate whether ice flow should be used.\nplots::Bool: Flag to indicate whether plots should be generated.\nuse_velocities::Bool: Flag to indicate whether velocities should be calculated.\nf_surface_velocity_factor::F: Numerical factor representing the ratio between depth integrated ice velocity and surface velocity.\noverwrite_climate::Bool: Flag to indicate whether to overwrite climate data.\nuse_glathida_data::Bool: Flag to indicate whether to use GLATHIDA data.\ntspan::Tuple{F, F}: Time span for the simulation.\nstep_MB::F: Time step for the MB simulation.\nmultiprocessing::Bool: Flag to indicate whether multiprocessing should be used.\nworkers::I: Number of workers for multiprocessing.\nworking_dir::String: Directory for working files.\ntest_mode::Bool: Flag to indicate whether to run in test mode.\nrgi_paths::Dict{String, String}: Dictionary of RGI paths.\nice_thickness_source::String: Source of ice thickness data.\nmapping::VM: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.\ngridScalingFactor::I: Grid downscaling factor, used to speed-up the tests.   Default value is 1 which means no downscaling is applied.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.SurfaceVelocityData","text":"Constructs SurfaceVelocityData using data from Rabatel et. al (2023) with the given parameters, including default ones.\n\nfunction SurfaceVelocityData(;     x::Union{Vector{F}, Nothing} = nothing,     y::Union{Vector{F}, Nothing} = nothing,     lat::Union{Vector{F}, Nothing} = nothing,     lon::Union{Vector{F}, Nothing} = nothing,     vx::Union{Vector{Matrix{F}}, Nothing} = nothing,     vy::Union{Vector{Matrix{F}}, Nothing} = nothing,     vabs::Union{Vector{Matrix{F}}, Nothing} = nothing,     vxerror::Union{Vector{F}, Nothing} = nothing,     vyerror::Union{Vector{F}, Nothing} = nothing,     vabserror::Union{Vector{F}, Nothing} = nothing,     date::Union{Vector{DateTime}, Nothing} = nothing,     date1::Union{Vector{DateTime}, Nothing} = nothing,     date2::Union{Vector{DateTime}, Nothing} = nothing,     dateerror::Union{Vector{Day}, Vector{Millisecond}, Nothing} = nothing,     flag::Union{BitMatrix, Nothing} = nothing,     isGridGlacierAligned::Bool = false, ) where {F <: AbstractFloat}\n\nConstructor for ice surface velocity data based on Rabatel et. al (2023).\n\nImportant remarks:\n\nVelocities values are reported in m/yr. Positive velocities correspond to the direction of increasing index of the glacier.\n\nWhen the glacier is oriented in east-west and south-north (see latitude and coordinate ordering), positive velocities of the ice surface velocity correspond to positive east-west and south-north velocity component.\n\nThe error in velocity is unique per timestamp, rather than being pixel distributed.\nThe error in the absolute velocities vabs_error is overestimated.\n\nReferences:     - Rabatel, A., Ducasse, E., Millan, R. & Mouginot, J.     Satellite-Derived Annual Glacier Surface Flow Velocity Products for the European Alps,     2015–2021.     Data 8, 66 (2023).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.SurfaceVelocityData-api","page":"API","title":"Sleipnir.SurfaceVelocityData","text":"A mutable struct representing a surface velocity data. Notice that all fields can be empty by providing nothing as the default value.\n\nSurfaceVelocityData{F <: AbstractFloat} <: AbstractData\n\nFields\n\nx::Union{Vector{F}, Nothing}: Easting of observation.\ny::Union{Vector{F}, Nothing}: Northing of observation.\nlat::Union{Vector{F}, Nothing}: Latitude of observation.\nlon::Union{Vector{F}, Nothing}: Longitude of observation.\nvx::Union{Vector{Matrix{F}}, Nothing}: x / longitudinal component of surface velocity. Positive velocities correspond to the direction of increasing index of the glacier x-coordinate.\nvy::Union{Vector{Matrix{F}}, Nothing}: y / latitudinal component of surface velocity. Positive velocities correspond to the direction of increasing index of the glacier y-coordinate.\nvabs::Union{Vector{Matrix{F}}, Nothing}: Absolute ice surface velocity.\nvx_error::Union{Vector{F}, Nothing}: Error in vx\nvy_error::Union{Vector{F}, Nothing}: Error in vy\nvabs_error::Union{Vector{F}, Nothing}: Error in vabs.\ndate::Union{Vector{DateTime}, Nothing}: Date of observation (mean of date1 and date2)\ndate1::Union{Vector{DateTime}, Nothing}: First date of acquisition.\ndate2::Union{Vector{DateTime}, Nothing}: Second date of acquisition.\ndate_error::Union{Vector{Day}, Vector{Millisecond}, Nothing}: Error in date.\nflag::Union{BitMatrix, Nothing}: Flag indicating whether a pixel is considered as reliable or not.\nisGridGlacierAligned::Bool: Whether the data have been gridded to the glacier grid or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.ThicknessData-api","page":"API","title":"Sleipnir.ThicknessData","text":"Simple time series of ice thickness data to test transient inversion\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.VJPType-api","page":"API","title":"Sleipnir.VJPType","text":"VJPType\n\nAbstract type representing the mode of Vector-Jacobian Product (VJP) computation used in a law. Subtypes of VJPType define how the VJP is evaluated (e.g., custom or using DifferentiationInterface.jl).\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.VelocityMapping-api","page":"API","title":"Sleipnir.VelocityMapping","text":"VelocityMapping\n\nAbstract type representing the mapping to use in order to map the ice velocity products onto the glacier grid. It contains all needed information to build both the spatial projection, and how to interpolate the data in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sleipnir.DummyClimate2D-Union{Tuple{}, Tuple{F}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.DummyClimate2D","text":"DummyClimate2D(;\n    longterm_temps::Vector{F} = []\n) where {F <: AbstractFloat}\n\nDummy climate initialization for very specific use cases where we don't have climate data and we need to build a minimalistic climate with only a few data. For the moment it supports only the initialization of the long term temperatures. It returns a minimalistic Climate2D instance.\n\nArguments:\n\nlongterm_temps::Vector{F}: Long term temperatures.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.ReverseUTMercator-Union{Tuple{F}, Tuple{F, F}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.ReverseUTMercator","text":"ReverseUTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0, zone::Union{Nothing, Int}=nothing, hemisphere=nothing) where {F <: AbstractFloat}\n\nTransverse Mercator Projection. This function reprojects latitude/longitude into northing/easting coordinates.\n\nKeyword arguments\n\n- `k`: scale factor of the projection\n- `cenlon`: Central longitude used in the projection\n- `cenlat`: Central latitude used in the projection\n- `x0`: Shift in easting\n- `y0`: Shift in northing\n- `zone` : Zone of the projection\n- `hemisphere`: Either :north or :south\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.UTMercator","text":"UTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0, zone::Union{Nothing, Int}=nothing, hemisphere=nothing) where {F <: AbstractFloat}\n\nTransverse Mercator Projection. This function reprojects northing/easting coordinates into latitude/longitude.\n\nKeyword arguments\n\n- `k`: scale factor of the projection\n- `cenlon`: Central longitude used in the projection\n- `cenlat`: Central latitude used in the projection\n- `x0`: Shift in easting\n- `y0`: Shift in northing\n- `zone` : Zone of the projection\n- `hemisphere`: Either :north or :south\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_all_callback_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api","page":"API","title":"Sleipnir.apply_all_callback_laws!","text":"apply_all_callback_laws!(model::AbstractModel, cache, simulation, glacier_idx, t, θ)\n\nThis function is a placeholder and must be implemented for your custom model type.\n\nIt is intended to apply all callback laws in the simulation to update the model cache for a given glacier at time t with parameters θ. By default, calling this function will throw an error to indicate that the user should provide their own implementation tailored to their model.\n\nArguments\n\nmodel::AbstractModel: The model instance.\ncache: The cache object storing state variables.\nsimulation: The simulation context.\nglacier_idx: Index identifying the glacier.\nt: The current simulation time.\nθ: The parameter vector.\n\nThrows\n\nAlways throws an error: \"This function should not be called. Implement apply_all_callback_laws! for your own model.\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_all_non_callback_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api","page":"API","title":"Sleipnir.apply_all_non_callback_laws!","text":"apply_all_non_callback_laws!(model::AbstractModel, cache, simulation, glacier_idx, t, θ)\n\nThis function is a placeholder and must be implemented for your custom model type.\n\nIt is intended to apply all non-callback laws in the simulation to update the model cache for a given glacier at time t with parameters θ. By default, calling this function will throw an error to indicate that the user should provide their own implementation tailored to their model.\n\nArguments\n\nmodel::AbstractModel: The model instance.\ncache: The cache object storing state variables.\nsimulation: The simulation context.\nglacier_idx: Index identifying the glacier.\nt: The current simulation time.\nθ: The parameter vector.\n\nThrows\n\nAlways throws an error: \"This function should not be called. Implement apply_all_non_callback_laws! for your own model.\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_t_cumul_grad!-Union{Tuple{F}, Tuple{Climate2Dstep, Matrix{F}}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.apply_t_cumul_grad!","text":"apply_t_cumul_grad!(climate_2D_step::Climate2Dstep, S::Matrix{F}) where {F <: AbstractFloat}\n\nApply temperature and precipitation gradients based on the positive degree day (PDD) and on the elevation matrix S to the climate data in climate_2D_step.\n\nArguments\n\nclimate_2D_step::Climate2Dstep: The climate data structure containing temperature, PDD, gradients, and reference height.\nS::Matrix{F}: A matrix of elevations.\n\nDescription\n\nThis function updates the temperature and PDD fields in climate_2D_step by applying the respective gradients based on the difference between the elevation matrix S and the reference height. Negative PDD values are cropped to zero. Additionally, the function adjusts the rain and snow fractions based on the updated temperature values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}-api","page":"API","title":"Sleipnir.apply_t_grad!","text":"apply_t_grad!(climate::RasterStack, dem::Raster)\n\nApply temperature gradients to the climate data based on the digital elevation model (DEM).\n\nArguments\n\nclimate::RasterStack: A RasterStack object containing climate data, including temperature and gradient information.\ndem::Raster: A Raster object representing the digital elevation model (DEM) data.\n\nDescription\n\nThis function adjusts the temperature data in the climate object by applying the temperature gradients. The adjustment is based on the difference between the mean elevation from the DEM data and a reference height specified in the metadata of the climate object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.block_average-Union{Tuple{F}, Tuple{Matrix{F}, Int64}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.block_average","text":"block_average(mat::Matrix{F}, n::Int) where {F <: AbstractFloat}\n\nDownsamples a matrix by averaging non-overlapping n x n blocks. Returns a matrix of the block-averaged values with size (div(X, n), div(Y, n)) where (X, Y) = size(mat).\n\nArguments\n\nmat::Matrix{F}: Input 2D matrix.\nn::Int: Block size for downsampling. Both matrix dimensions must be divisible by n.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.block_average_pad_edge-Union{Tuple{F}, Tuple{Matrix{F}, Int64}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.block_average_pad_edge","text":"block_average_pad_edge(mat::Matrix{F}, n::Int) where {F <: AbstractFloat}\n\nDownsamples a matrix by averaging n x n blocks, using edge-replication padding when the matrix dimensions are not divisible by n. Edge padding replicates the last row/column values to expand the matrix so that both dimensions are divisible by n. Returns a matrix of averaged values with size (ceil(Int, X/n), ceil(Int, Y/n)).\n\nArguments\n\nmat::Matrix{F}: Input 2D matrix.\nn::Int: Block size for downsampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.build_affect-Tuple{AbstractLaw, Any, Any, Any}-api","page":"API","title":"Sleipnir.build_affect","text":"build_affect(law::AbstractLaw, cache, glacier_idx, θ)\n\nReturn a !-style function suitable for use in a callback, which applies the given law to update the cache for a specific glacier and parameters θ, using the simulation time.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.combine_velocity_data-Tuple{Any}-api","page":"API","title":"Sleipnir.combine_velocity_data","text":"combine_velocity_data(refVelocities; merge=false)\n\nCombine multiple ice surface velocity datasets into a single SurfaceVelocityData object.\n\nArguments\n\nrefVelocities::Vector{SurfaceVelocityData}: A vector of ice surface velocity datasets to combine. Each element must have the same grid alignment (isGridGlacierAligned must be true for all).\nmerge::Bool=false: If true, velocities with the same date are averaged, and corresponding date ranges (date1, date2) are reduced to their min/max. If false, data are simply concatenated.\n\nReturns\n\nSurfaceVelocityData: A single object containing the combined velocity data, including vx, vy, vabs and their associated errors, as well as coordinate (x, y, lat, lon) and date information. The isGridGlacierAligned field reflects whether all input datasets were aligned.\n\nNotes\n\nThe function asserts that all input datasets are aligned on the same grid.\nWhen merge=true, velocities and errors are averaged over datasets sharing the same date.\nUses nanmean for averaging to handle missing data.\ndate_error is set to nothing when merging.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.create_results-Union{Tuple{F}, Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any, Vector{F}}} where {SIM<:Simulation, I<:Integer, F<:AbstractFloat}-api","page":"API","title":"Sleipnir.create_results","text":"create_results(\n    simulation::SIM,\n    glacier_idx::I,\n    solution,\n    tstops::Vector{F};\n    processVelocity::Union{Nothing, Function} = nothing,\n) where {SIM <: Simulation, I <: Integer}\n\nCreate a Results object from a given simulation and solution.\n\nArguments\n\nsimulation::SIM: The simulation object of type Simulation.\nglacier_idx::I: The index of the glacier within the simulation.\nsolution: The solution object containing all the steps including intermediate ones.\ntstops::Vector{F}: The list of time steps to use to construct the results.\nprocessVelocity::Union{Nothing, Function}=nothing: Post processing function to map the ice thickness to the surface velocity. It is called before creating the results. It takes as inputs simulation, ice thickness (matrix) and the associated time and returns 3 variables Vx, Vy, V which are all matrix. Defaults is nothing which means no post processing is applied.\n\nReturns\n\nresults: A Results object containing the processed simulation data.\n\nDetails\n\nThe function processes the solution to select the last value for each time step. It then constructs a Results object containing various attributes from the simulation and the iceflow model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}-api","page":"API","title":"Sleipnir.downscale_2D_climate!","text":"downscale_2D_climate!(glacier::Glacier2D)\n\nUpdate the 2D climate structure for a given glacier by downscaling climate data.\n\nArguments\n\nglacier::Glacier2D: The glacier object containing the climate data to be downscaled.\n\nDescription\n\nThis function updates the 2D climate structure of the given glacier by:\n\nUpdating the temperature, PDD (Positive Degree Days), snow, and rain fields in the 2D climate step with the corresponding values from the climate step.\nUpdating the gradients and average gradients in the 2D climate step.\nApplying temperature gradients and computing the snow/rain fraction for the selected period by reprojecting the current S with the RasterStack structure.\n\nNotes\n\nThe function modifies the glacier object in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.downscale_2D_climate-Tuple{Sleipnir.ClimateStep, Matrix{<:AbstractFloat}, Dict}-api","page":"API","title":"Sleipnir.downscale_2D_climate","text":"downscale_2D_climate(climate_step::ClimateStep, S::Matrix{<: AbstractFloat}, Coords::Dict)\n\nDownscales climate data to a 2D grid based on the provided matrix of surface elevation and coordinates.\n\nArguments\n\nclimate_step::ClimateStep: A struct containing climate data for a specific time step. Expected fields are:\n\"avg_temp\": Average temperature.\n\"temp\": Temperature.\n\"prcp\": Precipitation.\n\"gradient\": Temperature gradient.\n\"avg_gradient\": Average temperature gradient.\n\"ref_hgt\": Reference height.\nS::Matrix{<: AbstractFloat}: Surface elevation data.\nCoords::Dict: A dictionary with keys \"lon\" and \"lat\" for longitude and latitude coordinates.\n\nReturns\n\nClimate2Dstep: A Climate2Dstep object containing the downscaled climate data with fields:\ntemp: 2D array of temperature.\nPDD: 2D array of positive degree days.\nsnow: 2D array of snow precipitation.\nrain: 2D array of rain precipitation.\ngradient: Temperature gradient.\navg_gradient: Average temperature gradient.\nx: Longitude coordinates.\ny: Latitude coordinates.\nref_hgt: Reference height.\n\nDescription\n\nThis function creates dummy 2D arrays based on the provided surface elevation data and applies the climate step data to these arrays. It then constructs a Climate2Dstep object with the downscaled climate data and applies temperature gradients to compute the snow/rain fraction for the selected period.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.emptyPrepVJP-NTuple{6, Any}-api","page":"API","title":"Sleipnir.emptyPrepVJP","text":"emptyPrepVJP(cache, vjpPrep, simulation, glacier_idx, t, θ)\nemptyPrepVJPWithInputs(cache, vjpPrep, inputs, θ)\n\nFunction that defines an empty !-style function for the preparation of the VJPs. The two methods define the two possible signatures for the function that updates the cache in-place. Trying to apply this function will yield an error. It is for internal use only and it isn't exposed to the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.emptyVJP-NTuple{5, Any}-api","page":"API","title":"Sleipnir.emptyVJP","text":"emptyVJP(cache, simulation, glacier_idx, t, θ)\nemptyVJPWithInputs(cache, inputs, θ)\n\nFunction that defines an empty !-style function for the VJPs. The two methods define the two possible signatures for the function that updates the cache in-place. It is for internal use only and it isn't exposed to the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.fake_interpolated_datacube-Tuple{}-api","page":"API","title":"Sleipnir.fake_interpolated_datacube","text":"fake_interpolated_datacube()\n\nCreate a fake datacube of ice surface velocity time series. It corresponds to the interpolated data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.fake_multi_datacube-Tuple{}-api","page":"API","title":"Sleipnir.fake_multi_datacube","text":"fake_multi_datacube()\n\nCreate a fake datacube of ice surface velocity time series. It corresponds to the filtered multi source data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.fillNaN!-api","page":"API","title":"Sleipnir.fillNaN!","text":"fillNaN!(A::AbstractArray, fill::Number=zero(eltype(A)))\n\nReplace all NaN values in the array A with the specified fill value.\n\nArguments\n\nA::AbstractArray: The array in which NaN values will be replaced.\nfill::Number: The value to replace NaN with. Defaults to zero(eltype(A)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.fillNaN-api","page":"API","title":"Sleipnir.fillNaN","text":"fillNaN(A::AbstractArray, fill::Number=zero(eltype(A)))\n\nReplace all NaN values in the array A with the specified fill value.  If no fill value is provided, it defaults to the zero value of the element type of A.\n\nArguments\n\nA::AbstractArray: The input array that may contain NaN values.\nfill::Number: The value to replace NaNs with. Defaults to zero(eltype(A)).\n\nReturns\n\nAn array of the same type and shape as A, with all NaN values replaced by fill.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.fillZeros!-api","page":"API","title":"Sleipnir.fillZeros!","text":"fillZeros!(A::AbstractArray, fill::Number=NaN)\n\nReplace all zero elements in the array A with the specified fill value.\n\nArguments\n\nA::AbstractArray: The array in which to replace zero elements.\nfill::Number: The value to replace zero elements with. Defaults to NaN.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.fillZeros-api","page":"API","title":"Sleipnir.fillZeros","text":"fillZeros(A::AbstractArray, fill::Number=NaN) -> AbstractArray\n\nReplace all zero elements in the array A with the specified fill value.\n\nArguments\n\nA::AbstractArray: The input array in which zero elements are to be replaced.\nfill::Number: The value to replace zero elements with. Defaults to NaN.\n\nReturns\n\nAbstractArray: A new array with zero elements replaced by the fill value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.filter_missing_glaciers!-Tuple{Vector{String}, Sleipnir.Parameters}-api","page":"API","title":"Sleipnir.filter_missing_glaciers!","text":"filter_missing_glaciers!(rgi_ids::Vector{String}, params::Parameters)\n\nFilter out glaciers that cannot be processed from the given list of RGI IDs.\n\nArguments\n\nrgi_ids::Vector{String}: A vector of RGI IDs representing glaciers.\nparams::Parameters: A Parameters object containing simulation parameters.\n\nDescription\n\nThis function filters out glaciers from the provided rgi_ids list based on two criteria:\n\nGlaciers that are marked as level 2 in the RGI statistics CSV file.\nGlaciers listed in the missing_glaciers.jld2 file located in the params.simulation.working_dir directory.\n\nNotes\n\nThe RGI statistics CSV file is downloaded from a remote server.\nIf the missing_glaciers.jld2 file is not available, a warning is logged and the function skips this filtering step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.generate_raw_climate_files-Tuple{String, SimulationParameters}-api","page":"API","title":"Sleipnir.generate_raw_climate_files","text":"generate_raw_climate_files(rgi_id::String, simparams::SimulationParameters)\n\nGenerate raw climate files for a given RGI (Randolph Glacier Inventory) ID and simulation parameters.\n\nArguments\n\nrgi_id::String: The RGI ID for which to generate raw climate files.\nsimparams::SimulationParameters: The simulation parameters containing the time span and RGI paths.\n\nDescription\n\nThis function generates raw climate files for a specified RGI ID if they do not already exist. It retrieves raw climate data, ensures the desired period is covered, crops the data to the desired time period, and saves the raw climate data to disk.\n\nDetails\n\nConstructs the path to the RGI directory using the provided rgi_id and simparams.\nChecks if the raw climate file for the specified time span already exists.\nIf the file does not exist:\nRetrieves the raw climate data.\nEnsures the desired period is covered by the climate data.\nCrops the climate data to the desired time period.\nSaves the cropped climate data to disk.\nTriggers garbage collection to free up memory.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.get_cumulative_climate!-api","page":"API","title":"Sleipnir.get_cumulative_climate!","text":"get_cumulative_climate!(climate, t::AbstractFloat, step::AbstractFloat, gradient_bounds=[-0.009, -0.003])\nget_cumulative_climate!(climate, period::StepRange{Date, Day}, gradient_bounds=[-0.009, -0.003])\n\nCalculate and update the cumulative climate data for a given period. The user can choose between providing a specific time t and a time step step, or a time period defined by period.\n\nKeyword arguments\n\nclimate::Climate: The climate object containing raw climate data.\ngradient_bounds::Vector{Float64}: Optional. The bounds within which to clamp the gradient values. Default is [-0.009, -0.003].\n\nOptional parameters to specify the time period:\n\nt::AbstractFloat: Time at which the cumulative climate data should be computed.\nstep::AbstractFloat: Time step used to compute the cumulative climate data. Together with t they define a time period.\n\nor\n\nperiod::StepRange{Date, Day}: The time period for which to compute the cumulative climate data.\n\nUpdates\n\nclimate.climate_raw_step: The raw climate data for the given period.\nclimate.avg_temps: The average temperature for the given period.\nclimate.avg_gradients: The average gradient for the given period.\nclimate.climate_step.prcp: The cumulative precipitation for the given period.\nclimate.climate_step.temp: The cumulative temperature for the given period.\nclimate.climate_step.gradient: The cumulative gradient for the given period.\nclimate.climate_step.avg_temp: The average temperature for the given period.\nclimate.climate_step.avg_gradient: The average gradient for the given period.\nclimate.climate_step.ref_hgt: The reference height from the raw climate data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.get_cumulative_climate-api","page":"API","title":"Sleipnir.get_cumulative_climate","text":"get_cumulative_climate(\n    climate::RasterStack,\n    gradient_bounds::Vector{Float64}=[-0.009, -0.003],\n)\n\nCalculate cumulative climate statistics from the given climate data.\n\nKeyword arguments\n\nclimate::RasterStack: A RasterStack object containing temperature, precipitation, and gradient data.\ngradient_bounds::Vector{Float64}: A two-element vector specifying the lower and upper bounds for the gradient values. Defaults to [-0.009, -0.003].\n\nReturns\n\nclimate_sum::ClimateStep: A struct containing the following fields:\n\"temp\": The sum of positive degree days (PDDs) from the temperature data.\n\"prcp\": The sum of precipitation data.\n\"gradient\": The sum of gradient data, clipped within the specified bounds.\n\"avg_temp\": The average temperature.\n\"avg_gradient\": The average gradient.\n\"ref_hgt\": The reference height from the climate metadata.\n\nNotes\n\nThe temperature data is modified to only include positive degree-day values (PDDs).\nThe gradient data is clipped within the specified bounds to ensure plausible values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.get_glathida!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters}} where G<:Glacier2D-api","page":"API","title":"Sleipnir.get_glathida!","text":"get_glathida!(glaciers::Vector{G}, params::Parameters; force=false) where {G <: Glacier2D}\n\nRetrieve and process glacier thickness data for a vector of Glacier2D objects.\n\nArguments\n\nglaciers::Vector{Glacier2D}: A vector of Glacier2D objects for which the glacier thickness data is to be retrieved.\nparams::Parameters: A Parameters object containing simulation parameters.\nforce::Bool=false: A boolean flag indicating whether to force the retrieval of glacier thickness data.\n\nReturns\n\ngtd_grids::Vector: A vector of glacier thickness data grids.\nglaciers::Vector{Glacier2D}: The updated vector of Glacier2D objects after removing glaciers with no data.\n\nDescription\n\nThis function retrieves glacier thickness data for each glacier in the input vector using parallel processing. It updates a list of missing glaciers if any glacier has all data points equal to zero. The function then removes glaciers with no data from both the gtd_grids and glaciers vectors and returns the updated vectors.\n\nNotes\n\nThe function uses pmap for parallel processing of glaciers.\nThe list of missing glaciers is stored in a JLD2 file located at params.simulation.working_dir/data/missing_glaciers.jld2.\nGlaciers with no data are identified and removed based on the condition that all data points in their thickness grid are zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.get_glathida_glacier-Tuple{Glacier2D, Sleipnir.Parameters, Any}-api","page":"API","title":"Sleipnir.get_glathida_glacier","text":"get_glathida_glacier(glacier::Glacier2D, params::Parameters, force)\n\nRetrieve or generate the glathida glacier grid for a given glacier.\n\nArguments\n\nglacier::Glacier2D: The glacier object for which the glathida grid is to be retrieved or generated.\nparams::Parameters: The parameters object containing simulation settings.\nforce: A boolean flag indicating whether to force regeneration of the glathida grid even if it already exists.\n\nReturns\n\ngtd_grid: A 2D array representing the glathida glacier grid.\n\nDescription\n\nThis function checks if the glathida glacier grid file (glathida.h5) exists in the specified path. If the file exists and force is false, it reads the grid from the file. Otherwise, it reads the glacier thickness data from a CSV file (glathida_data.csv), computes the average thickness for each grid cell, and saves the resulting grid to an HDF5 file (glathida.h5).\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters, Rasters.RasterStack, Matrix{<:AbstractFloat}}-api","page":"API","title":"Sleipnir.get_longterm_temps","text":"get_longterm_temps(rgi_id::String, params::Parameters, climate::RasterStack) -> Array{Float64}\n\nCalculate the long-term average temperatures for a given glacier.\n\nArguments\n\nrgi_id::String: The RGI (Randolph Glacier Inventory) identifier for the glacier.\nparams::Parameters: A struct containing simulation parameters, including paths to RGI data.\nclimate::RasterStack: A RasterStack object containing climate data.\n\nReturns\n\nArray{Float64}: An array of long-term average temperatures.\n\nDescription\n\nThis function retrieves the gridded data for the specified glacier using its RGI identifier. It then applies a temperature gradient to the climate data based on the glacier's topography. Finally, it calculates the long-term average temperatures by grouping the temperature data by year and computing the mean for each group.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.get_raw_climate_data-Tuple{String}-api","page":"API","title":"Sleipnir.get_raw_climate_data","text":"get_raw_climate_data(rgi_path::String) -> RasterStack\n\nLoad raw climate data from a specified path.\n\nArguments\n\nrgi_path::String: The file path to the directory containing the climate data file.\n\nReturns\n\nRasterStack: A RasterStack object containing the climate data from the specified file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.get_result_id_from_rgi-Union{Tuple{SIM}, Tuple{I}, Tuple{I, SIM}} where {I<:Integer, SIM<:Simulation}-api","page":"API","title":"Sleipnir.get_result_id_from_rgi","text":"get_result_id_from_rgi(glacier_id::I, simulation::SIM) where {I <: Integer, SIM <: Simulation}\n\nExtract results of specific simulation from the Simulation object.\n\nArguments\n\nglacier_id::I: Numerical ID of glacier used to generate simulation.\nsimulation::SIM`: The simulation object containing the parameters and results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.glacierName-Tuple{String}-api","page":"API","title":"Sleipnir.glacierName","text":"glacierName(rgi_id::String)\nglacierName(rgi_ids::Vector{String})\n\nReturns the name(s) of one or multiple glaciers based the given RGI ID(s). It uses the rgi62_stats.csv file from OGGM.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.grid-Union{Tuple{FileArray}, Tuple{VM}, Tuple{F}, Tuple{G}, Tuple{G, Vector{F}, Vector{F}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Nothing, BitMatrix}, VM}} where {G<:AbstractGlacier, F<:AbstractFloat, VM<:Sleipnir.VelocityMapping, FileArray<:Rasters.FileArray}-api","page":"API","title":"Sleipnir.grid","text":"grid(\n    glacier::G,\n    latitudes::Vector{F},\n    longitudes::Vector{F},\n    vx::Union{FileArray, Array{Union{Missing, F}, 3}},\n    vy::Union{FileArray, Array{Union{Missing, F}, 3}},\n    mapping::VM\n) where {\n    G <: AbstractGlacier,\n    F <: AbstractFloat,\n    VM <: VelocityMapping,\n    FileArray <: Rasters.FileArray\n}\n\nGrid velocity data onto the glacier grid following the prescribed mapping. This function maps the 3 dimensional surface velocities (x, y and t) to the glacier grid. The provided surface velocities can be a Rasters.FileArray which happens when the RasterStack is instantiated in lazy mode. In this situation, only the smallest cube that contains all the needed data to construct the mapping is read from disk. The returned velocity variables have shape (nTimes, nx, ny) where nTimes is the number of time steps and (nx, ny) is the size of the glacier grid.\n\nArguments:\n\nglacier::G: Glacier instance which determines the glacier on which the   velocities are projected onto.\nlatitudes::Vector{F}: Vector of latitude values of the original surface   velocity grid.\nlongitudes::Vector{F}: Vector of longitude values of the original surface   velocity grid.\nvx::Union{FileArray, Array{Union{Missing, F}, 3}}: X component of the original   surface velocities. It can be either a Rasters.FileArray if the datacube is   read in lazy mode, or a plain 3 dimensional array.\nvy::Union{FileArray, Array{Union{Missing, F}, 3}}: Y component of the original   surface velocities. It can be either a Rasters.FileArray if the datacube is   read in lazy mode, or a plain 3 dimensional array.\nmapping::VM: Mapping to use.\n\nReturns:\n\nxG: A vector that gives the x coordinates of the glacier grid.\nyG: A vector that gives the y coordinates of the glacier grid.\nvxG: A 3 dimensional array of the x component of the velocity gridded onto the   glacier grid.\nvyG: A 3 dimensional array of the y component of the velocity gridded onto the   glacier grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}-api","page":"API","title":"Sleipnir.initialize_glacier","text":"initialize_glacier(rgi_id::String, parameters::Parameters; smoothing=false)\n\nInitialize a glacier with the given RGI ID and parameters.\n\nArguments\n\nrgi_id::String: The RGI (Randolph Glacier Inventory) ID of the glacier.\nparameters::Parameters: A struct containing various parameters required for initialization.\nsmoothing::Bool: Optional. If true, apply smoothing to the initial topography. Default is false.\nmasking::Union{Int, Nothing, Matrix}: Type of mask applied to the glacier to determine regions with no ice.\nvelocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}: A dictionary that provides for each RGI ID either the path to the datacube or the RasterStack with velocity data.\n\nReturns\n\nglacier: An initialized glacier object containing the initial topography and climate data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}-api","page":"API","title":"Sleipnir.initialize_glaciers","text":"initialize_glaciers(\n    rgi_ids::Vector{String},\n    params::Parameters;\n    velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}=Dict(),\n)\n\nInitialize glaciers based on provided RGI IDs and parameters.\n\nArguments\n\nrgi_ids::Vector{String}: A vector of RGI IDs representing the glaciers to be initialized.\nparams::Parameters: A Parameters object containing simulation parameters.\nvelocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}: A dictionary that provides for each RGI ID either the path to the datacube or the RasterStack with velocity data.\n\nReturns\n\nglaciers::Vector{Glacier2D}: A vector of initialized Glacier2D objects.\n\nDescription\n\nThis function performs the following steps:\n\nGenerates a file for missing glaciers if it does not already exist.\nFilters out missing glaciers from the provided RGI IDs.\nGenerates raw climate data for the glaciers if necessary.\nInitializes the glaciers using the provided RGI IDs and parameters.\nIf use_glathida_data is enabled in the simulation parameters, assigns GlaThiDa data to the glaciers.\n\nErrors\n\nThrows an error if none of the provided RGI IDs have GlaThiDa data.\n\nWarnings\n\nIssues a warning if not all glaciers have GlaThiDa data available.\n\nExample\n\n# We declare a list of glaciers to be initialized with their RGI IDs\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\n# We initialize those glaciers based on the RGI IDs and the parameters we previously specified\nglaciers = initialize_glaciers(rgi_ids, params)\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_surfacevelocitydata-Union{Tuple{Union{String, Rasters.RasterStack}}, Tuple{VM}, Tuple{G}} where {G<:AbstractGlacier, VM<:Sleipnir.VelocityMapping}-api","page":"API","title":"Sleipnir.initialize_surfacevelocitydata","text":"initialize_surfacevelocitydata(\n    raster::Union{String, <: RasterStack};\n    glacier::Union{G, Nothing}=nothing,\n    mapping::VM=MeanDateVelocityMapping(),\n    compute_vabs_error::Bool=true,\n    flag::Union{String, <: RasterStack, Nothing} = nothing\n) where {G <: AbstractGlacier, VM <: VelocityMapping}\n\nInitialize SurfaceVelocityData from Rabatel et. al (2023).\n\nArguments:\n\nraster::Union{String, RasterStack}: RasterStack or path of the netCDF file with surface velocity data.\nglacier::Union{G, Nothing}: Glacier associated to the surface velocity datacube.   When provided, the surface velocity data are gridded on the glacier grid using   the mapping.\nmapping::VM: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.\ncompute_vabs_error::Bool: Whether to compute the absolute error uncertainty.\nflag::Union{String, <: RasterStack, Nothing}: Option to provide a RasterStack   containing a fmask raster and which provides an indicator of whether each pixel   of the ice surface velocity data is considered as reliable or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.initialize_surfacevelocitydata_mask-api","page":"API","title":"Sleipnir.initialize_surfacevelocitydata_mask","text":"initialize_surfacevelocitydata_mask(data::RasterStack, flag::Union{String, <:RasterStack, Nothing}=nothing)\n\nCreate a mask for a glacier surface velocity dataset by subsetting and aligning a flag raster to the spatial domain of data.\n\nArguments\n\ndata::RasterStack: The glacier datacube or surface velocity dataset.\nflag::Union{String, RasterStack, Nothing}: Type of flag to be applied\n\nDescription\n\nThis function extracts the portion of the flag raster that spatially overlaps with the glacier domain defined by data. Because the flag raster is centered on pixel centers, its bounding box is shifted by half a grid step when subsetting.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sleipnir.is_in_glacier-Union{Tuple{F}, Tuple{I}, Tuple{Matrix{F}, I}} where {I<:Integer, F<:AbstractFloat}-api","page":"API","title":"Sleipnir.is_in_glacier","text":"is_in_glacier(A::Matrix{F}, distance::I) where {I <: Integer, F <: AbstractFloat}\n\nReturn a matrix with booleans indicating if a given pixel is at distance at least distance in the set of non zero values of the matrix. This usually allows discarding the border pixels of a glacier. A positive value of distanceindicates a measurement from inside the glacier, while a negativedistance`` indicates one from outside.\n\nArguments:\n\nA::Matrix{F}: Matrix from which to compute the matrix of booleans.\ndistance::I: Distance to the border, computed as the number of pixels we need   to move from within the glacier to find a pixel with value zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.local_distance-Union{Tuple{F}, Tuple{CoordRefSystems.TransverseMercator, Union{VecOrMat{F}, F}, Union{VecOrMat{F}, F}}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.local_distance","text":"Compute distance between one point in the format of a TransverseMercator point and a set of points defined through the coordinates x and y in meters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.mapVelocity-Tuple{MeanDateVelocityMapping, SurfaceVelocityData, AbstractFloat}-api","page":"API","title":"Sleipnir.mapVelocity","text":"mapVelocity(\n    velocityMapping::MeanDateVelocityMapping,\n    velocityData::SurfaceVelocityData,\n    t::AbstractFloat,\n)\n\nRetrieve the reference ice surface velocity for a given time step. This mapping uses the nearest snap shot available within a time window whose length is controlled by velocityMapping.thresDate. If no snapshot is found in the time window of length 2*velocityMapping.thresDate, the returned ice velocity components are empty matrices and the returned boolean flag useVel is set to false.\n\nArguments:\n\nvelocityMapping::MeanDateVelocityMapping: Mapping to map the reference ice velocity to a target time step t.\nvelocityData::SurfaceVelocityData: Surface velocity data. This is usually an attribute of a glacier.\nt::AbstractFloat: Current time step.\n\nReturns\n\nVx_ref: Matrix of the x-component of the ice surface velocity.\nVy_ref: Matrix of the y-component of the ice surface velocity.\nV_ref: Matrix of the ice surface velocity magnitude.\nuseVel: Boolean indicating whether the returned ice surface velocity can be used   or not. The value of this boolean depends on the success of the ice surface   velocity mapping at the current time step t.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.max_or_empty-Tuple{Array}-api","page":"API","title":"Sleipnir.max_or_empty","text":"max_or_empty(A::Array)\n\nReturn maximum value for non-empty arrays. This is just required to compute the error in the absolute velocity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.parse_proj-Tuple{String}-api","page":"API","title":"Sleipnir.parse_proj","text":"parse_proj(proj::String)\n\nParses the string containing the information of the projection to filter for important information \"+proj=tmerc +lat0=0 +lon0=6.985 +k=0.9996 +x0=0 +y0=0 +datum=WGS84 +units=m +no_defs\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.partial_year-Tuple{Any}-api","page":"API","title":"Sleipnir.partial_year","text":"partial_year(float::Float64) -> Float64\n\nCalculate the partial year value based on the given floating-point number.\n\nArguments\n\nfloat::Float64: A floating-point number representing the fraction of the year.\n\nReturns\n\nFloat64: The calculated partial year value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.partial_year-Tuple{Type{<:Dates.Period}, AbstractFloat}-api","page":"API","title":"Sleipnir.partial_year","text":"partial_year(period::Type{<:Period}, float)\n\nCalculate a partial year date based on a floating-point year value.\n\nArguments\n\nperiod::Type{<:Period}: The type of period to use (e.g., Month, Day).\nfloat::Float64: The floating-point year value.\n\nReturns\n\nDate: The calculated date corresponding to the partial year.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_bias-Tuple{Any, Any}-api","page":"API","title":"Sleipnir.plot_bias","text":"plot_bias(\n    results,\n    variables;\n    treshold = [0, 0],\n    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,\n)\n\nPlot the bias of the glacier integrated volume over the specified time span.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nvariables::Vector{Symbol}: The variables to be plotted.\ntitle_mapping::Dict{Symbol, String}: A dictionary mapping variable names to their titles.\ntspan::Tuple{Float64, Float64}: A tuple representing the start and end time for the simulation.\nfigsize::Union{Nothing, Tuple{Int64, Int64}}: Size of the figure.\n\nReturns\n\nA plot of the glacier integrated volume bias.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier-Tuple{Sleipnir.Results, String, Vector{Symbol}}-api","page":"API","title":"Sleipnir.plot_glacier","text":"plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -> Figure\n\nGenerate various types of plots for glacier data.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nplot_type::String: Type of plot to generate. Options are:\n\"heatmaps\": Heatmaps for glacier variables like :H, :H₀, :S, :B, :V, :Vx, :Vy, :V_ref.\n\"evolution difference\": Temporal difference metrics (between start and end) for a variable, with optional metrics like \"hist\" (histogram) and \"difference\".\n\"evolution statistics\": Temporal statistical metrics for a variable, with optional metrics like \"average\", \"median\", \"min\", \"max\", and \"std\".\n\"integrated volume\": Temporal evolution of the integrated ice volume for a variable.\n\"bias\": Scatter plot to visualize the bias between two variables.\nvariables::Vector{Symbol}: Variables to be plotted, e.g., :H.\n\nOptional Keyword Arguments\n\ntspan: A tuple representing the start and end time for the simulation.\nmetrics: Metrics to visualize, e.g., [\"average\"] for statistics, [\"difference\"] for difference.\nscale_text_size::Union{Nothing,Float64}: Optional argument to scale the text size for heatmaps.\nthreshold::Vector{F}: Threshold values for filtering data in bias plots.\nfigsize::Tuple{Int64, Int64}: Size of the figure.\n\nReturns\n\nA Figure object containing the desired visualization.\n\nNotes\n\nEnsure the variables and kwargs match the requirements of the specified plot_type.\nThe function routes requests to specific plotting functions based on plot_type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Sleipnir.Results, Vector{Symbol}, Any}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.plot_glacier_difference_evolution","text":"plot_glacier_difference_evolution(\n    results::Results,\n    variables::Vector{Symbol},\n    title_mapping;\n    tspan::Tuple{F,F}=results.tspan,\n    metrics::Vector{String}=\"difference\",\n    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,\n) where {F<:AbstractFloat}\n\nPlot the evolution of the difference in a glacier variable over time.\n\nArguments\n\nresults::Results: The simulation results object containing the data to be plotted.\nvariables::Vector{Symbol}: The variable to be plotted.\ntitle_mapping: A dictionary mapping variable names to their titles.\ntspan::Tuple{F,F}: A tuple representing the start and end time for the simulation.\nmetrics::Vector{String}: Metrics to visualize, e.g., [\"difference\"].\nfigsize::Union{Nothing, Tuple{Int64, Int64}}: Size of the figure.\n\nReturns\n\nA plot of the glacier difference evolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier_heatmaps-Tuple{Sleipnir.Results, Vector{Symbol}, Dict}-api","page":"API","title":"Sleipnir.plot_glacier_heatmaps","text":"plot_glacier_heatmaps(\n    results::Results,\n    variables::Vector{Symbol},\n    title_mapping::Dict;\n    scale_text_size::Union{Nothing,Float64}=nothing,\n    timeIdx::Union{Nothing,Int64}=nothing,\n    figsize::Union{Nothing, Tuple{Int64, Int64}} = nothing,\n    plotContour::Bool=false,\n) -> Figure\n\nPlot heatmaps for glacier variables.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nvariables::Vector{Symbol}: A list of variables to be plotted.\ntitle_mapping::Dict: A dictionary mapping variable names to their titles and colormaps.\nscale_text_size::Union{Nothing,Float64}: Optional argument to scale the text size.\ntimeIdx::Union{Nothing,Int64}:: Optional argument to select the index at which   data should be plotted when dealing with vector of matrix. Default is nothing   which selects the last element available.\nfigsize::Union{Nothing, Tuple{Int64, Int64}}: Size of the figure.\nplotContour::Bool: Whether to add a contour plot representing the glacier borders at   the beginning of the simulation on top of each of the figures. Default is false.\n\nReturns\n\nA plot of the glacier heatmaps.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}-api","page":"API","title":"Sleipnir.plot_glacier_integrated_volume","text":"plot_glacier_integrated_volume(\n    results,\n    variables,\n    title_mapping;\n    tspan,\n    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,\n)\n\nPlot the integrated volume of a glacier variable over time.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nvariables::Vector{Symbol}: The variable to be plotted.\ntitle_mapping: A dictionary mapping variable names to their titles.\ntspan: A tuple representing the start and end time for the simulation.\nfigsize::Union{Nothing, Tuple{Int64, Int64}}: Size of the figure.\n\nReturns\n\nA plot of the glacier integrated volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier_quivers-Tuple{Sleipnir.Results, Vector{Symbol}, Dict}-api","page":"API","title":"Sleipnir.plot_glacier_quivers","text":"plot_glacier_quivers(\n    results::Results,\n    variables::Vector{Symbol},\n    title_mapping::Dict;\n    timeIdx::Union{Nothing,Int64} = nothing,\n    figsize::Union{Nothing, Tuple{Int64, Int64}} = nothing,\n    lengthscale::Float64 = 0.00001,\n    tiplength::Float64 = 0.5,\n) -> Figure\n\nPlot quivers for glacier variables.\n\nArguments\n\nresults::Results: The results object containing the data to be plotted.\nvariables::Vector{Symbol}: A list of variables to be plotted.\ntitle_mapping::Dict: A dictionary mapping variable names to their titles and colormaps.\ntimeIdx::Union{Nothing,Int64}:: Optional argument to select the index at which   data should be plotted when dealing with vector of matrix. Default is nothing   which selects the last element available.\nfigsize::Union{Nothing, Tuple{Int64, Int64}}: Size of the figure.\nlengthscale::Float64: Lengthscale of the arrows in the quiver plot.\ntiplength::Float64: Length of the arrow in the quiver plot.\n\nReturns\n\nA plot of the glacier quivers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier_statistics_evolution-Tuple{Sleipnir.Results, Vector{Symbol}, Any}-api","page":"API","title":"Sleipnir.plot_glacier_statistics_evolution","text":"plot_glacier_statistics_evolution(\n    results::Results,\n    variables::Vector{Symbol},\n    title_mapping;\n    metrics=\"median\",\n    tspan,\n    threshold=0.5,\n    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,\n)\n\nPlot the evolution of statistics for multiple glacier variables over time.\n\nArguments\n\nresults::Results: The simulation results object containing the data to be plotted.\nvariables::Vector{Symbol}: A list of variables to be plotted.\ntitle_mapping: A dictionary mapping variable names to their titles.\nmetrics: Metrics to visualize, e.g., \"average\", \"median\", \"min\", \"max\", and \"std\". Default is \"median\".\ntspan: A tuple representing the start and end time for the simulation.\nthreshold: A threshold value to filter the data. Default is 0.5.\nfigsize::Union{Nothing, Tuple{Int64, Int64}}: Size of the figure.\n\nReturns\n\nA plot of the glacier statistics evolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_glacier_vid-Tuple{String, Sleipnir.Results, Glacier2D, Any, Any, String}-api","page":"API","title":"Sleipnir.plot_glacier_vid","text":"plot_glacier_vid(\n    plot_type::String,\n    results::Results,\n    glacier::Glacier2D,\n    tspan,\n    step,\n    pathVideo::String;\n    framerate::Int=24,\n    baseTitle::String=\"\"\n)\n\nGenerate various types of videos for glacier data. For now only the evolution of the glacier ice thickness is supported. More types of visualizations will be added in the future. \n\nArguments\n\nplot_type: Type of plot to generate. Options are:\n\"thickness\": Heatmap of the glacier thickness.\nresults: A result object containing the simulation results including ice   thickness over time.\nglacier: A glacier instance.\ntspan: The simulation time span.\nstep: Time step to use to retrieve the results and generate the video.\npathVideo: Path of the mp4 file to generate.\n\nOptional Keyword Arguments\n\nframerate: The framerate to use for the video generation.\nbaseTitle: The prefix to use in the title of the frames. In each frame it is   concatenated with the value of the year in the form \" (t=XXXX)\".\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.plot_gridded_data-Union{Tuple{F}, Tuple{Union{Array{Matrix{F}, 1}, Matrix{F}}, Sleipnir.Results}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.plot_gridded_data","text":"plot_gridded_data(\n    gridded_data::Union{Vector{Matrix{F}}, Matrix{F}},\n    results::Results;\n    scale_text_size::Union{Nothing,Float64}=nothing,\n    timeIdx::Union{Nothing,Int64}=nothing,\n    figsize::Union{Nothing, Tuple{Int64, Int64}} = nothing,\n    plotContour::Bool=false,\n    colormap = :cool,\n    logPlot = false,\n) where {F <: AbstractFloat}\n\nPlot a gridded matrix (or a time series of matrices) as a heatmap using metadata from results.\n\nArguments\n\ngridded_data::Union{Vector{Matrix{F}}, Matrix{F}}: Single snapshot or time series (defaults to last timestep).\nresults::Results: Supplies lon, lat, x, y, rgi_id, Δx and H (mask).\nscale_text_size, figsize, colormap: Optional plotting params.\ntimeIdx::Union{Nothing,Int64}: Select timestep when gridded_data is a vector.\nplotContour::Bool: overlay glacier-mask contour from results.H.\nlogPlot::Bool: Use log10 colorscale (positive non-NaN values determine range).\n\nBehavior\n\nMasks out cells where results.H[begin] .<= 0 (set to NaN).\nAdds colorbar, central lon/lat tick, and a Δx-based scale bar in km.\nIf plotContour, draws mask boundary lines.\nReturns a CairoMakie.Figure.\n\nErrors\n\nAsserts gridded_data is non-empty and timeIdx (if provided) is in range.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.precompute_all_VJPs_laws!-Tuple{AbstractModel, Vararg{Any, 5}}-api","page":"API","title":"Sleipnir.precompute_all_VJPs_laws!","text":"precompute_all_VJPs_laws!(model::AbstractModel, cache, simulation, glacier_idx, t, θ)\n\nThis function is a placeholder and must be implemented for your custom model type.\n\nIt is intended to precompute the VJPs for all the laws that are used in a model. By default, calling this function will throw an error to indicate that the user should provide their own implementation tailored to their model.\n\nArguments\n\nmodel::AbstractModel: The model instance.\ncache: The cache object storing state variables.\nsimulation: The simulation context.\nglacier_idx: Index identifying the glacier.\nt: The current simulation time.\nθ: The parameter vector.\n\nThrows\n\nAlways throws an error: \"This function should not be called. Implement precompute_all_VJPs_laws! for your own model.\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.prepare_vjp_law-Tuple{Any, AbstractLaw, Any, Any, Any}-api","page":"API","title":"Sleipnir.prepare_vjp_law","text":"prepare_vjp_law(simulation, law::AbstractLaw, law_cache, θ, glacier_idx)\n\nFunction used to prepare the VJPs at the initialization of the model cache. It is used for example to compile VJPs of the laws to be differentiated using DifferentiationInterface.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.random_spatially_coherent_mask-Tuple{Integer, Integer}-api","page":"API","title":"Sleipnir.random_spatially_coherent_mask","text":"random_spatially_coherent_mask(h::Integer, w::Integer; sigma::Real=1.0, threshold::Real=0.0) -> BitMatrix\nrandom_spatially_coherent_mask(mask::BitMatrix; sigma::Real=1.0, threshold::Real=0.0) -> BitMatrix\n\nGenerate a random binary mask with spatially correlated patches rather than pixel-wise independent noise. This is done by drawing white noise, applying a Gaussian low-pass filter in the frequency domain, and thresholding the result.\n\nArguments\n\nh::Integer, w::Integer: Height and width of the mask.\nmask::BitMatrix: An existing binary mask. The generated spatially coherent mask   will be applied elementwise (.&) to this mask.\nsigma::Real=1.0: Controls the spatial correlation length. Larger values produce   smoother, larger patches.\nthreshold::Real=0.0: Threshold applied to the filtered noise. Higher values   result in sparser masks. Statistically, setting the threshold to zero results in   a mask with half pixels to true.\n\nReturns\n\nA BitMatrix of size (h, w) containing true in patchy regions and false elsewhere.\n\nExamples\n\n```julia\n\nGenerate a new 256×256 patchy mask\n\nmask = randomspatiallycoherent_mask(256, 256; sigma=8.0, threshold=0.0)\n\nApply patchy masking to an existing mask\n\nbase = trues(128, 128) patchy = randomspatiallycoherent_mask(base; sigma=5.0, threshold=0.3)\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.ratio_max-Tuple{Any, Any}-api","page":"API","title":"Sleipnir.ratio_max","text":"ratio_max(v, vabs)\n\nCompute the maximum ratio between v and vabs at points where the value of vabs is not a NaN.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.retrieve_simulation-Tuple{Any}-api","page":"API","title":"Sleipnir.retrieve_simulation","text":"retrieve_simulation(p)\nretrieve_simulation(p::Container)\n\nFunction that retrieves the simulation object from integrator.p when called from a callback. If p is a subtype of Container, then p.simulation is returned, otherwise it returns p. It is for internal use only and it isn't exposed to the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.reverseForHeatmap-Union{Tuple{F}, Tuple{Matrix{F}, Vector{F}, Vector{F}}} where F<:AbstractFloat-api","page":"API","title":"Sleipnir.reverseForHeatmap","text":"reverseForHeatmap(\n    inp::Matrix{F},\n    x::Vector{F},\n    y::Vector{F}\n) where {F <: AbstractFloat}\n\nOut-of-place reverse of a matrix based on the values of the x and y axes. This function corrects the orientation so that the heatmap is displayed correctly.\n\nArguments\n\ninp::Matrix{F}: The matrix to reverse.\nx::Vector{F}: Values of the x axis.\ny::Vector{F}: Values of the y axis.\n\nReturns\n\nOut-of-place copy of inp that has been reversed if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Sleipnir.Results{F, I}, 1}, SIM}} where {F<:AbstractFloat, I<:Integer, SIM<:Simulation}-api","page":"API","title":"Sleipnir.save_results_file!","text":"save_results_file!(results_list::Vector{Results{F, I}}, simulation::SIM; path::Union{String,Nothing}=nothing) where {F <: AbstractFloat, I <: Integer, SIM <: Simulation}\n\nSave the results of a simulation to a file.\n\nArguments\n\nresults_list::Vector{Results{F, I}}: A vector containing the results of the simulation.\nsimulation::SIM: The simulation object containing the parameters and results.\npath::Union{String,Nothing}: Optional. The path where the results file will be saved. If not provided, a default path will be used.\n\nDescription\n\nThis function saves the results of a simulation to a file in JLD2 format. If the path argument is not provided, the function will create a default path based on the current project directory. The results are saved in a file named prediction_<nglaciers>glaciers_<tspan>.jld2, where <nglaciers> is the number of glaciers in the simulation and <tspan> is the simulation time span.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.smooth!-Tuple{Any}-api","page":"API","title":"Sleipnir.smooth!","text":"smooth!(A)\n\nSmooths the interior of a 2D array A using a simple averaging method. The function modifies the array A in place.\n\nArguments\n\nA::AbstractMatrix: A 2D array to be smoothed.\n\nDetails\n\nThe function updates the interior elements of A (excluding the boundary elements) by adding a weighted average of the second differences along both dimensions. The boundary elements are then set to the values of their nearest interior neighbors to maintain the boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.stop_condition_tstops-Tuple{Any, AbstractFloat, Any, Vector{<:AbstractFloat}}-api","page":"API","title":"Sleipnir.stop_condition_tstops","text":"stop_condition_tstops(u, t, integrator, tstops)\n\nCheck if the current time t is in the list of stop times tstops.\n\nArguments\n\nu: The current state of the system (not used in this function).\nt::AbstractFloat: The current time.\nintegrator: The integrator object (not used in this function).\ntstops::Vector{<: AbstractFloat}: A collection of times at which the integration should stop.\n\nReturns\n\nBool: true if t is in tstops, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.tdata-Tuple{Nothing}-api","page":"API","title":"Sleipnir.tdata","text":"tdata(data::Nothing)\ntdata(data::ThicknessData)\ntdata(data::Nothing, mapping::MeanDateVelocityMapping)\ntdata(data::SurfaceVelocityData, mapping::MeanDateVelocityMapping)\n\nRetrieve the time steps at which data is available for ice thickness and surface velocity data. If the provided data is nothing, returns an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.trim_period-Tuple{Any, Any}-api","page":"API","title":"Sleipnir.trim_period","text":"trim_period(period, climate)\n\nAdjusts the given period to fit within the bounds of the climate data, ensuring it aligns with hydrological years.\n\nArguments\n\nperiod::UnitRange{Date}: The initial date range to be trimmed.\nclimate::AbstractArray: The climate data array, which should have a time dimension Ti.\n\nReturns\n\nUnitRange{Date}: The adjusted date range that fits within the climate data's time bounds.\n\nDetails\n\nIf the start of the climate data is later than the start of the period, the period is adjusted to start from October 1st of the year of the climate data's start.\nIf the end of the climate data is earlier than the end of the period, the period is adjusted to end on September 30th of the year of the climate data's end.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.∂law∂inp!-Tuple{}-api","page":"API","title":"Sleipnir.∂law∂inp!","text":"∂law∂inp!()\n\nThis function serves as a placeholder and should be replaced by other implementations in ODINN. This implementation throws an error. It is for internal use only and is not exposed to the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sleipnir.∂law∂θ!-Tuple{}-api","page":"API","title":"Sleipnir.∂law∂θ!","text":"∂law∂θ!()\n\nThis function serves as a placeholder and should be replaced by other implementations in ODINN. This implementation throws an error. It is for internal use only and is not exposed to the user.\n\n\n\n\n\n","category":"method"},{"location":"code_of_conduct/#Contributor-Covenant-3.0-Code-of-Conduct","page":"Code of conduct","title":"Contributor Covenant 3.0 Code of Conduct","text":"We want everyone in the ODINN community to feel safe and respected. Our code of conduct outlines the standards we expect from all contributors and maintainers—please take a moment to read it before getting involved. You can find the code of conduct in our GitHub repository under docs/src/code_of_conduct.md:","category":"section"},{"location":"code_of_conduct/#Our-Pledge","page":"Code of conduct","title":"Our Pledge","text":"We pledge to make our community welcoming, safe, and equitable for all.\n\nWe are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.","category":"section"},{"location":"code_of_conduct/#Encouraged-Behaviors","page":"Code of conduct","title":"Encouraged Behaviors","text":"While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.\n\nWith these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:\n\nRespecting the purpose of our community, our activities, and our ways of gathering.\nEngaging kindly and honestly with others.\nRespecting different viewpoints and experiences.\nTaking responsibility for our actions and contributions.\nGracefully giving and accepting constructive feedback.\nCommitting to repairing harm when it occurs.\nBehaving in other ways that promote and sustain the well-being of our community.","category":"section"},{"location":"code_of_conduct/#Restricted-Behaviors","page":"Code of conduct","title":"Restricted Behaviors","text":"We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.\n\nHarassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.\nCharacter attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.\nStereotyping or discrimination. Characterizing anyone’s personality or behavior on the basis of immutable identities or traits.\nSexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.\nViolating confidentiality. Sharing or acting on someone's personal or private information without their permission.\nEndangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.\nBehaving in other ways that threaten the well-being of our community.","category":"section"},{"location":"code_of_conduct/#Other-Restrictions","page":"Code of conduct","title":"Other Restrictions","text":"Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.\nFailing to credit sources. Not properly crediting the sources of content you contribute.\nPromotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.\nIrresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.","category":"section"},{"location":"code_of_conduct/#Reporting-an-Issue","page":"Code of conduct","title":"Reporting an Issue","text":"Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.\n\nWhen an incident does occur, it is important to report it promptly. To report a possible violation, please reach out to any member of the developer team.\n\nCommunity Moderators take reports of violations seriously and will make every effort to respond in a timely manner. They will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators will keep investigation and enforcement actions as transparent as possible while prioritizing safety and confidentiality. In order to honor these values, enforcement actions are carried out in private with the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution.","category":"section"},{"location":"code_of_conduct/#Addressing-and-Repairing-Harm","page":"Code of conduct","title":"Addressing and Repairing Harm","text":"\n\nIf an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.\n\nWarning\nEvent: A violation involving a single incident or series of incidents.\nConsequence: A private, written warning from the Community Moderators.\nRepair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations.\nTemporarily Limited Activities\nEvent: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.\nConsequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.\nRepair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over.\nTemporary Suspension\nEvent: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.\nConsequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.\nRepair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted.\nPermanent Ban\nEvent: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.\nConsequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.\nRepair: There is no possible repair in cases of this severity.\n\nThis enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.","category":"section"},{"location":"code_of_conduct/#Scope","page":"Code of conduct","title":"Scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","category":"section"},{"location":"code_of_conduct/#Attribution","page":"Code of conduct","title":"Attribution","text":"This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.\n\nContributor Covenant is stewarded by the Organization for Ethical Source and licensed under CC BY-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/\n\nFor answers to common questions about Contributor Covenant, see the FAQ at https://www.contributor-covenant.org/faq. Translations are provided at https://www.contributor-covenant.org/translations. Additional enforcement and community guideline resources can be found at https://www.contributor-covenant.org/resources. The enforcement ladder was inspired by the work of Mozilla’s code of conduct team.","category":"section"},{"location":"forward_simulation/#Forward-simulation-tutorial","page":"Forward simulation","title":"Forward simulation tutorial","text":"This tutorial provides a simple example on how to perform a forward simulation using ODINN.jl.","category":"section"},{"location":"forward_simulation/#Running-the-whole-code","page":"Forward simulation","title":"Running the whole code","text":"using ODINN\n\n# Define the working directory\nworking_dir = joinpath(ODINN.root_dir, \"demos\")\n\n# Ensure the working directory exists\nmkpath(working_dir)\n\n# Define which glacier RGI IDs we want to work with\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()\n\n# Create the necessary parameters\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n        multiprocessing = true,\n        workers = 4,\n        rgi_paths = rgi_paths\n    )\n)\n\n# Specify a model based on an iceflow model, a mass balance model, and a machine learning model\nmodel = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF = 6.0 / 1000.0, acc_factor = 1.2 / 1000.0),\n)\n\n# We initialize the glaciers with all the necessary data\nglaciers = initialize_glaciers(rgi_ids, params)\n\n# We specify the type of simulation we want to perform\nprediction = Prediction(model, glaciers, params)\n\n# And finally, we just run the simulation\nrun!(prediction)\n\n# Then we can visualize the results of the simulation, e.g. the difference in ice thickness between 2010 to 2015 for Argentière glacier\npdiff = plot_glacier(prediction.results[1], \"evolution difference\", [:H]; metrics=[\"difference\"])","category":"section"},{"location":"forward_simulation/#Step-by-step-explanation-of-the-tutorial","page":"Forward simulation","title":"Step-by-step explanation of the tutorial","text":"Here we will cover in detail each one of the steps that lead us to run the Prediction from the previous example (i.e. a forward run). This first tutorial keeps things simple, and since we are not using machine learning models, we will only use the Model type to specify the iceflow and mass balance models. These functionalities are mainly covered by Huginn.jl.","category":"section"},{"location":"forward_simulation/#Step-1:-Parameter-initialization","page":"Forward simulation","title":"Step 1: Parameter initialization","text":"The first step is to initialize and specify all the necessary parameters. In ODINN.jl we have many different types of parameters, specifying different aspects of the model. All the parameter types come with a default constructor, which will provide default values in case you don't want to tune those. The main types of parameters are:\n\nSimulation parameters: SimulationParameters includes all the parameters related to the                            ODINN.jl simulation, including the number of workers, the timespan                             of the simulation or the working directory.\nHyperparameters: Hyperparameters includes all the necessary hyperparameters for a machine learning model.\nUDEparameters: UDEparameters contains the parameters related to the training of a Universal Differential Equation.\n\nAll these sub-types of parameters are held in a Parameters struct, a general parameters structure to be passed to an ODINN simulation.\n\nFirst we need to specify a list of RGI IDs of the glacier we want to work with. Specifying an RGI region is also possible. From these RGI IDs, we will look for the necessary files inside the workspace.\n\nrgi_ids = [\"RGI60-11.03638\", \"RGI60-11.01450\", \"RGI60-11.02346\", \"RGI60-08.00203\"]\nrgi_paths = get_rgi_paths()\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        working_dir = working_dir,\n        tspan = (2010.0, 2015.0),\n        multiprocessing = true,\n        workers = 4,\n        rgi_paths = rgi_paths\n    )\n)","category":"section"},{"location":"forward_simulation/#Step-2:-Model-specification","page":"Forward simulation","title":"Step 2: Model specification","text":"The next step is to specify which model(s) we want to use for our simulation. In ODINN we have three different types of model, which are encompassed in a Model structure:\n\nIceflow model: IceflowModel is the ice flow dynamics model that will be used to simulate                     iceflow. It defaults to a 2D Shallow Ice Approximation.\nSurface mass balance model: MassBalanceModel is the mass balance model that will be used for                             simulations. Options here include temperature-index models, or                             machine learning models coming from MassBalanceMachine.\nMachine learning model: MLmodel is the machine learning model (e.g. a neural network) which will                             be used as part of a hybrid model based on a Universal Differential Equation.\n\nThe model is initialized using the Model constructor:\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n)","category":"section"},{"location":"forward_simulation/#Step-3:-Glacier-initialization","page":"Forward simulation","title":"Step 3: Glacier initialization","text":"The third step is to fetch and initialize all the necessary data for our glaciers of interest. This is strongly built on top of OGGM, mostly providing a Julia interface to automatize this. The package Gungnir is used to fetch the necessary data from the RGI and other sources. The data is then stored in servers and fetched and read using Rasters.jl directly by Sleipnir.jl when needed.\n\nThen, we initialize those glaciers based on those RGI IDs and the parameters we previously specified.\n\nglaciers = initialize_glaciers(rgi_ids, params)","category":"section"},{"location":"forward_simulation/#Step-4:-Creating-and-running-a-simulation","page":"Forward simulation","title":"Step 4: Creating and running a simulation","text":"The final step of the pipeline, is to create an ODINN simulation based on all the previous steps, and then to run it. There are different types of simulations that we can do with ODINN:\n\nPrediction: This is a forward simulation, where the initial glacier conditions are run forward in                 in time based on specified parameters and climate data.\n\nThis is as simple as doing:\n\nprediction = Prediction(model, glaciers, params)\n\nAnd once we have the Prediction object, we can run it using run!:\n\nrun!(prediction)\n\nThere we go, we have successfully simulated the evolution of 3 glaciers for 5 years in around 1-2 seconds!","category":"section"},{"location":"forward_simulation/#Step-5:-Visualizing-the-results","page":"Forward simulation","title":"Step 5: Visualizing the results","text":"# Finally, we can use the plotting functions of `ODINN.jl` to visualize the results of the simulation. Like the glacier ice thickness evolution\nplot_glacier(prediction.results[1], \"evolution difference\", [:H]; metrics=[\"difference\"])\n\nOr the initial glacier ice thickness and the resulting ice surface velocities\n\nplot_glacier(prediction.results[1], \"heatmaps\", [:H, :V])\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"inversions/#Inversion-types","page":"Inversion types","title":"Inversion types","text":"In this section we present the main ideas behind the inversions. In data assimilation, one aims at calibrating a model such that the predictions match the observations. The observations can be either an initial, intermediate or final state or observations over time. When we try to invert a trajectory by matching multiple states or observations over time, we are referring to a transient inversion. \n\nIn the classical setting, inversions are made with respect to some quantity of interest that is involed in the iceflow equation, i.e. the mechanistic model. This can be for example the creep coefficient A for the Shallow Ice Approximation (SIA) like in [2]. This parameter can be constant for one glacier or vary with respect to space (i.e. in a grid), in which case a spatial regularization is added to make the inversion problem well-posed.\n\nAnother way to invert a parameter in an iceflow equation is to parametrize the quantity of interest, let us say A, by other quantities which can be in the case of [2], the long term air temperature T. The optimized variable is not A but the parameters theta and the mapping (Ttheta)mapsto A(thetaT) defines a parametrization of the ice rheology. We refer hereafter to this kind of inversion as a functional inversion, where the goal is to optimize the parameters of a regressor specifying a function, rather than directly optimizing parameters or coefficients of a mechanistic model.\n\nWe summarize the main differences between the two kind of inversions hereafter, and we specify the case for performing inversions of the initial conditions (i.e. glacier state), which are a sub-case of classical inversions.","category":"section"},{"location":"inversions/#Classical-inversions","page":"Inversion types","title":"Classical inversions","text":"We refer to classical inversions as the inverse problems where the objective is to directly invert the parameters p of a mechanistic model itself (e.g. the SIA equation). These type of inversions are handled in ODINN via the Inversion subtype of Simulation.\n\nThe optimization problem is\n\nmin_theta L left(hat S S right) + Rleft( hat S p right)\n\nwhere theta is the vector of parameters to invert, for example theta=A; L(hat S S) is the empirical loss function between a predicted state hat S and observations S (for example, the ice thickness or the ice surface velocity); and R(hat S p) is a regularization term.","category":"section"},{"location":"inversions/#Classical-inversions-tutorial","page":"Inversion types","title":"Classical inversions tutorial","text":"The classical inversion tutorial provides an example on how to use these methods to invert in a scalar or gridded way a parameter of the Shallow Ice Approximation. ","category":"section"},{"location":"inversions/#Inversion-with-respect-to-initial-state-of-the-glacier","page":"Inversion types","title":"Inversion with respect to initial state of the glacier","text":"A specific case of a classical inversion is inverting the initial state of glacier. Ice flow models are very sensitive to the initial state of the glacier. For example, it is very common to observe how bad initializations of the ice thickness can lead to unrealistic physical evolutions of the glacier over time (see [3] for a good explanation of this phenomenon in the context of ice sheet simulations). For cases where the initial condition of the glacier is not completely known and/or we want to avoid numerical shocks during the forward simulation, ODINN provides an interface to optimize the initial conditions of the ice thickness H(t = t_0) = H_0 as an extra parameter of the inversion (e.g. in conjunction with the coefficients of basal sliding or the parameters of a neural network parametrization). \n\nWe provide an object InitialCondition that enables the prescription of all the important parameters of the initialization. An initial guess can be provided: :Farinotti2019 for the ice thickness product by Farinotti et al. (2019), or :Farinotti2019Random for the same product with some added Gaussian noise. In order to guarantee that the ice thickness is always non-negative, we introduce a filter function that maps model parameters into a non-negative initial ice thickness matrix (see evaluate_H₀). Finally, prescribing an inversion with respect to the initial condition can be directly included by defining the initial condition as one extra regressor inside the model:\n\nic = InitialCondition(params, glaciers, :Farinotti2019)\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A = LawA(nn_model, params)),\n    mass_balance = nothing,\n    regressors = (; A = nn_model, IC = ic)\n)\n\nFrom an optimization perspective, the computation of the gradients of the loss function with respect to the initial condition is simply given by the value of the adjoint variable at the initial time, which is part of the standard inversion pipeline of ODINN and it does not add any extra computational overhead.\n\nOnce the model has been trained, the value of the initialization can be computed directly from the optimized parameter \\theta using the evaluate_H₀ function to a specific glacier.","category":"section"},{"location":"inversions/#Functional-inversions","page":"Inversion types","title":"Functional inversions","text":"We refer to functional inversions as the inverse problems where the objective is to invert the parameter theta of a regressor (e.g. a neural network), in order to learn a function that parametrizes a subpart of a mechanistic model (e.g. the SIA) with respect to one or more input variables (e.g. surface melt, basal slope) [2]. The methods behind functional inversions are known as Universal Differential Equations [1].\n\nWe present the concept of a functional inversion for the case where we want to learn a law for the ice rheology A in the Shallow Ice Approximation by using a neural network as a parametrization A=textNN(thetaT) with weights theta.\n\nbeginaligned min_theta mathcalDleft(hat S S right) + mathcalRleft( hat S p right)\n A=textNN(thetaT)\nendaligned\n\n(Image: Overview of ODINN.jl’s workflow to perform functional inversions of glacier physical processes using Universal Differential Equations.)\n\nFigure: Overview of ODINN.jl’s workflow to perform functional inversions of glacier physical processes using Universal Differential Equations. The parameters (θ) of a function determining a given physical process (D_θ), expressed by a neural network NN_θ, are optimized in order to minimize a loss function. In this example, the physical to be inferred law was constrained only by climate data, but any other proxies of interest can be used to design it. The climate data, and therefore the glacier mass balance, are downscaled (i.e. it depends on S), with S being updated by the solver, thus dynamically updating the state of the simulation for a given timestep.","category":"section"},{"location":"inversions/#Understanding-the-Laws-interface","page":"Inversion types","title":"Understanding the Laws interface","text":"In ODINN, in order to specify functional inversions, we have introduced a Law type which is responsible for linking a given regressor and a set of input variables to a target of a mechanistic model (for now the SIA). Here is a quick example on how this looks like:\n\nlaw_inputs = (; CPDD=InpCPDD(), topo_roughness=InpTopoRough())\nmodel = Model(\n    iceflow = SIA2Dmodel(params; C=SyntheticC(params; inputs=law_inputs)),\n    mass_balance = nothing\n)\n\nIn this piece of code, we are selecting cumulative positive degree days (CPDDs) and topographical roughness as inputs for a law/parametrization named SyntheticC. Then, when declaring the ice flow model, we associate it to the parameter C of the iceflow model (i.e. the basal sliding). Using this simple interface, we can easily combine all sorts of input variables, with different laws and targets/subparts of mechanistic models.\n\nwarning: Warning\nIt is important to bear in mind that new input types and laws cannot be created on the fly, they need to be specified/added by a user beforehand. For input variables, it is generally a matter of fetching the right data and processing it to the right format for the law/function. For laws, one just needs to specify which function is applied to the different input variables. If the law and input variables involve a regressor, then the new types for the law and inputs must be added to ODINN.jl here; if the law doesn't include any regressors, they can be added directly to Huginn.jl here. \n\nHere is an example of how the code of an input variable looks like:\n\n# We first need to declare the type for the input variable, with any fields that might be needed\nstruct InpCPDD <: AbstractInput\n    window::Int\nend\n\n# Then we can specify a default name for that input\ndefault_name(::InpCPDD) = :CPDD\n\n# And then, using multiple dispatch, we specify the righ `get_input` function for this type, i.e. how to get it\nfunction get_input(cpdd::InpCPDD, simulation, glacier_idx, t)\n    window = cpdd.window\n    glacier = simulation.glaciers[glacier_idx]\n    # We trim only the time period between `t` and `t - x`, where `x` is the PDD time window defined in the physical parameters.\n    period = (partial_year(Day, t) - Day(window)):Day(1):partial_year(Day, t)\n    get_cumulative_climate!(glacier.climate, period)\n    # Convert climate dataset to 2D based on the glacier's DEM\n    climate_2D_step = downscale_2D_climate(glacier.climate.climate_step, glacier)\n\n    return climate_2D_step.PDD\nend\n\nThe logic behind the Laws system is quite similar. Here is a simple example of a synthetic law made following this interface:\n\nfunction SyntheticC(params::Sleipnir.Parameters; inputs = (; CPDD=InpCPDD()))\n    C_synth_law = Law{Array{Float64, 2}}(;\n        name = :SyntheticC,\n        inputs = inputs,\n        max_value = params.physical.maxC,\n        min_value = params.physical.minC,\n        f! = function (cache, inp, θ)\n            # Nonlinear scaling using a sigmoid transformation\n            # C = Cmin + (Cmax - Cmin) * sigmoid(β * (inp.CPDD)))\n            # β controls the steepness of the sigmoid, ϵ avoids division by zero\n            Cmin = params.physical.minC\n            Cmax = params.physical.maxC\n            β = 1.0      # Steepness parameter for sigmoid\n            sigmoid = @. 1.0 / (1.0 + exp(-β * (inp.CPDD - 1.0)))  # Center sigmoid at x=1 for flexibility\n            # If the provided C values are a matrix, reduce matrix size to match operations\n            cache .= Cmin .+ (Cmax - Cmin) .* (isa(sigmoid, Matrix) ? inn1(sigmoid) : sigmoid)\n        end,\n        init_cache = function (simulation, glacier_idx, θ)\n            zeros(size(simulation.glaciers[glacier_idx].S) .- 1)\n        end,\n        callback_freq = 1/52,  # weekly frequency\n    )\n    return C_synth_law\nend\n\nDeclaring a Law implies creating a function which returns a specific type for that law. That custom type needs to specify (1) any necessary fields to be used (e.g. the inputs, its name...), (2) its associated function f!, i.e. what does the law do, (3) how the cache needs to be initialized for the law to interact with the simulation, and (4) the callback frequency callback_freq, which determines the time frequency on which the law will be called during the simulation (e.g. weekly).\n\nFunctional inversions in ODINN are also handled by the Inversion subtype of Simulation. Whether a classical or a functional inversion should be made with respect to some of the components of the PDE depends on how the law is defined.","category":"section"},{"location":"inversions/#Functional-inversion-tutorial","page":"Inversion types","title":"Functional inversion tutorial","text":"The functional inversion tutorial gives an example of how such an inversion can be run in practice with ODINN.jl.","category":"section"},{"location":"inversions/#Laws-and-Law-inputs-tutorials","page":"Inversion types","title":"Laws and Law inputs tutorials","text":"For more details on how to actually implement new laws and law inputs, and for a list of all the ones that are already available within ODINN.jl, you can check the Laws tutorial and the Laws inputs tutorial respectively. ","category":"section"},{"location":"inversions/#Logging","page":"Inversion types","title":"Logging","text":"ODINN.jl provides useful statistics, such as the training loss history or the parameters history in the inversion objects. The training statistics can also be inspected with TensorBoard through VSCode or a local webserver. You can either use the TensorBoard VSCode extension or simply install TensorBoard in a Python environment and then launch tensorboard --logdir .logs/.\n\nBy default the TensorBoard logs are stored in your ODINN folder in ODINN/.logs/ but you may have to adapt the command above if you log in a different folder.","category":"section"},{"location":"laws/#Laws-tutorial","page":"Laws","title":"Laws tutorial","text":"This tutorial provides simple examples on how to create learnable and non learnable laws and how to inject them into the iceflow model.\n\nLet's say we have followed the classical workflow from ODINN, shown in the Forward simulation and Functional inversion tutorials. When we declare the Model type, we can specify the laws that we want to use in the iceflow model. Here we will briefly show how to do it. For more details you can check the Understanding the Law interface section.\n\nusing ODINN\nusing Plots\nusing Dates\nusing PlotlyJS\n\n# Dummy parameters, only specifying the type of loss function to be used\nparams = Parameters(UDE = UDEparameters(empirical_loss_function=LossH()))","category":"section"},{"location":"laws/#Learnable-laws","page":"Laws","title":"Learnable laws","text":"Learnable laws are laws that can be trained using a regressor. They are used to map input variables to a target variable in the iceflow model. In ODINN, we have implemented several learnable laws that can be used in the iceflow model.\n\nnn_model = NeuralNetwork(params)\n\nA_law = LawA(nn_model, params)\n\nThe output of the law definition above states that it maps the long term air temperature T to a float value which corresponds to the creep coefficient A. It is defined as a neural network that takes as input the long term air temperature T and returns the creep coefficient A. The parameters θ of the neural network are learned during the inversion process, by minimizing the loss function given some target data (for this case the ice thickness).\n\nAs explained in the Sensitivity analysis section, ODINN needs to compute the vector-Jacobian products (VJPs). The part of the VJP concerning the law can be computed from different ways and it is possible to customize this, or use a default automatic differentiation backend. For this specific law the VJPs are already customized to have an efficient implementation and the user does not have to worry about this. The VJP law customization tutorial provides a complete description of how this VJP computation can be customized.\n\nThe ouput above shows that the law is applied at each iteration of the iceflow PDE. Additionally it says that custom VJPs are used to compute the gradient and that these VJPs are precomputed as the inputs of the law do not depend on the glacier state. By precomputed we mean that they are computed before solving the adjoint iceflow PDE, refer to the VJP law customization tutorial for more information.\n\nIt is then possible to visualize how the law integrates into the iceflow PDE:\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n    regressors = (; A=nn_model)\n)","category":"section"},{"location":"laws/#Non-learnable-laws","page":"Laws","title":"Non learnable laws","text":"Non learnable laws are laws that are not trained using a regressor. They are used to map input variables to a target variable in the iceflow model, but they do not have any learnable parameters.","category":"section"},{"location":"laws/#Example-1:-Cuffey-and-Paterson-(2010)-1-dimensional-law","page":"Laws","title":"Example 1: Cuffey and Paterson (2010) 1-dimensional law","text":"Here is a quick example also drawn from the Functional inversion tutorial. We define a synthetic law to generate the synthetic dataset. For this, we use some tabular data from Cuffey and Paterson (2010).\n\nA_law = CuffeyPaterson(scalar=true)\n\nNote that this time since there is no learnable parameter, ODINN does not need to compute the VJPs.\n\nmodel = Model(\n    iceflow = SIA2Dmodel(params; A=A_law),\n    mass_balance = TImodel1(params; DDF=6.0/1000.0, acc_factor=1.2/1000.0),\n)\n\nIn this ice flow model, the ice rigidity A is defined by the CuffeyPaterson law, which is a non-learnable law that maps the long term air temperature T to the creep coefficient A.","category":"section"},{"location":"laws/#Example-2:-Synthetic-C-(sliding)-2-dimensional-law","page":"Laws","title":"Example 2: Synthetic C (sliding) 2-dimensional law","text":"In this example, we present a synthetic non-learnable law, that maps the basal sliding coefficient C to the surface topographical roughness and cumulative positive degree days (CPDDs).\n\nrgi_paths = get_rgi_paths()\n\n# Retrieving simulation data for the following glaciers\nrgi_ids = [\"RGI60-11.03638\"]\nδt = 1/12\n\nThe key part here is the definition of the law inputs, which are the variables that will be used to compute the basal sliding coefficient C. In this case, we use the CPDD and the topographical roughness as inputs. As you can see, there are different options to customize the way the inputs are computed. For exampe, for the CPDD, we can specify a time window over which the CPDD is integrated. For the topographical roughness, we can specify a spatial window and the type of curvature to be used.\n\nlaw_inputs = (; CPDD=iCPDD(window=Week(1)), topo_roughness=iTopoRough(window=200.0, curvature_type=:variability))\n\nThen, we define the parameters as for any other simulation.\n\nparams = Parameters(\n    simulation = SimulationParameters(\n        use_MB = false,\n        use_velocities = false,\n        tspan = (2010.0, 2015.0),\n        rgi_paths = rgi_paths,\n        gridScalingFactor = 4 # We reduce the size of glacier for simulation\n        ),\n    solver = Huginn.SolverParameters(\n        step = δt,\n        progress = true\n        )\n    )\n\n# When declaring the model, we will indicate that the basal sliding coefficient `C` will be simulated by the `SyntheticC` law, which takes as input the parameters and the law inputs we defined before.\n\nmodel = Huginn.Model(\n    iceflow = SIA2Dmodel(params; C=SyntheticC(params; inputs=law_inputs)),\n    mass_balance = nothing,\n)\n\nWe retrieve some glaciers for the simulation\n\nglaciers = initialize_glaciers(rgi_ids, params)\n\nTime snapshots for transient inversion\n\ntstops = collect(2010:δt:2015)\n\nThen, we can run the generate_ground_truth_prediction function to simulate the glacier evolution using the defined law.\n\nprediction = generate_ground_truth_prediction(glaciers, params, model, tstops)\n\n# Importantly, we provide the `plot_law` function to visualize 2-dimensional laws in 3D.\n\nThis is especially useful when exploring the behaviour of laws with respect to different proxies, and to better understand learnable laws and their drivers.\n\nfig = plot_law(prediction.model.iceflow.C, prediction, law_inputs, 1, nothing);\nnothing #hide\n\nSince we are in the documentation it is not possible to have an interactive plot but if you reproduce this example locally, you can run the line above without \";\" and you can skip the lines hereafter. This will open an interactive window with a 3D plot that you can rotate.\n\nfolder = \"laws_plots\"\nmkpath(folder)\nfilepath = joinpath(folder, \"3d_plot.png\")\nPlotlyJS.savefig(fig, filepath);\nnothing #hide\n\n<img src=\"./laws_plots/3d_plot.png\" width=\"500\"/>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"simulations/#Simulations","page":"Simulations","title":"Simulations","text":"One can run different types of simulations in ODINN.jl. Any specific type of simulation must be a subtype of Simulation. All simulations share the same common interface designed around multiple dispatch. Basically, once a simulation type has been created, one can easily run by calling run!(simulation).\n\nThe main types of simulations are the following ones:","category":"section"},{"location":"simulations/#Prediction","page":"Simulations","title":"Prediction","text":"A prediction, also known as a forward simulation, is just a forward simulation given a model configuration, based on parameters, glaciers and models. These are managed in Huginn.jl, since they do not involve any inverse methods nor parameter optimization.","category":"section"},{"location":"simulations/#Inversion","page":"Simulations","title":"Inversion","text":"An Inversion is the inversion of the parameters involved in the PDE, or the parameters of a regressor (e.g. a neural network), which parametrize a function that modulates a parameter or set of parameters in a given mechanistic model (e.g. the SIA).","category":"section"},{"location":"simulations/#Huginn.Prediction","page":"Simulations","title":"Huginn.Prediction","text":"Prediction{CACHE} <: Simulation\n\nA mutable struct that represents a prediction simulation.\n\nFields\n\nmodel::Sleipnir.Model: The model used for the prediction.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the prediction.\nparameters::Sleipnir.Parameters: The parameters used for the prediction.\nresults::Vector{Results}: A vector of results obtained from the prediction.\n\n\n\n\n\n","category":"type"},{"location":"simulations/#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G<:AbstractGlacier","page":"Simulations","title":"Huginn.Prediction","text":"Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G <: Sleipnir.AbstractGlacier}\n\nCreate a Prediction object using the given model, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for prediction.\nglaciers::Vector{G}: A vector of glacier objects, where each glacier is a subtype of Sleipnir.AbstractGlacier.\nparameters::Sleipnir.Parameters: The parameters used for the prediction.\n\nReturns\n\nPrediction: A Prediction object based on the input values.\n\n\n\n\n\n","category":"method"},{"location":"simulations/#ODINN.Inversion","page":"Simulations","title":"ODINN.Inversion","text":"mutable struct Inversion{MODEL, CACHE, GLACIER, RES} <: Simulation\n\nAn object representing an inversion simulation. It can involve at the same time a classical inversion and a functional inversion (i.e. the inversion of a function using some data-driven regressor).\n\nFields\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{Sleipnir.AbstractGlacier}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\nresults::ODINN.Results: A ODINN.Results instance to store the results of the inversion and of the forward simulations.\n\n\n\n\n\n","category":"type"},{"location":"simulations/#ODINN.Inversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G<:AbstractGlacier, M<:Sleipnir.Model, P<:Sleipnir.Parameters}","page":"Simulations","title":"ODINN.Inversion","text":"function Inversion(\n    model::M,\n    glaciers::Vector{G},\n    parameters::P\n) where {G <: Sleipnir.AbstractGlacier, M <: Sleipnir.Model, P <: Sleipnir.Parameters}\n\nConstructor for Inversion struct with glacier model information, glaciers, and parameters.\n\nArguments\n\nmodel::Sleipnir.Model: The model used for the simulation.\nglaciers::Vector{G}: A vector of glaciers involved in the simulation.\nparameters::Sleipnir.Parameters: The parameters used for the simulation.\n\nReturns\n\nInversion: A new instance of the Inversion struct.\n\n\n\n\n\n","category":"method"},{"location":"input_laws/#Laws-inputs","page":"Laws inputs","title":"Laws inputs","text":"This tutorial showcases the different inputs that can be used inside the laws.\n\nusing ODINN\n\nIf we represent the A law that we already presented in the Laws tutorial, we can see that it depends on an input T, which is the long term air temperature:\n\nparams = Parameters() # Dummy parameters\nnn_model = NeuralNetwork(params)\nA_law = LawA(nn_model, params)\n\nThe inputs of the laws are represented as objects that derive from AbstractInput. We have defined a subset of inputs that can be used to parameterize laws.","category":"section"},{"location":"input_laws/#Implementation","page":"Laws inputs","title":"Implementation","text":"It is also possible to define new inputs by creating a new struct type and defining the method for this specific type. On top of type of the input, we also need to override two methods using multiple dispatch: get_input and Base.zero. The first one computes the value of the input at a given time t for a specific glacier inside the simulation. The second one returns the zero value of the input for a specific glacier, used to generate an empty cache. For example the long term air temperature is defined with the following code:\n\nstruct iAvgScalarTemp <: AbstractInput end\ndefault_name(::iAvgScalarTemp) = :averaged_long_term_temperature\nfunction get_input(temp::iAvgScalarTemp, simulation, glacier_idx, t)\n    glacier = simulation.glaciers[glacier_idx]\n    return mean(glacier.climate.longterm_temps_scalar)\nend\nfunction Base.zero(temp::iAvgScalarTemp, simulation, glacier_idx)\n    glacier = simulation.glaciers[glacier_idx]\n    return zero(glacier.climate.longterm_temps_scalar)\nend\n\nAn input can compute a physical quantity which is not already defined in the iceflow model like the long term air temperature above, but it can also re-use existing variables. This is the case of ∇S which corresponds to the surface slope. It is retrieved simply by returning the cached variable that lives in the iceflow model:\n\nstruct i∇S <: AbstractInput end\ndefault_name(::i∇S) = :∇S\nfunction get_input(::i∇S, simulation, glacier_idx, t)\n    return simulation.cache.iceflow.∇S\nend\nfunction Base.zero(::i∇S, simulation, glacier_idx)\n    (; nx, ny) = simulation.glaciers[glacier_idx]\n    return zeros(nx-1, ny-1)\nend\n\nwarning: Warning\nKeep in mind that if you define new inputs, this will work only for forward simulations. As soon as you do inversions with custom gradient computation (that is not with SciMLSensitivity), this requires a careful rooting of the gradient and you need to implement more than simply defining new inputs that depend on the glacier state. This is considered as a very advanced feature and we recommend that you seek assistance in this case.","category":"section"},{"location":"input_laws/#List-of-available-inputs","page":"Laws inputs","title":"List of available inputs","text":"For the moment we support the following list of inputs:\n\nScalar averaged long term air temperature\n\niAvgScalarTemp()\n\nGridded averaged long term air temperature\n\niAvgGriddedTemp()\n\nCumulative positive degree days (PDD)\n\niCPDD()\n\nIce thickness on the dual grid in the SIA\n\niH̄()\n\nSurface slope\n\ni∇S()\n\nTopographic roughness\n\niTopoRough()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"input_laws/#Huginn.iAvgScalarTemp","page":"Laws inputs","title":"Huginn.iAvgScalarTemp","text":"iAvgScalarTemp <: AbstractInput\n\nInput that represents the long term air temperature over the whole glacier. It is computed using the OGGM climate data over a period predefined in Gungnir (i.e. around 30 years).\n\n\n\n\n\n","category":"type"},{"location":"input_laws/#Huginn.iAvgGriddedTemp","page":"Laws inputs","title":"Huginn.iAvgGriddedTemp","text":"iAvgGriddedTemp <: AbstractInput\n\nInput that represents the long term air temperature over the glacier grid. It is computed using the OGGM climate data over a period predefined in Gungnir (i.e. around 30 years).\n\n\n\n\n\n","category":"type"},{"location":"input_laws/#Huginn.iCPDD","page":"Laws inputs","title":"Huginn.iCPDD","text":"iCPDD <: AbstractInput\n\nInput that represents the cumulative positive degree days (PDD) over the last time window window. It is computed by summing the daily PDD values from t - window to t using the glacier's climate data.\n\n\n\n\n\n","category":"type"},{"location":"input_laws/#Huginn.iH̄","page":"Laws inputs","title":"Huginn.iH̄","text":"iH̄ <: AbstractInput\n\nInput that represents the ice thickness in the SIA. It is the averaged ice thickness computed on the dual grid, that is H̄ = avg(H) which is different from the ice thickness solution H.\n\n\n\n\n\n","category":"type"},{"location":"input_laws/#Huginn.i∇S","page":"Laws inputs","title":"Huginn.i∇S","text":"i∇S <: AbstractInput\n\nInput that represents the surface slope in the SIA. It is computed using the bedrock elevation and the ice thickness solution H. The spatial differences are averaged over the opposite axis:\n\nS = B + H\n∇S = (avg_y(diff_x(S) / Δx).^2 .+ avg_x(diff_y(S) / Δy).^2).^(1/2)\n\n\n\n\n\n","category":"type"},{"location":"input_laws/#Huginn.iTopoRough","page":"Laws inputs","title":"Huginn.iTopoRough","text":"iTopoRough{F<:AbstractFloat} <: AbstractInput\n\nInput that represents the topographic roughness of the glacier. It is computed as the curvature of the glacier bed (or surface) over a specified window size. The curvature can be calculated in different directions (flow, cross-flow, or both) and using different curvature types (scalar or variability).\n\n\n\n\n\n","category":"type"},{"location":"#ODINN.jl-documentation","page":"Home","title":"ODINN.jl documentation","text":"Welcome to the ODINN.jl documentation, a large-scale scientific machine learning (SciML) glacier model, leveraging differentiable programming in Julia. This documentation provides the necessary information to understand the ecosystem built around ODINN.jl, its APIs, workflows and some examples of the main usage types of the model(s).","category":"section"},{"location":"#Quick-install","page":"Home","title":"Quick install","text":"ODINN.jl is a registered Julia package, so installing it is as easy as:\n\njulia> using Pkg\n\njulia> Pkg.add(\"ODINN\")\n\ninfo: Info\nODINN.jl and the rest of the ODINN ecosystem packages require Julia v1.10 or later, which are the ones used in the CI. ","category":"section"},{"location":"#Documentation-overview","page":"Home","title":"Documentation overview","text":"The documentation, which you can navigate through the left-hand-side panel, is structured in the following way:\n\nQuick start: Provides a straight-to-the-point example of a simple use-case of ODINN.jl to get an idea of the basic interface and style.\nTutorials: They provide clear examples of the main types of simulations and workflows that you can work with in ODINN.jl.\nHow to use ODINN: Explains the basic building blocks (i.e. types) used in ODINN.jl simulations, and how they are assembled together. \nInversions: Addresses more advanced questions related to inverse modelling, computing gradients, optimization and machine learning. \nCommunity: Explains the aspects related to how to contribute to the model(s), code style, building the documentation in local and the code of conduct. \nOngoing changes and future plans: Self-explanatory.\nReferences: List of scientific papers used in this documentation.","category":"section"},{"location":"#Vision","page":"Home","title":"Vision","text":"Rather than focusing on global-scale simulations and sea-level rise contributions, ODINN.jl has, for now, a regional and catchment-scale focus, aiming to exploit the latest remote sensing and in situ observations to capture missing or subgrid glacier processes. In order to do so, ODINN.jl leverages Universal Differential Equations (UDEs), combining PDEs describing ice flow dynamics with data-driven regressors, such as neural networks [1]. For this, ODINN.jl relies heavily on the SciML Julia ecosytem and the native automatic differentiation (AD) support. Therefore ODINN.jl has a two-fold goal:\n\nTo advance the application of scientific machine learning and differentiable programming for large-scale geoscientific modelling.\nTo advance the inference of new parametrizations to characterize key missing or subgrid processes of glaciers to improve large-scale glacier simulations. ","category":"section"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"ODINN.jl is a modular model, split into multiple packages, each one handling a specific task:\n\nODINN.j is the high-level interace to the whole ODINN ecosystem, containing the SciML functionalities related to automatic differentiation and sensitivity of hybrid models, mixing differential equations and data-driver regressors. \nHuginn.jl is the ice flow dynamics module of ODINN. It contains all the information regarding glacier ice flow models, including the numerical methods to solve the PDEs using OrdinaryDiffEq.jl. \nMuninn.jl is the surface mass balance module of ODINN. It  contains all the information regarding glacier interactions with the atmosphere (i.e. surface mass balance processes). For now we support simple temperature-index models, but soon we are planning to incorporate machine learning models coming from the MassBalanceMachine.\nSleipnir.jl is the core package of ODINN, holding all the basic data structures and functions, common to the whole ecosystem. It directly reads the files provided by Gungnir. \nGungnir is a Python package, using OGGM to retrieve all the necessary files (i.e. rasters and climate data) for the initial conditions and simulations in all the ODINN ecosystem. The user has the possibility to either store those files locally, or to use the ones we provide in a server. This is work in progress, so we will progressively cover more and more glaciers and regions in the near future.\n\n<img src=\"./assets/ODINN_ecosystem_v4.png\" alt=\"ODINN ecosystem overview\" width=\"700\"/>","category":"section"},{"location":"#Developers","page":"Home","title":"Developers","text":"ODINN.jl is being developed by Jordi Bolibar (CNRS, IGE), Facundo Sapienza (Stanford University) and Alban Gossard (Université Grenoble Alpes, IGE).\n\nPast developers include Mathieu Le Séac'h (Université Grenoble Alpes, IGE), Lucille Gimenes (Université Grenoble Alpes, IGE) and Vivek Gajadhar (TU Delft).","category":"section"},{"location":"#Citing","page":"Home","title":"Citing","text":"If you use ODINN.jl for research, teaching or other activities, please use the following citation from our latest paper:\n\n@article{bolibar_sapienza_universal_2023,\n\ttitle = {Universal differential equations for glacier ice flow modelling},\n\tauthor = {Bolibar, J. and Sapienza, F. and Maussion, F. and Lguensat, R. and Wouters, B. and P\\'erez, F.},\n\tjournal = {Geoscientific Model Development},\n\tvolume = {16},\n\tyear = {2023},\n\tnumber = {22},\n\tpages = {6671--6687},\n\turl = {https://gmd.copernicus.org/articles/16/6671/2023/},\n\tdoi = {10.5194/gmd-16-6671-2023}\n}","category":"section"},{"location":"#Funding","page":"Home","title":"Funding","text":"The ODINN project has been funded by an ANR TRACCS early career call, an IRGA fellowship from the Multidisciplinary Institute on Artificial Intelligence (Grenoble, France), the Nederlandse Organisatie voor Wetenschappelijk Onderzoek, Stichting voor de Technische Wetenschappen (Vidi grant 016.Vidi.171.063), the National Science Foundation (EarthCube programme under awards 1928406 and 1928374) and a TU Delft Climate Action grant. ","category":"section"}]
}
