<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ODINN.jl</title><meta name="title" content="API · ODINN.jl"/><meta property="og:title" content="API · ODINN.jl"/><meta property="twitter:title" content="API · ODINN.jl"/><meta name="description" content="Documentation for ODINN.jl."/><meta property="og:description" content="Documentation for ODINN.jl."/><meta property="twitter:description" content="Documentation for ODINN.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ODINN.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ODINN.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../forward_simulation/">Forward simulation</a></li><li><a class="tocitem" href="../functional_inversion/">Functional inversion</a></li></ul></li><li><a class="tocitem" href="../funcs_types/">Types and functions</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ODINN-SciML/ODINN.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This is an exhaustive list of all the types and functions in <code>ODINN.jl</code>, <code>Huginn.jl</code>, <code>Muninn.jl</code> and <code>Sleipnir.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.AbstractAdjointMethod-api" href="#ODINN.AbstractAdjointMethod-api"><code>ODINN.AbstractAdjointMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractAdjointMethod</code></pre><p>Abstract type representing the flavor of AD and adjoint to be used to compute the gradient of the cost function. There are two parts where one can play with how the gradient is propagated: the iceflow model VJP and the adjoint of the ODE solver. The VJP of the iceflow model can be computed using either AD (Zygote or Enzyme), the discrete, or the continuous adjoint of the iceflow model. As for the computation of the adjoint of the ODE solution, it can be handled by SciMLSensitivity, or computed using the adjoint implemented in ODINN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/AdjointTypes.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.AbstractVJPMethod-api" href="#ODINN.AbstractVJPMethod-api"><code>ODINN.AbstractVJPMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractVJPMethod</code></pre><p>Abstract type representing the flavor of AD to be used to compute the VJP inside the gradient of the cost function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/VJPTypes.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.ContinuousAdjoint-api" href="#ODINN.ContinuousAdjoint-api"><code>ODINN.ContinuousAdjoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ContinuousAdjoint{
    F &lt;: AbstractFloat,
    I &lt;: Integer,
    VJP &lt;: AbstractVJPMethod
    } &lt;: AbstractAdjointMethod</code></pre><p>Continuous adjoint of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><strong>Fields</strong></p><ul><li><code>VJP_method::VJP</code>: Type of AbstractVJPMethod used to compute VJPs inside adjoint   calculation.</li><li><code>solver::Any</code>: The solver to be used for adjoint.</li><li><code>reltol::F</code>: Relative tolerance to be used in the ODE solver of the adjoint.</li><li><code>abstol::F</code>: Absolute tolerance to be used in the ODE solver of the adjoint.</li><li><code>n_quadrature::I</code>: Number of nodes used in the Gauss quadrature for the numerical   integration of the loss function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/AdjointTypes.jl#L27-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.ContinuousVJP-api" href="#ODINN.ContinuousVJP-api"><code>ODINN.ContinuousVJP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Continuous manual implementation of the VJP required inside the adjoint calculation. It relies in the continuous expresion for the adjoint operation based on the functional for of the forward PDE.</p><p><code>ContinuousVJP</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/VJPTypes.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.DiscreteAdjoint-api" href="#ODINN.DiscreteAdjoint-api"><code>ODINN.DiscreteAdjoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscreteAdjoint{VJP &lt;: AbstractVJPMethod} &lt;: AbstractAdjointMethod</code></pre><p>Discrete adjoint of SIA2D with manual implementation of the backward in the ODE scheme.</p><p><strong>Fields</strong></p><ul><li><code>VJP_method</code>: Type of AbstractVJPMethod used to compute VJPs inside adjoint   calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/AdjointTypes.jl#L60-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.DiscreteVJP-api" href="#ODINN.DiscreteVJP-api"><code>ODINN.DiscreteVJP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Discrete manual implementation of the VJP required inside the adjoint calculation. This implements the pullback function for the function to differentiate.</p><p><code>DiscreteVJP</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/VJPTypes.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.DummyAdjoint-api" href="#ODINN.DummyAdjoint-api"><code>ODINN.DummyAdjoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Struct to provide a dummy gradient. It does not have to be the true gradient. Mainly used to test that the optimization pileline works independenly of the gradient calculation.</p><p><code>DummyAdjoint</code></p><p><strong>Fields:</strong></p><ul><li><code>grad::Function</code>: In-place function <code>f(du, u; kwargs)</code> that fills the first   argument <code>du</code> with the gradient values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/AdjointTypes.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.EnzymeVJP-api" href="#ODINN.EnzymeVJP-api"><code>ODINN.EnzymeVJP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Enzyme implementation of VJP used inside the adjoint calculation.</p><p><code>EnzymeVJP</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/VJPTypes.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.FunctionalInversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G&lt;:AbstractGlacier, M&lt;:Sleipnir.Model, P&lt;:Sleipnir.Parameters}-api" href="#ODINN.FunctionalInversion-Union{Tuple{P}, Tuple{M}, Tuple{G}, Tuple{M, Vector{G}, P}} where {G&lt;:AbstractGlacier, M&lt;:Sleipnir.Model, P&lt;:Sleipnir.Parameters}-api"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function FunctionalInversion(
    model::Sleipnir.Model,
    glaciers::Vector{G},
    parameters::Sleipnir.Parameters
) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Constructor for FunctionalInversion struct with glacier model information, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>FunctionalInversion</code>: A new instance of the FunctionalInversion struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/FunctionalInversion.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.FunctionalInversion-api" href="#ODINN.FunctionalInversion-api"><code>ODINN.FunctionalInversion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct FunctionalInversion &lt;: Simulation</code></pre><p>An object representing a functional inversion simulation (i.e. the inversion of a function using some data-driven regressor).</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the simulation.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the simulation.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the simulation.</li><li><code>results::Vector{Results}</code>: A vector to store the results of the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/FunctionalInversion.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Hyperparameters-Tuple{}-api" href="#ODINN.Hyperparameters-Tuple{}-api"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hyperparameters(; current_epoch::Int64 = 1, current_minibatch::Int64 = 1, loss_history::Vector{Float64} = Vector{Float64}(), optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule} = BFGS(initial_stepnorm=0.001), loss_epoch::Float64 = 0.0, epochs::Int64 = 50, batch_size::Int64 = 15)</code></pre><p>Constructs a <code>Hyperparameters</code> object with the specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>current_epoch::Int64</code>: The current epoch number. Defaults to 1.</li><li><code>current_minibatch::Int64</code>: The current minibatch number. Defaults to 1.</li><li><code>loss_history::Vector{Float64}</code>: A vector to store the history of loss values. Defaults to an empty vector.</li><li><code>optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}</code>: The optimizer to be used. Defaults to <code>BFGS(initial_stepnorm=0.001)</code>.</li><li><code>loss_epoch::Float64</code>: The loss value for the current epoch. Defaults to 0.0.</li><li><code>epochs::Int64</code>: The total number of epochs. Defaults to 50.</li><li><code>batch_size::Int64</code>: The size of each minibatch. Defaults to 15.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Hyperparameters</code> object initialized with the provided values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/Hyperparameters.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Hyperparameters-api" href="#ODINN.Hyperparameters-api"><code>ODINN.Hyperparameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Hyperparameters{F &lt;: AbstractFloat, I &lt;: Int} &lt;: AbstractParameters</code></pre><p>A mutable struct that holds hyperparameters for training a machine learning model.</p><p><strong>Keyword arguments</strong></p><ul><li><code>current_epoch::I</code>: The current epoch number.</li><li><code>current_minibatch::I</code>: The current minibatch number.</li><li><code>loss_history::Vector{F}</code>: A vector storing the history of loss values.</li><li><code>optimizer::Union{Optim.FirstOrderOptimizer, Flux.Optimise.AbstractOptimiser, Optimisers.AbstractRule}</code>: The optimizer used for training.</li><li><code>loss_epoch::F</code>: The loss value for the current epoch.</li><li><code>epochs::I</code>: The total number of epochs for training.</li><li><code>batch_size::I</code>: The size of each minibatch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/Hyperparameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier-api" href="#ODINN.Inversion-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier-api"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Inversion(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Create an <code>Inversion</code> object using the provided model, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model to be used for the inversion.</li><li><code>glaciers::Vector{G}</code>: A vector of glaciers, where each glacier is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters to be used for the inversion.</li></ul><p><strong>Returns</strong></p><ul><li><code>inversion</code>: An <code>Inversion</code> object initialized with the provided model, glaciers, and parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/inversions/Inversion.jl#L81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Inversion-api" href="#ODINN.Inversion-api"><code>ODINN.Inversion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Inversion &lt;: Simulation</code></pre><p>A mutable struct that represents an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the inversion.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the inversion.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the inversion.</li><li><code>inversion::Vector{InversionResults}</code>: A vector of results from the inversion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/inversions/Inversion.jl#L62-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#ODINN.InversionParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}(;
    initial_conditions::Vector{F} = [1.0],
    lower_bound::Vector{F} = [0.0],
    upper_bound::Vector{F} = [Inf],
    regions_split::Vector{Int} = [1, 1],
    x_tol::F = 1.0e-3,
    f_tol::F = 1.0e-3,
    solver = BFGS()
)</code></pre><p>Initialize the parameters for the inversion process.</p><p><strong>Arguments</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: Starting point for optimization.</li><li><code>lower_bound::Vector{F}</code>: Lower bounds for optimization variables.</li><li><code>upper_bound::Vector{F}</code>: Upper bounds for optimization variables.</li><li><code>regions_split::Vector{Int}</code>: Defines the amount of region split based on altitude and distance to border for the inversion process.</li><li><code>x_tol::F</code>: Tolerance for variables convergence.</li><li><code>f_tol::F</code>: Tolerance for function value convergence.</li><li><code>solver</code>: Optimization solver to be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/InversionParameters.jl#L27-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.InversionParameters-api" href="#ODINN.InversionParameters-api"><code>ODINN.InversionParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InversionParameters{F&lt;:AbstractFloat}</code></pre><p>A mutable struct that holds parameters for inversion processes. This struct is a subtype of <code>AbstractParameters</code>.</p><p><strong>Fields</strong></p><ul><li><code>initial_conditions::Vector{F}</code>: A vector of initial conditions.</li><li><code>lower_bound::Vector{F}</code>: A vector specifying the lower bounds for the parameters.</li><li><code>upper_bound::Vector{F}</code>: A vector specifying the upper bounds for the parameters.</li><li><code>regions_split::Vector{Int}</code>: A vector indicating how the regions are split.</li><li><code>x_tol::F</code>: The tolerance for the solution&#39;s x-values.</li><li><code>f_tol::F</code>: The tolerance for the function values.</li><li><code>solver::Any</code>: The solver to be used for the inversion process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/InversionParameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.InversionResults-api" href="#ODINN.InversionResults-api"><code>ODINN.InversionResults</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct InversionResults{F &lt;: Real}</code></pre><p>A structure to store the results of an inversion simulation.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::Union{String, Nothing}</code>: The RGI identifier, which can be a string or nothing.</li><li><code>A::F</code>: Area parameter.</li><li><code>n::F</code>: Exponent parameter.</li><li><code>C::Matrix{F}</code>: Coefficient matrix.</li><li><code>H_pred::Matrix{F}</code>: Predicted height matrix.</li><li><code>H_obs::Matrix{F}</code>: Observed height matrix.</li><li><code>H_diff::Matrix{F}</code>: Difference between predicted and observed height matrices.</li><li><code>V_pred::Matrix{F}</code>: Predicted volume matrix.</li><li><code>V_obs::Matrix{F}</code>: Observed volume matrix.</li><li><code>V_diff::Matrix{F}</code>: Difference between predicted and observed volume matrices.</li><li><code>MSE::F</code>: Mean squared error.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::F</code>: Longitude.</li><li><code>lat::F</code>: Latitude.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/inversions/Inversion.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.NeuralNetwork-Union{Tuple{TAR}, Tuple{NamedTupleType}, Tuple{ComponentArrayType}, Tuple{ChainType}, Tuple{P}} where {P&lt;:Sleipnir.Parameters, ChainType&lt;:Lux.Chain, ComponentArrayType&lt;:ComponentArrays.ComponentArray, NamedTupleType&lt;:NamedTuple, TAR&lt;:AbstractTarget}-api" href="#ODINN.NeuralNetwork-Union{Tuple{TAR}, Tuple{NamedTupleType}, Tuple{ComponentArrayType}, Tuple{ChainType}, Tuple{P}} where {P&lt;:Sleipnir.Parameters, ChainType&lt;:Lux.Chain, ComponentArrayType&lt;:ComponentArrays.ComponentArray, NamedTupleType&lt;:NamedTuple, TAR&lt;:AbstractTarget}-api"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NN(params::Parameters;
    architecture::Union{Flux.Chain, Nothing} = nothing,
    θ::Union{Vector{AbstractFloat}, Nothing} = nothing)</code></pre><p>Creates a new feed-forward neural network.</p><p><strong>Keyword arguments</strong></p><ul><li><code>architecture</code>: <code>Flux.Chain</code> neural network architecture (optional)</li><li><code>θ</code>: Neural network parameters (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/MLmodel.jl#L58-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.NeuralNetwork-api" href="#ODINN.NeuralNetwork-api"><code>ODINN.NeuralNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NeuralNetwork{
    ChainType &lt;: Lux.Chain,
    ComponentVectorType &lt;: ComponentVector,
    NamedTupleType &lt;: NamedTuple
} &lt;: MLmodel</code></pre><p>Feed-forward neural network.</p><p><strong>Fields</strong></p><ul><li><code>architecture::ChainType</code>: <code>Flux.Chain</code> neural network architecture</li><li><code>θ::ComponentVectorType</code>: Neural network parameters</li><li><code>st::NamedTupleType</code>: Neural network status</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/MLmodel.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SIA2D_D_target-api" href="#ODINN.SIA2D_D_target-api"><code>ODINN.SIA2D_D_target</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIA2D_D_target(; interpolation=:None, n_interp_half=20,
                 prescale=nothing, postscale=nothing)</code></pre><p>Inversion of general diffusivity as a function of physical parameters.</p><p>D(H, ∇S, θ) = H * NN(H, ∇S; θ)</p><p>So now we are learning the velocoty field given by D * ∇S. This inversion is similar to learnign the velocity field assuming that this is parallel to the gradient in surface ∇S.</p><p><strong>Arguments</strong></p><ul><li><code>interpolation::Symbol = :None</code>: Specifies the interpolation method. Options include <code>:Linear</code>, <code>:None</code>.</li><li><code>n_interp_half::Int = 20</code>: Half-width of the interpolation stencil. Determines resolution of interpolation.</li><li><code>prescale::Union{Fin, Nothing} = nothing</code>: Optional prescaling function or factor applied before parametrization. Must be of type <code>Fin</code> or <code>nothing</code>.</li><li><code>postscale::Union{Fout, Nothing} = nothing</code>: Optional postscaling function or factor applied after parametrization. Must be of type <code>Fout</code> or <code>nothing</code>.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>Fin</code>: Type of the prescale function or operator.</li><li><code>Fout</code>: Type of the postscale function or operator.</li></ul><p><strong>Supertype</strong></p><ul><li><code>AbstractSIA2DTarget</code>: Inherits from the abstract target type for 2D SIA modeling.</li></ul><p><strong>Returns</strong></p><ul><li>An instance of <code>SIA2D_D_target</code> configured with optional scaling and interpolation parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_D_pure.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SIA2D_foo_target-api" href="#ODINN.SIA2D_foo_target-api"><code>ODINN.SIA2D_foo_target</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create foo target for testing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_utils.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SciMLSensitivityAdjoint-api" href="#ODINN.SciMLSensitivityAdjoint-api"><code>ODINN.SciMLSensitivityAdjoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Struct that defines the SciMLSensitivity adjoint flavor. This is the default behavior in ODINN.</p><p><code>SciMLSensitivityAdjoint</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/AdjointTypes.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Int64}-api" href="#ODINN.TrainingStats-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Int64}-api"><code>ODINN.TrainingStats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function TrainingStats(;
    retcode::Union{String, Nothing} = nothing,
    losses::Vector{F} = Float64[],
    niter::I = 0
) where {F &lt;: AbstractFloat, I &lt;: Int}</code></pre><p>Constructor for TrainingStats object used to store important information during training. </p><p><strong>Arguments</strong></p><ul><li><code>retcode</code>: Report code of the optimization.</li><li><code>losses</code>: Vector storing the value of the loss function at each iteration. </li><li><code>niter</code>: Total number of iterations/epochs.</li><li><code>θ</code>: Parameters of neural network after training</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/training_stats/TrainingStats.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.TrainingStats-api" href="#ODINN.TrainingStats-api"><code>ODINN.TrainingStats</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct TrainingStats</code></pre><p>An object with the information of the training. </p><p><strong>Fields</strong></p><ul><li><code>retcode</code>: Report code of the optimization.</li><li><code>losses</code>: Vector storing the value of the loss function at each iteration. </li><li><code>niter</code>: Total number of iterations/epochs.</li><li><code>θ</code>: Parameters of neural network after training</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/training_stats/TrainingStats.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ&lt;:AbstractAdjointMethod-api" href="#ODINN.UDEparameters-Union{Tuple{}, Tuple{ADJ}} where ADJ&lt;:AbstractAdjointMethod-api"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UDEparameters(; sensealg, optim_autoAD, grad, optimization_method, loss_type, empirical_loss_function, scale_loss, target) where {ADJ &lt;: AbstractAdjointMethod}</code></pre><p>Create a <code>UDEparameters</code> object for configuring the sensitivity analysis and optimization of a Universal Differential Equation (UDE).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm</code>: The sensitivity algorithm to use for adjoint calculations. Defaults to <code>GaussAdjoint(autojacvec=SciMLSensitivity.EnzymeVJP())</code>.</li><li><code>optim_autoAD::AbstractADType</code>: The automatic differentiation type for optimization. Defaults to <code>Optimization.AutoEnzyme()</code>.</li><li><code>grad::ADJ</code>: The adjoint gradient computation method. Defaults to <code>SciMLSensitivityAdjoint()</code>.</li><li><code>optimization_method::String</code>: The optimization method to use. Must be either <code>&quot;AD+AD&quot;</code> or <code>&quot;AD+Diff&quot;</code>. Defaults to <code>&quot;AD+AD&quot;</code>.</li><li><code>loss_type::String</code>: The type of loss function to use. Must be either <code>&quot;V&quot;</code> (velocity) or <code>&quot;H&quot;</code> (thickness). Defaults to <code>&quot;V&quot;</code>.</li><li><code>empirical_loss_function::AbstractLoss</code>: The loss function to use for optimization. Defaults to <code>L2Sum()</code>.</li><li><code>scale_loss::Bool</code>: Whether to scale the loss function. Defaults to <code>true</code>.</li><li><code>target::Union{Symbol, Nothing}</code>: The target variable for optimization. Defaults to <code>:A</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UDEparameters</code> object configured with the specified sensitivity, optimization, and loss settings.</li></ul><p><strong>Description</strong></p><p>This function creates a <code>UDEparameters</code> object that encapsulates the configuration for sensitivity analysis, optimization, and loss computation in a Universal Differential Equation (UDE) framework. It verifies that the provided <code>optimization_method</code> and <code>loss_type</code> are valid and constructs the solver parameters accordingly.</p><p><strong>Notes</strong></p><ul><li>The <code>optimization_method</code> must be either <code>&quot;AD+AD&quot;</code> (automatic differentiation for both forward and backward passes) or <code>&quot;AD+Diff&quot;</code> (automatic differentiation combined with finite differences).</li><li>The <code>loss_type</code> must be either <code>&quot;V&quot;</code> (velocity-based loss) or <code>&quot;H&quot;</code> (thickness-based loss).</li><li>The <code>empirical_loss_function</code> determines how the loss is computed during optimization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/UDEparameters.jl#L33-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.UDEparameters-api" href="#ODINN.UDEparameters-api"><code>ODINN.UDEparameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct that holds parameters for a UDE (Universal Differential Equation).</p><pre><code class="nohighlight hljs">UDEparameters{ADJ &lt;: AbstractAdjointMethod} &lt;: AbstractParameters</code></pre><p><strong>Fields</strong></p><ul><li><code>sensealg::SciMLBase.AbstractAdjointSensitivityAlgorithm</code>: The sensitivity algorithm used for adjoint sensitivity analysis.</li><li><code>optimization_method::String</code>: The optimization method to be used.</li><li><code>loss_type::String</code>: The type of loss function to be used.</li><li><code>scale_loss::Bool</code>: A boolean indicating whether to scale the loss.</li><li><code>target::Symbol</code>: The target variable for the optimization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/UDEparameters.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.A_law_PatersonCuffey-Tuple{}-api" href="#ODINN.A_law_PatersonCuffey-Tuple{}-api"><code>ODINN.A_law_PatersonCuffey</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A_law_PatersonCuffey()</code></pre><p>Returns a law of the coefficient A as a polynomial of the temperature. The values used to fit the polynomial come from Peterson &amp; Cuffey.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.CallbackOptimizationSet-Tuple{Any, Any}-api" href="#ODINN.CallbackOptimizationSet-Tuple{Any, Any}-api"><code>ODINN.CallbackOptimizationSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CallbackOptimizationSet(θ, l; callbacks)</code></pre><p>Helper to combine callbacks for Optimization function. This executes the action of each callback.   (equivalent to CallbackSet for DifferentialEquations.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/callback_utils.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Diffusivity-Tuple{SIA2D_D_target}-api" href="#ODINN.Diffusivity-Tuple{SIA2D_D_target}-api"><code>ODINN.Diffusivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Diffusivity(target::SIA2D_D_target; H, ∇S, θ, iceflow_model, ml_model, glacier, params)</code></pre><p>Compute the effective diffusivity field for a 2D shallow ice model using the diagnostic <code>target</code> and  a predicted velocity matrix <code>U</code>.</p><p>This function uses a learned or specified model to estimate the velocity matrix <code>U</code>, then calculates the diffusivity as either <code>H .* U</code> (if dimensions match) or the averaged <code>H</code> times <code>U</code> if dimensions differ by one grid cell (staggered grid). Errors if dimensions are incompatible.</p><p><strong>Arguments</strong></p><ul><li><code>target::SIA2D_D_target</code>: Diagnostic target object defining interpolation and scaling rules.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: Ice thickness.</li><li><code>∇S</code>: Ice surface slope.</li><li><code>θ</code>: Parameters of the model.</li><li><code>iceflow_model</code>: Iceflow model used for simulation.</li><li><code>ml_model</code>: Machine learning model used for simulation.</li><li><code>glacier</code>: Glacier data.</li><li><code>params</code>: Model parameters.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix of diffusivity values with the same shape as <code>H</code> or staggered by one cell, depending on <code>U</code>.</li></ul><p><strong>Throws</strong></p><ul><li>An error if the dimensions of <code>U</code> and <code>H</code> are not compatible for diffusivity calculation.</li></ul><p><strong>Notes</strong></p><p>Uses <code>predict_U_matrix</code> internally to obtain velocity-like terms. Supports both grid-matched  and staggered configurations by averaging <code>H</code> where necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_D_pure.jl#L37-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Diffusivity_scalar-Tuple{SIA2D_D_target}-api" href="#ODINN.Diffusivity_scalar-Tuple{SIA2D_D_target}-api"><code>ODINN.Diffusivity_scalar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Diffusivity_scalar(target::SIA2D_D_target; h, ∇s, θ, iceflow_model, ml_model, glacier, params)</code></pre><p>Scalar version if Diffusivity().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_D_pure.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.GaussQuadrature-Tuple{Any, Any, Int64}-api" href="#ODINN.GaussQuadrature-Tuple{Any, Any, Int64}-api"><code>ODINN.GaussQuadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gauss Quadratrue for numerical integration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/gradient.jl#L256-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, MLM&lt;:ODINN.MLmodel}-api" href="#ODINN.Model-Union{Tuple{}, Tuple{MLM}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel, MLM&lt;:ODINN.MLmodel}-api"><code>ODINN.Model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Model(; iceflow::Union{IFM, Vector{IFM}, Nothing}, mass_balance::Union{MBM, Vector{MBM}, Nothing}, machine_learning::Union{MLM, Nothing}) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel, MLM &lt;: MLmodel}</code></pre><p>Creates a new model instance using the provided iceflow, mass balance, and machine learning components.</p><p><strong>Arguments</strong></p><ul><li><code>iceflow::Union{IFM, Vector{IFM}, Nothing}</code>: The iceflow model(s) to be used. Can be a single model, a vector of models, or <code>nothing</code>.</li><li><code>mass_balance::Union{MBM, Vector{MBM}, Nothing}</code>: The mass balance model(s) to be used. Can be a single model, a vector of models, or <code>nothing</code>.</li><li><code>machine_learning::Union{MLM, Nothing}</code>: The machine learning model to be used. Can be a single model or <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>model</code>: A new instance of <code>Sleipnir.Model</code> initialized with the provided components.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/MLmodel.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.Parameters-Tuple{}-api" href="#ODINN.Parameters-Tuple{}-api"><code>ODINN.Parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructor for the <code>Parameters</code> type. Since some of the subtypes of parameters are defined in different packages of the ODINN ecosystem, this constructor will call the constructors of the different subtypes and return a <code>Parameters</code> object with the corresponding subtypes.  The <code>Parameters</code> mutable struct is defined in <code>Sleipnir.jl</code> using abstract types, which are later on defined in the different packages of the ODINN ecosystem.</p><pre><code class="nohighlight hljs">Parameters(;
        physical::PhysicalParameters = PhysicalParameters(),
        simulation::SimulationParameters = SimulationParameters(),
        solver::SolverParameters = SolverParameters(),
        hyper::Hyperparameters = Hyperparameters(),
        UDE::UDEparameters = UDEparameters()
        inversion::InversionParameters = InversionParameters()
        )</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: Physical parameters for the simulation.</li><li><code>simulation::SimulationParameters</code>: Parameters related to the simulation setup.</li><li><code>solver::SolverParameters</code>: Parameters for the solver configuration.</li><li><code>hyper::Hyperparameters</code>: Hyperparameters for the model.</li><li><code>UDE::UDEparameters</code>: Parameters specific to the UDE (Universal Differential Equation).</li><li><code>inversion::InversionParameters</code>: Parameters for inversion processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/parameters/UDEparameters.jl#L87-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SIA2D_UDE!-Union{Tuple{I}, Tuple{R}, Tuple{Any, Matrix{R}, Matrix{R}, FunctionalInversion, Any, R, I}} where {R&lt;:Real, I&lt;:Integer}-api" href="#ODINN.SIA2D_UDE!-Union{Tuple{I}, Tuple{R}, Tuple{Any, Matrix{R}, Matrix{R}, FunctionalInversion, Any, R, I}} where {R&lt;:Real, I&lt;:Integer}-api"><code>ODINN.SIA2D_UDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>currently just use for Enzyme</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L400-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SIA2D_UDE-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Any, R, SIM, I}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api" href="#ODINN.SIA2D_UDE-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Any, R, SIM, I}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>ODINN.SIA2D_UDE</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper to pass a parametrization to the SIA2D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L376-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SIA2D_grad!-Tuple{Any, Any, FunctionalInversion}-api" href="#ODINN.SIA2D_grad!-Tuple{Any, Any, FunctionalInversion}-api"><code>ODINN.SIA2D_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Inverse with batch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/gradient.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.SIA2D_grad_batch!-Tuple{Any, FunctionalInversion}-api" href="#ODINN.SIA2D_grad_batch!-Tuple{Any, FunctionalInversion}-api"><code>ODINN.SIA2D_grad_batch!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Inverse by glacier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/gradient.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.VJP_λ_∂SIA_discrete-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api" href="#ODINN.VJP_λ_∂SIA_discrete-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA_discrete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA_discrete(
    ∂dH::Matrix{R},
    H::Matrix{R},
    simulation::SIM,
    t::R;
    batch_id::Union{Nothing, I} = nothing
)</code></pre><p>Compute an out-of-place adjoint step of the Shallow Ice Approximation PDE. Given an output gradient, it backpropagates the gradient to the inputs H and A. To some extent, this function is equivalent to VJP<em>λ</em>∂SIA∂H<em>continuous and VJP</em>λ<em>∂SIA∂θ</em>continuous.</p><p>Arguments:</p><ul><li><code>∂dH::Matrix{R}</code>: Output gradient to backpropagate.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li><li><code>batch_id::Union{Nothing, I}</code>: Batch index.</li></ul><p>Returns:</p><ul><li><code>∂H::Matrix{R}</code>: Input gradient wrt H.</li><li><code>∂A::F</code>: Input gradient wrt A.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/adjoint.jl#L9-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api" href="#ODINN.VJP_λ_∂SIA∂H_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA∂H_continuous</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂H_continuous(
    λ::Matrix{R},
    H::Matrix{R},
    simulation::SIM,
    t::R;
    batch_id::Union{Nothing, I} = nothing
)</code></pre><p>Implementation of the continuous adjoint of the SIA2D equation with respect to H. Given λ and H, it returns the VJP of λ^T * ∂(SIA2D)/∂H (H).</p><p>Arguments:</p><ul><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li><li><code>batch_id::Union{Nothing, I}</code>: Batch index.</li></ul><p>Returns:</p><ul><li><code>dλ::Matrix{R}</code>: Jacobian vector product, also called input gradient in reverse-mode AD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/adjoint.jl#L167-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api" href="#ODINN.VJP_λ_∂SIA∂θ_continuous-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, Any, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>ODINN.VJP_λ_∂SIA∂θ_continuous</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VJP_λ_∂SIA∂θ_continuous(
    θ,
    λ::Matrix{R},
    H::Matrix{R},
    simulation::SIM,
    t::R;
    batch_id::Union{Nothing, I} = nothing
)</code></pre><p>Implementation of the continuous adjoint of the SIA2D equation with respect to θ. Given λ, H and θ, it returns the VJP of λ^T * ∂(SIA2D)/∂θ (θ).</p><p>Arguments:</p><ul><li><code>θ</code>: Vector of parameters</li><li><code>λ::Matrix{R}</code>: Adjoint state, also called output gradient in reverse-mode AD.</li><li><code>H::Matrix{R}</code>: Ice thickness which corresponds to the input state of the SIA2D.</li><li><code>simulation::SIM</code>: Simulation parameters.</li><li><code>t::R</code>: Time value, not used as SIA2D is time independent.</li><li><code>batch_id::Union{Nothing, I}</code>: Batch index.</li></ul><p>Returns:</p><ul><li><code>dλ::Matrix{R}</code>: Jacobian vector product, also called input gradient in reverse-mode AD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/adjoint.jl#L300-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.apply_parametrization!-Tuple{SIA2D_D_target}-api" href="#ODINN.apply_parametrization!-Tuple{SIA2D_D_target}-api"><code>ODINN.apply_parametrization!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_D_pure.jl#L303-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.callback_diagnosis-Tuple{Any, Any, Any}-api" href="#ODINN.callback_diagnosis-Tuple{Any, Any, Any}-api"><code>ODINN.callback_diagnosis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">callback_diagnosis(θ, l, simulation)</code></pre><p>Callback function to track and diagose training. It includes print and updates in simulation::Simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/callback_utils.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.callback_plots_A-Tuple{Any, Any, Any}-api" href="#ODINN.callback_plots_A-Tuple{Any, Any, Any}-api"><code>ODINN.callback_plots_A</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">callback_plots_A(θ, l, simulation)</code></pre><p>Callback function to generate plots during training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/callback_utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.cap_D-Tuple{Any}-api" href="#ODINN.cap_D-Tuple{Any}-api"><code>ODINN.cap_D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Normalization of D to cap at a maximum physical value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_utils.jl#L125-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.create_interpolation-Tuple{Matrix}-api" href="#ODINN.create_interpolation-Tuple{Matrix}-api"><code>ODINN.create_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function create_interpolation(A::Matrix; n_interp_half::Int)</code></pre><p>Function to create an intepolation for AD computation combining uniform and quantiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_utils.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}-api" href="#ODINN.enable_multiprocessing-Tuple{Sleipnir.Parameters}-api"><code>ODINN.enable_multiprocessing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enable_multiprocessing(params::Sleipnir.Parameters) -&gt; Int</code></pre><p>Configures and enables multiprocessing based on the provided simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: A parameter object containing simulation settings,  including the number of workers (<code>params.simulation.workers</code>) and whether multiprocessing  is enabled (<code>params.simulation.multiprocessing</code>).</li></ul><p><strong>Behavior</strong></p><ul><li>If multiprocessing is enabled (<code>params.simulation.multiprocessing == true</code>) and the  specified number of workers (<code>params.simulation.workers</code>) is greater than 0:<ul><li>Adds the required number of worker processes if the current number of processes  (<code>nprocs()</code>) is less than the specified number of workers.</li><li>Suppresses precompilation output on the worker processes and ensures the <code>ODINN</code>  module is loaded on all workers.</li><li>If the specified number of workers is 1, removes all worker processes.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>The number of worker processes (<code>nworkers()</code>) after configuration.</li></ul><p><strong>Notes</strong></p><ul><li>This function uses <code>@eval</code> to dynamically add or remove worker processes.</li><li>Precompilation output is suppressed on workers to reduce noise in the console.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/setup/config.jl#L66-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.generate_batches-Tuple{S} where S&lt;:Simulation-api" href="#ODINN.generate_batches-Tuple{S} where S&lt;:Simulation-api"><code>ODINN.generate_batches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_batches(simulation::S; shuffle=false) where {S &lt;: Simulation}</code></pre><p>Generate a data loader for batching simulations, optionally shuffling the batches.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::S</code>: A <code>Simulation</code> object (or subtype of <code>Simulation</code>) containing the data to be batched.</li><li><code>shuffle::Bool=false</code>: A flag indicating whether to shuffle the batches. Defaults to <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataLoader</code> object that provides batched access to the simulation data.</li></ul><p><strong>Description</strong></p><p>This function creates a <code>DataLoader</code> for batching the provided simulation object. The <code>DataLoader</code> allows for efficient iteration over the simulation data in batches. The batch size is set to <code>1</code> by default, and the <code>shuffle</code> flag determines whether the batches are shuffled. If <code>shuffle</code> is enabled, a warning is logged to indicate that the batches used for parallelization are being shuffled.</p><p><strong>Notes</strong></p><ul><li>The batch size is fixed at <code>1</code> in this implementation. To modify the batch size, you may need to adjust the <code>DataLoader</code> initialization.</li><li>Shuffling the batches may affect reproducibility and parallelization behavior.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L358-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.generate_fake_A!-Union{Tuple{G}, Tuple{Vector{G}, Function}} where G&lt;:AbstractGlacier-api" href="#ODINN.generate_fake_A!-Union{Tuple{G}, Tuple{Vector{G}, Function}} where G&lt;:AbstractGlacier-api"><code>ODINN.generate_fake_A!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_fake_A!(glaciers::Vector{G}, fakeA::Function) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Generate and assign a fake flow rate factor <code>A</code> for a vector of glaciers based on their long-term temperatures.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{G}</code>: A vector of glacier objects of type <code>G</code>, where <code>G</code> is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>fakeA::Function</code>: A function that computes the flow rate factor <code>A</code> based on the mean long-term temperature of a glacier.</li></ul><p><strong>Description</strong></p><p>This function iterates over a vector of glaciers and computes the flow rate factor <code>A</code> for each glacier using the provided <code>fakeA</code> function. The flow rate factor is computed based on the mean of the glacier&#39;s long-term temperature (<code>longterm_temps</code>) and is assigned to the glacier&#39;s <code>A</code> property.</p><p><strong>Notes</strong></p><ul><li>The <code>fakeA</code> function should take a single argument (temperature) and return the corresponding flow rate factor.</li><li>This function modifies the <code>glaciers</code> vector in place by updating the <code>A</code> property of each glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L237-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.generate_glacier_prediction!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{Float64}}} where G&lt;:AbstractGlacier-api" href="#ODINN.generate_glacier_prediction!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters, Sleipnir.Model, Vector{Float64}}} where G&lt;:AbstractGlacier-api"><code>ODINN.generate_glacier_prediction!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate fake forward simulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/inverse/SIA2D/gradient.jl#L219-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Union{Function, Symbol, Polynomials.Polynomial}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}-api" href="#ODINN.generate_ground_truth-Union{Tuple{F}, Tuple{G}, Tuple{Vector{G}, Union{Function, Symbol, Polynomials.Polynomial}, Sleipnir.Parameters, Sleipnir.Model, Vector{F}}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat}-api"><code>ODINN.generate_ground_truth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_ground_truth(glaciers::Vector{G}, law::Symbol, params, model, tstops::Vector{F}) where {G &lt;: Sleipnir.AbstractGlacier, F &lt;: AbstractFloat}</code></pre><p>Generate ground truth data for a glacier simulation by applying a specified flow law and running a forward model.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{G}</code>: A vector of glacier objects of type <code>G</code>, where <code>G</code> is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>law::Symbol</code>: The flow law to use for the simulation. Currently supports <code>:PatersonCuffey</code>.</li><li><code>params</code>: Simulation parameters, typically of type <code>Sleipnir.Parameters</code>.</li><li><code>model</code>: The model to use for the simulation, typically of type <code>Sleipnir.Model</code>.</li><li><code>tstops::Vector{F}</code>: A vector of time steps (of type <code>F &lt;: AbstractFloat</code>) at which the simulation will be evaluated.</li></ul><p><strong>Description</strong></p><ol><li>Applies the specified flow law (<code>law</code>) to generate a polynomial function for the flow rate factor <code>A</code>.</li><li>Generates a fake flow rate factor <code>A</code> for each glacier based on the long-term temperature of the glacier.</li><li>Runs a forward model simulation for the glaciers using the provided parameters, model, and time steps.</li></ol><p><strong>Notes</strong></p><ul><li>If an unsupported flow law is provided, an error is logged.</li><li>The function modifies the <code>glaciers</code> vector in place by updating their flow rate factor <code>A</code> and running the forward model.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">glaciers = [glacier1, glacier2] # dummy example
law = :PatersonCuffey
params = Sleipnir.Parameters(...) # to be filled
model = Sleipnir.Model(...) # to be filled
tstops = 0.0:1.0:10.0

generate_ground_truth(glaciers, law, params, model, tstops)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L122-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.generate_simulation_batches-Tuple{FunctionalInversion}-api" href="#ODINN.generate_simulation_batches-Tuple{FunctionalInversion}-api"><code>ODINN.generate_simulation_batches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_simulation_batches(simulation::FunctionalInversion)</code></pre><p>Generate batches of simulations from a <code>FunctionalInversion</code> object for parallel or batched processing.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::FunctionalInversion</code>: A <code>FunctionalInversion</code> object containing the model, glaciers, parameters, results, and statistics for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>FunctionalInversion</code> objects, each representing a batch of simulations. Each batch contains a subset of glaciers, models, and results from the original simulation.</li></ul><p><strong>Description</strong></p><p>This function splits the glaciers and associated data in the <code>simulation</code> object into smaller batches for processing. Each batch is represented as a new <code>FunctionalInversion</code> object. The number of batches is determined by the <code>nbatches</code> variable (currently set to 1). If the simulation results are empty, the function creates batches with empty results. Otherwise, it includes the corresponding results for each glacier in the batches.</p><p><strong>Notes</strong></p><ul><li>The number of glaciers (<code>ninstances</code>) must be divisible by the number of batches (<code>nbatches</code>). An assertion is used to enforce this condition.</li><li>The function currently defaults to <code>nbatches = 1</code>, meaning no actual batching is performed. This can be updated to use <code>simulation.parameters.hyper.batchsize</code> for dynamic batching.</li><li>If the simulation results are empty, the function creates batches with empty results objects.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L311-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.get_default_NN-Tuple{Any, Any}-api" href="#ODINN.get_default_NN-Tuple{Any, Any}-api"><code>ODINN.get_default_NN</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_NN(θ_trained, ft; lightNN=false)</code></pre><p>Generates a neural network.</p><p><strong>Arguments</strong></p><ul><li><code>θ_trained</code>: Pre-trained neural network parameters (optional).</li><li><code>ft</code>: Float type used.</li><li><code>lightNN</code>: Boolean that determines if a light architecture is returned or not.</li></ul><p><strong>Returns</strong></p><ul><li><code>UA</code>: <code>Lux.Chain</code> neural network architecture.</li><li><code>θ</code>: Neural network parameters.</li><li><code>st</code>: Lux state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.get_rheology_law-Tuple{Function}-api" href="#ODINN.get_rheology_law-Tuple{Function}-api"><code>ODINN.get_rheology_law</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_rheology_law(law::Function)</code></pre><p>Return the provided rheology law function without modification.  This just uses multiple dispatch to handle cases where the rheology law is already a function.</p><p><strong>Arguments</strong></p><ul><li><code>law::Function</code>: A function representing the rheology law for the flow rate factor <code>A</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The input function <code>law</code>, unchanged.</li></ul><p><strong>Description</strong></p><p>This function is a simple bypass that uses multiple dispatch to handle cases where the rheology law is already provided as a function. It directly returns the input function without any modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L217-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.get_rheology_law-Tuple{Polynomials.Polynomial}-api" href="#ODINN.get_rheology_law-Tuple{Polynomials.Polynomial}-api"><code>ODINN.get_rheology_law</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_rheology_law(law::Polynomial)</code></pre><p>Convert a polynomial into a rheology law function for the flow rate factor <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>law::Polynomial</code>: A polynomial representing the rheology law for the flow rate factor <code>A</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A function <code>fakeA(T)</code> that computes the flow rate factor <code>A</code> for a given temperature <code>T</code> using the provided polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L200-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.get_rheology_law-Tuple{Symbol}-api" href="#ODINN.get_rheology_law-Tuple{Symbol}-api"><code>ODINN.get_rheology_law</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_rheology_law(law::Symbol)</code></pre><p>Retrieve the rheology law function for the flow rate factor <code>A</code> based on the specified law.</p><p><strong>Arguments</strong></p><ul><li><code>law::Symbol</code>: A symbol representing the rheology law to use. Currently supports <code>:PatersonCuffey</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A function <code>fakeA(T)</code> that computes the flow rate factor <code>A</code> for a given temperature <code>T</code> using the specified rheology law.</li></ul><p><strong>Description</strong></p><p>This function retrieves the parametrization law for the glacier&#39;s flow rate factor <code>A</code>. If the specified law is <code>:PatersonCuffey</code>, it uses the <code>A_law_PatersonCuffey</code> polynomial to define the flow rate factor as a function of temperature. If an unsupported law is provided, an error is logged.</p><p><strong>Notes</strong></p><ul><li>The returned function <code>fakeA(T)</code> can be used to compute the flow rate factor for a given temperature <code>T</code>.</li><li>If an unknown law is provided, the function logs an error and does not return a valid function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L171-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.merge_batches-Tuple{Vector}-api" href="#ODINN.merge_batches-Tuple{Vector}-api"><code>ODINN.merge_batches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_batches(results::Vector)</code></pre><p>Merge simulation results from multiple batches into a single collection.</p><p><strong>Arguments</strong></p><ul><li><code>results::Vector</code>: A vector where each element is a collection of results (e.g., arrays or vectors) from a batch.</li></ul><p><strong>Returns</strong></p><ul><li>A single collection containing all the merged results from the input batches.</li></ul><p><strong>Description</strong></p><p>This function takes a vector of results from multiple simulation batches and merges them into a single collection using vertical concatenation (<code>vcat</code>). It is useful for combining results that were processed in parallel or in separate batches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L340-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.normalize-Union{Tuple{Any}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#ODINN.normalize-Union{Tuple{Any}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.normalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize(X; lims::Tuple{F, F}; method = :shift) where {F &lt;: AbstractFloat}</code></pre><p>Normalize a variable by using an affine transformation defined by some input lower and upper bounds (m, M) and transforming to O(1) scale.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Input value.</li><li><code>lims::Tuple{F, F}</code>: Lower and upper bounds to use in the affine transformation.</li><li><code>method::Symbol</code>: Method to scale data.</li></ul><p><strong>Returns</strong></p><ul><li>The input variable scaled by the affine transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_utils.jl#L98-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.predict_A̅-Union{Tuple{F}, Tuple{Any, Any, Tuple{F, F}}} where F&lt;:AbstractFloat-api" href="#ODINN.predict_A̅-Union{Tuple{F}, Tuple{Any, Any, Tuple{F, F}}} where F&lt;:AbstractFloat-api"><code>ODINN.predict_A̅</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_A̅(U, temp, lims::Tuple{F, F}) where {F &lt;: AbstractFloat}</code></pre><p>Predicts the value of A with a neural network based on the long-term air temperature and on the bounds value to normalize the output of the neural network.</p><p><strong>Arguments</strong></p><ul><li><code>U</code>: Neural network.</li><li><code>temp</code>: Temperature to be fed as an input of the neural network.</li><li><code>lims::Tuple{F, F}</code>: Bounds to use for the affine transformation of the neural   network output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_A.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.predict_U_scalar-Union{Tuple{SIA2D_D_target}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#ODINN.predict_U_scalar-Union{Tuple{SIA2D_D_target}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>ODINN.predict_U_scalar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/target/target_D_pure.jl#L277-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.printProgressLoss-NTuple{4, Any}-api" href="#ODINN.printProgressLoss-NTuple{4, Any}-api"><code>ODINN.printProgressLoss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">printProgressLoss(iter, total_iters, loss, improvement)</code></pre><p>Print function to track training.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/callback_utils.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.run!-Tuple{FunctionalInversion}-api" href="#ODINN.run!-Tuple{FunctionalInversion}-api"><code>ODINN.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(simulation::FunctionalInversion)</code></pre><p>Run the training process for a given <code>FunctionalInversion</code> simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::FunctionalInversion</code>: The simulation object containing the parameters and settings for the functional inversion process.</li></ul><p><strong>Description</strong></p><p>This function initiates the training of a Universal Differential Equation (UDE) for the provided simulation. It prints a message indicating the start of the training process, calls the <code>train_UDE!</code> function to perform the training, and collects the results in <code>results_list</code>. The results are intended to be saved using <code>Sleipnir.save_results_file!</code>, but this step is currently commented out and will be enabled once the optimization is working. Finally, the garbage collector is triggered to free up memory.</p><p><strong>Notes</strong></p><ul><li>The <code>Sleipnir.save_results_file!</code> function call is currently commented out and should be enabled once the optimization process is confirmed to be working.</li><li>The garbage collector is explicitly run using <code>GC.gc()</code> to manage memory usage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.save_simulation_file!-Union{Tuple{SIM}, Tuple{Any, SIM}} where SIM&lt;:Simulation-api" href="#ODINN.save_simulation_file!-Union{Tuple{SIM}, Tuple{Any, SIM}} where SIM&lt;:Simulation-api"><code>ODINN.save_simulation_file!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This function saves the results of a simulation to a file in JLD2 format. If the <code>path</code> argument is not provided, the function will create a default path based on the current project directory. The results are saved in a file named <code>prediction_&lt;nglaciers&gt;glaciers_&lt;tspan&gt;.jld2</code>, where <code>&lt;nglaciers&gt;</code> is the number of glaciers in the simulation and <code>&lt;tspan&gt;</code> is the simulation time span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/results/result_utils.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, SciMLBase.DiscreteCallback, I}} where {I&lt;:Integer, SIM&lt;:Simulation}-api" href="#ODINN.simulate_iceflow_UDE!-Union{Tuple{SIM}, Tuple{I}, Tuple{Any, SIM, SciMLBase.DiscreteCallback, I}} where {I&lt;:Integer, SIM&lt;:Simulation}-api"><code>ODINN.simulate_iceflow_UDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function simulate<em>iceflow</em>UDE!(     θ,     simulation::SIM,     cb::DiscreteCallback,     batch_id::I;     du = Huginn.SIA2D) where {I &lt;: Integer, SIM &lt;: Simulation}</p><p>Make forward simulation of the iceflow UDE determined in <code>du</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L329-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.store_thickness_data!-Union{Tuple{F}, Tuple{Prediction, Vector{F}}} where F&lt;:AbstractFloat-api" href="#ODINN.store_thickness_data!-Union{Tuple{F}, Tuple{Prediction, Vector{F}}} where F&lt;:AbstractFloat-api"><code>ODINN.store_thickness_data!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">store_thickness_data!(prediction::Prediction, tstops::Vector{F}) where {F &lt;: AbstractFloat}</code></pre><p>Store the simulated thickness data in the corresponding glaciers within a <code>Prediction</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>prediction::Prediction</code>: A <code>Prediction</code> object containing the simulation results and associated glaciers.</li><li><code>tstops::Vector{F}</code>: A vector of time steps (of type <code>F &lt;: AbstractFloat</code>) at which the simulation was evaluated.</li></ul><p><strong>Description</strong></p><p>This function iterates over the glaciers in the <code>Prediction</code> object and stores the simulated thickness data (<code>H</code>) and corresponding time steps (<code>t</code>) in the <code>data</code> field of each glacier. If the <code>data</code> field is empty (<code>nothing</code>), it initializes it with the thickness data. Otherwise, it appends the new thickness data to the existing data.</p><p><strong>Notes</strong></p><ul><li>The function asserts that the time steps (<code>ts</code>) in the simulation results match the provided <code>tstops</code>. If they do not match, an error is raised.</li><li>T</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L261-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.train_UDE!-Tuple{FunctionalInversion, Optim.FirstOrderOptimizer}-api" href="#ODINN.train_UDE!-Tuple{FunctionalInversion, Optim.FirstOrderOptimizer}-api"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>BFGS Training</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.train_UDE!-Tuple{FunctionalInversion}-api" href="#ODINN.train_UDE!-Tuple{FunctionalInversion}-api"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>train_UDE!(simulation::FunctionalInversion)</p><p>Trains UDE based on the current FunctionalInversion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.train_UDE!-Union{Tuple{AR}, Tuple{FunctionalInversion, AR}} where AR&lt;:Optimisers.AbstractRule-api" href="#ODINN.train_UDE!-Union{Tuple{AR}, Tuple{FunctionalInversion, AR}} where AR&lt;:Optimisers.AbstractRule-api"><code>ODINN.train_UDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>ADAM Training</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/simulations/functional_inversions/functional_inversion_utils.jl#L129-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation-api" href="#ODINN.update_training_state!-Union{Tuple{S}, Tuple{S, Any}} where S&lt;:Simulation-api"><code>ODINN.update_training_state!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_training_state!(simulation::S, l) where {S &lt;: Simulation}</code></pre><p>Update the training state to determine if the training has completed an epoch. If an epoch is completed, reset the minibatches, update the history loss, and increment the epoch count.</p><p><strong>Arguments</strong></p><ul><li><code>simulation</code>: The current state of the simulation or training process.</li><li><code>l</code>: The current loss value or other relevant metric.</li></ul><p><strong>Returns</strong></p><ul><li>None. This function updates the state in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/ODINN.jl/blob/0b8fb88016aa5207304f7901a1b21e888774dc76/src/models/machine_learning/ML_utils.jl#L390-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.IceflowModel-api" href="#Huginn.IceflowModel-api"><code>Huginn.IceflowModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IceflowModel</code></pre><p>An abstract type representing the base model for ice flow simulations. All specific ice flow models should subtype this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/IceflowModel.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier-api" href="#Huginn.Prediction-Union{Tuple{G}, Tuple{Sleipnir.Model, Vector{G}, Sleipnir.Parameters}} where G&lt;:AbstractGlacier-api"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prediction(model::Sleipnir.Model, glaciers::Vector{G}, parameters::Sleipnir.Parameters) where {G &lt;: Sleipnir.AbstractGlacier}</code></pre><p>Create a <code>Prediction</code> object using the given model, glaciers, and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for prediction.</li><li><code>glaciers::Vector{G}</code>: A vector of glacier objects, where each glacier is a subtype of <code>Sleipnir.AbstractGlacier</code>.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the prediction.</li></ul><p><strong>Returns</strong></p><ul><li><code>Prediction</code>: A <code>Prediction</code> object based on the input values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/Prediction.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.Prediction-api" href="#Huginn.Prediction-api"><code>Huginn.Prediction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prediction &lt;: Simulation</code></pre><p>A mutable struct that represents a prediction simulation.</p><p><strong>Fields</strong></p><ul><li><code>model::Sleipnir.Model</code>: The model used for the prediction.</li><li><code>glaciers::Vector{Sleipnir.AbstractGlacier}</code>: A vector of glaciers involved in the prediction.</li><li><code>parameters::Sleipnir.Parameters</code>: The parameters used for the prediction.</li><li><code>results::Vector{Results}</code>: A vector of results obtained from the prediction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/Prediction.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2Dmodel-Union{Tuple{Sleipnir.Parameters}, Tuple{R}, Tuple{I}} where {I&lt;:Integer, R&lt;:Real}-api" href="#Huginn.SIA2Dmodel-Union{Tuple{Sleipnir.Parameters}, Tuple{R}, Tuple{I}} where {I&lt;:Integer, R&lt;:Real}-api"><code>Huginn.SIA2Dmodel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIA2Dmodel(
    params::Sleipnir.Parameters;
    A::Union{R, Nothing} = nothing,
    n::Union{R, Nothing} = nothing,
    C::Union{R, Matrix{R}, Nothing} = nothing,
    H₀::Matrix{R} = Matrix{Sleipnir.Float}([;;]),
    H::Union{Matrix{R}, Nothing} = nothing,
    H̄::Union{Matrix{R}, Nothing} = nothing,
    S::Matrix{R} = Matrix{Sleipnir.Float}([;;]),
    dSdx::Union{Matrix{R}, Nothing} = nothing,
    dSdy::Union{Matrix{R}, Nothing} = nothing,
    D::Union{Matrix{R}, Nothing} = nothing,
    D_is_provided::Union{Bool, Nothing} = nothing,
    Dx::Union{Matrix{R}, Nothing} = nothing,
    Dy::Union{Matrix{R}, Nothing} = nothing,
    dSdx_edges::Union{Matrix{R}, Nothing} = nothing,
    dSdy_edges::Union{Matrix{R}, Nothing} = nothing,
    ∇S::Union{Matrix{R}, Nothing} = nothing,
    ∇Sy::Union{Matrix{R}, Nothing} = nothing,
    ∇Sx::Union{Matrix{R}, Nothing} = nothing,
    Fx::Union{Matrix{R}, Nothing} = nothing,
    Fy::Union{Matrix{R}, Nothing} = nothing,
    Fxx::Union{Matrix{R}, Nothing} = nothing,
    Fyy::Union{Matrix{R}, Nothing} = nothing,
    V::Union{Matrix{R}, Nothing} = nothing,
    Vx::Union{Matrix{R}, Nothing} = nothing,
    Vy::Union{Matrix{R}, Nothing} = nothing,
    Γ::Union{R, Nothing} = nothing,
    MB::Union{Matrix{R}, Nothing} = nothing,
    MB_mask::Union{BitMatrix, Nothing} = nothing,
    MB_total::Union{Matrix{R}, Nothing} = nothing,
    glacier_idx::Union{I, Nothing} = nothing
) where {I &lt;: Integer, R &lt;: Real}</code></pre><p>Constructs a new <code>SIA2Dmodel</code> object with the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: Simulation parameters.</li><li><code>A::Union{R, Nothing}</code>: Flow law parameter (default: <code>nothing</code>).</li><li><code>n::Union{R, Nothing}</code>: Flow law exponent (default: <code>nothing</code>).</li><li><code>C::Union{R, Matrix{R}, Nothing}</code>: Basal sliding parameter (default: <code>nothing</code>).</li><li><code>H₀::Matrix{R}</code>: Initial ice thickness (default: empty matrix).</li><li><code>H::Union{Matrix{R}, Nothing}</code>: Ice thickness (default: <code>nothing</code>).</li><li><code>H̄::Union{Matrix{R}, Nothing}</code>: Averaged ice thickness (default: <code>nothing</code>).</li><li><code>S::Matrix{R}</code>: Surface elevation (default: empty matrix).</li><li><code>dSdx::Union{Matrix{R}, Nothing}</code>: Surface slope in x-direction (default: <code>nothing</code>).</li><li><code>dSdy::Union{Matrix{R}, Nothing}</code>: Surface slope in y-direction (default: <code>nothing</code>).</li><li><code>D::Union{Matrix{R}, Nothing}</code>: Diffusivity (default: <code>nothing</code>).</li><li><code>D_is_provided::Union{Bool, Nothing}</code>: Specifies if D is provided by user or computed (default: <code>false</code>).</li><li><code>Dx::Union{Matrix{R}, Nothing}</code>: Diffusivity in x-direction (default: <code>nothing</code>).</li><li><code>Dy::Union{Matrix{R}, Nothing}</code>: Diffusivity in y-direction (default: <code>nothing</code>).</li><li><code>dSdx_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in x-direction (default: <code>nothing</code>).</li><li><code>dSdy_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in y-direction (default: <code>nothing</code>).</li><li><code>∇S::Union{Matrix{R}, Nothing}</code>: Gradient of surface elevation (default: <code>nothing</code>).</li><li><code>∇Sy::Union{Matrix{R}, Nothing}</code>: Gradient of surface elevation in y-direction (default: <code>nothing</code>).</li><li><code>∇Sx::Union{Matrix{R}, Nothing}</code>: Gradient of surface elevation in x-direction (default: <code>nothing</code>).</li><li><code>Fx::Union{Matrix{R}, Nothing}</code>: Flux in x-direction (default: <code>nothing</code>).</li><li><code>Fy::Union{Matrix{R}, Nothing}</code>: Flux in y-direction (default: <code>nothing</code>).</li><li><code>Fxx::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in x-direction (default: <code>nothing</code>).</li><li><code>Fyy::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in y-direction (default: <code>nothing</code>).</li><li><code>V::Union{Matrix{R}, Nothing}</code>: Velocity (default: <code>nothing</code>).</li><li><code>Vx::Union{Matrix{R}, Nothing}</code>: Velocity in x-direction (default: <code>nothing</code>).</li><li><code>Vy::Union{Matrix{R}, Nothing}</code>: Velocity in y-direction (default: <code>nothing</code>).</li><li><code>Γ::Union{R, Nothing}</code>: Auxiliary matrix (default: <code>nothing</code>).</li><li><code>MB::Union{Matrix{R}, Nothing}</code>: Mass balance (default: <code>nothing</code>).</li><li><code>MB_mask::Union{BitMatrix, Nothing}</code>: Mask for mass balance (default: <code>nothing</code>).</li><li><code>MB_total::Union{Matrix{R}, Nothing}</code>: Total mass balance (default: <code>nothing</code>).</li><li><code>glacier_idx::Union{I, Nothing}</code>: Index of the glacier (default: <code>nothing</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>SIA2Dmodel</code>: A new <code>SIA2Dmodel</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D.jl#L80-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2Dmodel-api" href="#Huginn.SIA2Dmodel-api"><code>Huginn.SIA2Dmodel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct SIA2Dmodel{R &lt;: Real, I &lt;: Integer} &lt;: SIAmodel</code></pre><p>A mutable struct representing a 2D Shallow Ice Approximation (SIA) model.</p><p><strong>Fields</strong></p><ul><li><code>A::Union{Ref{R}, Nothing}</code>: Flow rate factor.</li><li><code>n::Union{Ref{R}, Nothing}</code>: Flow law exponent.</li><li><code>C::Union{Ref{R}, Matrix{R}, Nothing}</code>: Sliding coefficient.</li><li><code>H₀::Matrix{R}</code>: Initial ice thickness.</li><li><code>H::Union{Matrix{R}, Nothing}</code>: Ice thickness.</li><li><code>H̄::Union{Matrix{R}, Nothing}</code>: Averaged ice thickness.</li><li><code>S::Matrix{R}</code>: Surface elevation.</li><li><code>dSdx::Union{Matrix{R}, Nothing}</code>: Surface slope in the x-direction.</li><li><code>dSdy::Union{Matrix{R}, Nothing}</code>: Surface slope in the y-direction.</li><li><code>D::Union{Matrix{R}, Nothing}</code>: Diffusivity.</li><li><code>D_is_provided::Union{Bool, Nothing}</code>: Specifies if D is provided by user or computed.</li><li><code>Dx::Union{Matrix{R}, Nothing}</code>: Diffusivity in the x-direction.</li><li><code>Dy::Union{Matrix{R}, Nothing}</code>: Diffusivity in the y-direction.</li><li><code>dSdx_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in the x-direction.</li><li><code>dSdy_edges::Union{Matrix{R}, Nothing}</code>: Surface slope at edges in the y-direction.</li><li><code>∇S::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation.</li><li><code>∇Sy::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation in the y-direction.</li><li><code>∇Sx::Union{Matrix{R}, Nothing}</code>: Gradient of the surface elevation in the x-direction.</li><li><code>Fx::Union{Matrix{R}, Nothing}</code>: Flux in the x-direction.</li><li><code>Fy::Union{Matrix{R}, Nothing}</code>: Flux in the y-direction.</li><li><code>Fxx::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in the x-direction.</li><li><code>Fyy::Union{Matrix{R}, Nothing}</code>: Second derivative of flux in the y-direction.</li><li><code>V::Union{Matrix{R}, Nothing}</code>: Velocity.</li><li><code>Vx::Union{Matrix{R}, Nothing}</code>: Velocity in the x-direction.</li><li><code>Vy::Union{Matrix{R}, Nothing}</code>: Velocity in the y-direction.</li><li><code>Γ::Union{Ref{R}, Nothing}</code>: Basal shear stress.</li><li><code>MB::Union{Matrix{R}, Nothing}</code>: Mass balance.</li><li><code>MB_mask::Union{AbstractArray{Bool}, Nothing}</code>: Mask for mass balance.</li><li><code>MB_total::Union{Matrix{R}, Nothing}</code>: Total mass balance.</li><li><code>glacier_idx::Union{Ref{I}, Nothing}</code>: Index of the glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D.jl#L10-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIAmodel-api" href="#Huginn.SIAmodel-api"><code>Huginn.SIAmodel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIAmodel</code></pre><p>An abstract type representing the Shallow Ice Approximation (SIA) models. This type is a subtype of <code>IceflowModel</code> and serves as a base for all SIA-specific models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/IceflowModel.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api" href="#Huginn.SolverParameters-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructs a <code>SolverParameters</code> object with the specified parameters or using default values.</p><pre><code class="nohighlight hljs">SolverParameters(; solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = RDPK3Sp35(),
                  reltol::F = 1e-12,
                  step::F = 1.0/12.0,
                  tstops::Union{Nothing,Vector{F}} = nothing,
                  save_everystep = false,
                  progress::Bool = true,
                  progress_steps::I = 10) where {F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm</code>: The ODE solver algorithm to use. Defaults to <code>RDPK3Sp35()</code>.</li><li><code>reltol::F</code>: The relative tolerance for the solver. Defaults to <code>1e-12</code>.</li><li><code>step::F</code>: The step size for the callbacks. These are mainly used to run the surface mass balance model. Defaults to <code>1.0/12.0</code> (i.e. a month).</li><li><code>tstops::Union{Nothing, Vector{F}}</code>: Optional vector of time points where the solver should stop. Defaults to <code>nothing</code>.</li><li><code>save_everystep::Bool</code>: Whether to save the solution at every step. Defaults to <code>false</code>.</li><li><code>progress::Bool</code>: Whether to show progress during the solving process. Defaults to <code>true</code>.</li><li><code>progress_steps::I</code>: The number of steps between progress updates. Defaults to <code>10</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>solver_parameters</code>: A <code>SolverParameters</code> object constructed with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/parameters/SolverParameters.jl#L27-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SolverParameters-api" href="#Huginn.SolverParameters-api"><code>Huginn.SolverParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct that holds parameters for the solver.</p><pre><code class="nohighlight hljs">SolverParameters{F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Fields</strong></p><ul><li><code>solver::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm</code>: The algorithm used for solving differential equations.</li><li><code>reltol::F</code>: The relative tolerance for the solver.</li><li><code>step::F</code>: The step size for the solver.</li><li><code>tstops::Union{Nothing, Vector{F}}</code>: Optional vector of time points where the solver should stop for the callbacks.</li><li><code>save_everystep::Bool</code>: Flag indicating whether to save the solution at every step.</li><li><code>progress::Bool</code>: Flag indicating whether to show progress during the solving process.</li><li><code>progress_steps::I</code>: The number of steps between progress updates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/parameters/SolverParameters.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.H_from_V-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation-api" href="#Huginn.H_from_V-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation-api"><code>Huginn.H_from_V</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">H_from_V(V::Matrix{&lt;:Real}, simulation::SIM) where {SIM &lt;: Simulation}</code></pre><p>Compute the ice thickness <code>H</code> from the velocity <code>V</code> for a given simulation.</p><p><strong>Arguments</strong></p><ul><li><code>V::Matrix{&lt;:Real}</code>: A matrix representing the velocity of ice.</li><li><code>simulation::SIM</code>: An instance of a simulation, which must be a subtype of <code>Simulation</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::Matrix{&lt;:Real}</code>: A matrix representing the computed ice thickness.</li></ul><p><strong>Description</strong></p><p>This function calculates the ice thickness <code>H</code> based on the provided velocity <code>V</code> and the parameters from the <code>simulation</code> object. It uses various physical parameters and constants defined in the <code>simulation</code> to perform the computation. The function also handles NaN and Inf values in the resulting ice thickness matrix by replacing them with 0.0.</p><p><strong>Details</strong></p><ul><li>The function first extracts necessary parameters from the <code>simulation</code> object, including physical constants and glacier properties.</li><li>It updates the glacier surface altimetry and computes surface gradients on edges using staggered grid variables.</li><li>The surface stress <code>Γꜛ</code> is calculated based on the provided parameters.</li><li>The ice thickness <code>H</code> is then computed using the velocity <code>V</code> and the surface stress <code>Γꜛ</code>.</li><li>Finally, the function replaces any <code>NaN</code> or <code>Inf</code> values in the resulting ice thickness matrix with 0.0 and returns the matrix <code>H</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L421-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.Model-Union{Tuple{}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel}-api" href="#Huginn.Model-Union{Tuple{}, Tuple{MBM}, Tuple{IFM}} where {IFM&lt;:IceflowModel, MBM&lt;:MBmodel}-api"><code>Huginn.Model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function Model(;     iceflow::Union{IFM, Nothing},     mass_balance::Union{MBM, Nothing}     ) where {IFM &lt;: IceflowModel, MBM &lt;: MBmodel}</p><p>Initialize Model at Huginn level (no machine learning model).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/IceflowModel.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api" href="#Huginn.SIA2D!-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>Huginn.SIA2D!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIA2D!(dH::Matrix{R}, H::Matrix{R}, simulation::SIM, t::R) where {R &lt;:Real, SIM &lt;: Simulation}</code></pre><p>Simulates the evolution of ice thickness in a 2D shallow ice approximation (SIA) model. Works in-place.</p><p><strong>Arguments</strong></p><ul><li><code>dH::Matrix{R}</code>: Matrix to store the rate of change of ice thickness.</li><li><code>H::Matrix{R}</code>: Matrix representing the ice thickness.</li><li><code>simulation::SIM</code>: Simulation object containing model parameters and state.</li><li><code>t::R</code>: Current simulation time.</li></ul><p><strong>Details</strong></p><p>This function updates the ice thickness <code>H</code> and computes the rate of change <code>dH</code> using the shallow ice approximation in 2D. It retrieves necessary parameters from the <code>simulation</code> object, enforces positive ice thickness values, updates glacier surface altimetry, computes surface gradients, flux components, and flux divergence.</p><p><strong>Notes</strong></p><ul><li>The function operates on a staggered grid for computing gradients and fluxes.</li><li>Surface elevation differences are capped using upstream ice thickness to impose boundary conditions.</li><li>The function modifies the input matrices <code>dH</code> and <code>H</code> in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api" href="#Huginn.SIA2D-Union{Tuple{SIM}, Tuple{I}, Tuple{R}, Tuple{Matrix{R}, SIM, R}} where {R&lt;:Real, I&lt;:Integer, SIM&lt;:Simulation}-api"><code>Huginn.SIA2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SIA2D(H::Matrix{R}, simulation::SIM, t::R; batch_id::Union{Nothing, I} = nothing) where {R &lt;: Real, I &lt;: Integer, SIM &lt;: Simulation}</code></pre><p>Compute the change in ice thickness (<code>dH</code>) for a 2D Shallow Ice Approximation (SIA) model. Works out-of-place.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{R}</code>: Ice thickness matrix.</li><li><code>simulation::SIM</code>: Simulation object containing model parameters and glacier data.</li><li><code>t::R</code>: Current time step.</li><li><code>batch_id::Union{Nothing, I}</code>: Optional batch ID to select a specific glacier model. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>dH::Matrix{R}</code>: Matrix representing the change in ice thickness.</li></ul><p><strong>Details</strong></p><p>This function performs the following steps:</p><ol><li>Retrieves the appropriate iceflow model and glacier data based on <code>batch_id</code>.</li><li>Retrieves physical parameters from the simulation object.</li><li>Ensures that ice thickness values are non-negative.</li><li>Updates the glacier surface altimetry.</li><li>Computes surface gradients on the edges of the grid.</li><li>Calculates the diffusivity <code>D</code> based on the surface gradients and ice thickness.</li><li>Computes the flux components <code>Fx</code> and <code>Fy</code>.</li><li>Calculates the flux divergence to determine the change in ice thickness <code>dH</code>.</li></ol><p><strong>Notes</strong></p><ul><li>The function uses <code>@views</code> to avoid unnecessary array allocations.</li><li>The <code>@tullio</code> macro is used for efficient tensor operations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L113-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.V_from_H-Union{Tuple{SIM}, Tuple{F}, Tuple{I}, Tuple{SIM, Matrix{F}}} where {I&lt;:Integer, F&lt;:AbstractFloat, SIM&lt;:Simulation}-api" href="#Huginn.V_from_H-Union{Tuple{SIM}, Tuple{F}, Tuple{I}, Tuple{SIM, Matrix{F}}} where {I&lt;:Integer, F&lt;:AbstractFloat, SIM&lt;:Simulation}-api"><code>Huginn.V_from_H</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">V_from_H(
    simulation::SIM,
    H::Matrix{F};
    batch_id::Union{Nothing, I}=nothing
) where {I &lt;: Integer, F &lt;: AbstractFloat, SIM &lt;: Simulation}</code></pre><p>Compute surface velocity from ice thickness using the SIA model. It relies on <code>surface_V</code> to compute <code>Vx</code> and <code>Vy</code> and it additionally computes the magnitude of the velocity <code>V</code>.</p><p>Arguments:</p><ul><li><code>simulation::SIM</code>: The simulation structure used to retrieve the physical   parameters.</li><li><code>H::Matrix{F}</code>: The ice thickness matrix.</li><li><code>batch_id::Union{Nothing, I}=nothing</code>: The batch ID that is used to retrieve the   iceflow model in <code>surface_V</code>.</li></ul><p>Returns:</p><ul><li><code>Vx</code>: x axis component of the surface velocity.</li><li><code>Vy</code>: y axis component of the surface velocity.</li><li><code>V</code>: Magnitude velocity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L477-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg!-Tuple{Any, Any}-api" href="#Huginn.avg!-Tuple{Any, Any}-api"><code>Huginn.avg!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg!(O, I)</code></pre><p>Compute the average of adjacent elements in the input array <code>I</code> and store the result in the output array <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the averaged values will be stored.</li><li><code>I</code>: Input array from which the adjacent elements will be averaged.</li></ul><p><strong>Details</strong></p><p>This function uses the <code>@views</code> macro to avoid creating temporary arrays and the <code>@.</code> macro to broadcast the operations. The averaging is performed by taking the mean of each 2x2 block of elements in <code>I</code> and storing the result in the corresponding element in <code>O</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg-Tuple{Any}-api" href="#Huginn.avg-Tuple{Any}-api"><code>Huginn.avg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg(A::AbstractArray)</code></pre><p>Compute the average of each 2x2 block in the input array <code>A</code>. The result is an array where each element is the average of the corresponding 2x2 block in <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: A 2D array of numerical values.</li></ul><p><strong>Returns</strong></p><ul><li>A 2D array of the same type as <code>A</code>, where each element is the average of a 2x2 block from <code>A</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg_surface_V!-Tuple{SIM} where SIM&lt;:Simulation-api" href="#Huginn.avg_surface_V!-Tuple{SIM} where SIM&lt;:Simulation-api"><code>Huginn.avg_surface_V!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_surface_V!(simulation::SIM) where {SIM &lt;: Simulation}</code></pre><p>Calculate the average surface velocity for a given simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: A simulation object of type <code>SIM</code> which is a subtype of <code>Simulation</code>.</li></ul><p><strong>Description</strong></p><p>This function computes the average surface velocity components (<code>Vx</code> and <code>Vy</code>) and the resultant velocity (<code>V</code>) for the ice flow model within the given simulation. It first calculates the surface velocities at the initial and current states, then averages these velocities and updates the ice flow model&#39;s velocity fields.</p><p><strong>Notes</strong></p><ul><li>The function currently uses a simple averaging method and may need more datapoints for better interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L221-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I&lt;:Integer, SIM&lt;:Simulation}-api" href="#Huginn.avg_surface_V-Union{Tuple{SIM}, Tuple{I}} where {I&lt;:Integer, SIM&lt;:Simulation}-api"><code>Huginn.avg_surface_V</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_surface_V(simulation::SIM; batch_id::Union{Nothing, I} = nothing) where {I &lt;: Integer, SIM &lt;: Simulation}</code></pre><p>Compute the average surface velocity for a given simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: The simulation object containing the model and other relevant data.</li><li><code>batch_id::Union{Nothing, I}</code>: An optional batch identifier. If provided, it specifies which batch of the iceflow model to use. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>V̄x</code>: The average surface velocity in the x-direction.</li><li><code>V̄y</code>: The average surface velocity in the y-direction.</li><li><code>V</code>: The magnitude of the average surface velocity.</li></ul><p><strong>Details</strong></p><p>This function computes the initial and final surface velocities and averages them to obtain the average surface velocity. It handles simulations that use reverse differentiation by selecting the appropriate iceflow model for each glacier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L249-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg_x!-Tuple{Any, Any}-api" href="#Huginn.avg_x!-Tuple{Any, Any}-api"><code>Huginn.avg_x!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_x!(O, I)</code></pre><p>Compute the average of adjacent elements along the first dimension of array <code>I</code> and store the result in array <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the averaged values will be stored.</li><li><code>I</code>: Input array from which adjacent elements will be averaged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg_x-Tuple{Any}-api" href="#Huginn.avg_x-Tuple{Any}-api"><code>Huginn.avg_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_x(A::AbstractArray)</code></pre><p>Compute the average of adjacent elements along the first dimension of the array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: Input array.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> with one less element along the first dimension, containing the averages of adjacent elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L93-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg_y!-Tuple{Any, Any}-api" href="#Huginn.avg_y!-Tuple{Any, Any}-api"><code>Huginn.avg_y!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_y!(O, I)</code></pre><p>Compute the average of adjacent elements along the second dimension of array <code>I</code> and store the result in array <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the averaged values will be stored.</li><li><code>I</code>: Input array from which the adjacent elements will be averaged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.avg_y-Tuple{Any}-api" href="#Huginn.avg_y-Tuple{Any}-api"><code>Huginn.avg_y</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">avg_y(A::AbstractArray)</code></pre><p>Compute the average of adjacent elements along the second dimension of the input array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: An array of numeric values.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> containing the averages of adjacent elements along the second dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L106-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer-api" href="#Huginn.batch_iceflow_PDE!-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer-api"><code>Huginn.batch_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE!(glacier_idx::I, simulation::Prediction)</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE for a given temperature series batch in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/prediction_utils.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer-api" href="#Huginn.batch_iceflow_PDE-Union{Tuple{I}, Tuple{I, Prediction}} where I&lt;:Integer-api"><code>Huginn.batch_iceflow_PDE</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batch_iceflow_PDE(glacier_idx::I, simulation::Prediction)</code></pre><p>Solve the Shallow Ice Approximation iceflow PDE for a given temperature series batch out-of-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/prediction_utils.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F&lt;:AbstractFloat-api" href="#Huginn.define_callback_steps-Union{Tuple{F}, Tuple{Tuple{F, F}, F}} where F&lt;:AbstractFloat-api"><code>Huginn.define_callback_steps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">define_callback_steps(tspan::Tuple{F, F}, step::F) where {F &lt;: AbstractFloat}</code></pre><p>Defines the times to stop for the DiscreteCallback given a step and a timespan.</p><p><strong>Arguments</strong></p><ul><li><code>tspan::Tuple{Float64, Float64}</code>: A tuple representing the start and end times.</li><li><code>step::Float64</code>: The step size for generating the callback steps.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: A vector of callback steps within the specified time span.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/parameters/SolverParameters.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.diff_x!-Tuple{Any, Any, Any}-api" href="#Huginn.diff_x!-Tuple{Any, Any, Any}-api"><code>Huginn.diff_x!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_x!(O, I, Δx)</code></pre><p>Compute the finite difference of array <code>I</code> along the first dimension and store the result in array <code>O</code>. The difference is computed using the spacing <code>Δx</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array to store the finite differences.</li><li><code>I</code>: Input array from which finite differences are computed.</li><li><code>Δx</code>: Spacing between points in the first dimension.</li></ul><p><strong>Notes</strong></p><ul><li>The function uses <code>@views</code> to avoid copying data when slicing arrays.</li><li>The operation is performed in-place, modifying the contents of <code>O</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.diff_x-Tuple{Any}-api" href="#Huginn.diff_x-Tuple{Any}-api"><code>Huginn.diff_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_x(A::AbstractArray)</code></pre><p>Compute the difference along the first dimension of the array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: Input array.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> containing the differences along the first dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.diff_y!-Tuple{Any, Any, Any}-api" href="#Huginn.diff_y!-Tuple{Any, Any, Any}-api"><code>Huginn.diff_y!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_y!(O, I, Δy)</code></pre><p>Compute the finite difference along the y-axis and store the result in <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>O</code>: Output array where the result will be stored.</li><li><code>I</code>: Input array from which the finite difference is computed.</li><li><code>Δy</code>: The spacing between points in the y-direction.</li></ul><p><strong>Description</strong></p><p>This function calculates the finite difference along the y-axis for the input array <code>I</code> and stores the result in the output array <code>O</code>. The calculation is performed using the formula:</p><pre><code class="nohighlight hljs">O = (I[:,begin+1:end] - I[:,1:end - 1]) / Δy</code></pre><p>The <code>@views</code> macro is used to avoid copying data when slicing the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.diff_y-Tuple{Any}-api" href="#Huginn.diff_y-Tuple{Any}-api"><code>Huginn.diff_y</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_y(A::AbstractArray)</code></pre><p>Compute the difference between adjacent elements along the second dimension (columns) of the input array <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: An array of numeric values.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type as <code>A</code> containing the differences between adjacent elements along the second dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L132-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.generate_result-Union{Tuple{SIM}, Tuple{SIM, Any, Any}} where SIM&lt;:Simulation-api" href="#Huginn.generate_result-Union{Tuple{SIM}, Tuple{SIM, Any, Any}} where SIM&lt;:Simulation-api"><code>Huginn.generate_result</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_result(simulation::SIM, A, n) where {SIM &lt;: Simulation}</code></pre><p>Generate the result of a simulation by initializing the model with the specified parameters and running the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: An instance of a type that is a subtype of <code>Simulation</code>.</li><li><code>A</code>: The parameter to set for <code>simulation.model.iceflow.A</code>.</li><li><code>n</code>: The parameter to set for <code>simulation.model.iceflow.n</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>result</code>: The first result from the simulation&#39;s results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/plotting/plotting_utils.jl#L102-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.halfar_solution-Tuple{Any, Any, Any, Any, Any, Any, PhysicalParameters}-api" href="#Huginn.halfar_solution-Tuple{Any, Any, Any, Any, Any, Any, PhysicalParameters}-api"><code>Huginn.halfar_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">halfar_solution(R, t, h₀, r₀, A, n, physical_parameters::PhysicalParameters)</code></pre><p>Return the evaluation of the Halfar solution for the SIA equation.</p><p>Arguments:</p><ul><li><code>R</code>: Radial distance. The solution has polar symmetry around the center of origin.</li><li><code>t</code>: Time.</li><li><code>h₀</code> and <code>r₀</code>: Parameters of the Halfar solution.</li><li><code>A</code>: Glen&#39;s law parameter.</li><li><code>n</code>: Creep exponent.</li><li><code>physical_parameters::PhysicalParameters</code>: Physical parameters that allow   retrieving the ice density and the gravity constant.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/solutions/halfar.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer, G&lt;:AbstractGlacier}-api" href="#Huginn.initialize_iceflow_model!-Union{Tuple{G}, Tuple{I}, Tuple{IF}, Tuple{IF, I, G, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer, G&lt;:AbstractGlacier}-api"><code>Huginn.initialize_iceflow_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function initialize<em>iceflow</em>model!(     iceflow<em>model::IF,     glacier</em>idx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable in-place mutation.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `iceflow_model`: Iceflow model used for simulation.
- `glacier_idx`: Index of glacier.
- `glacier`: `Glacier` to provide basic initial state of the ice flow model.
- `parameters`: `Parameters` to configure some physical variables.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D.jl#L213-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer}-api" href="#Huginn.initialize_iceflow_model-Union{Tuple{I}, Tuple{IF}, Tuple{IF, I, AbstractGlacier, Sleipnir.Parameters}} where {IF&lt;:IceflowModel, I&lt;:Integer}-api"><code>Huginn.initialize_iceflow_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function initialize<em>iceflow</em>model(     iceflow<em>model::IF,     glacier</em>idx::I,     glacier::AbstractGlacier,     params::Sleipnir.Parameters ) where {IF &lt;: IceflowModel, I &lt;: Integer}</p><p>Initialize iceflow model data structures to enable out-of-place mutation.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `iceflow_model`: Iceflow model used for simulation.
- `glacier_idx`: Index of glacier.
- `glacier`: `Glacier` to provide basic initial state of the ice flow model.
- `parameters`: `Parameters` to configure some physical variables.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D.jl#L271-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.inn-Tuple{Any}-api" href="#Huginn.inn-Tuple{Any}-api"><code>Huginn.inn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inn(A::AbstractArray)</code></pre><p>Extracts the inner part of a 2D array <code>A</code>, excluding the first and last rows and columns.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: A 2D array from which the inner part will be extracted.</li></ul><p><strong>Returns</strong></p><ul><li>A subarray of <code>A</code> containing all elements except the first and last rows and columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L145-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.inn1-Tuple{Any}-api" href="#Huginn.inn1-Tuple{Any}-api"><code>Huginn.inn1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inn1(A::AbstractArray)</code></pre><p>Returns a view of the input array <code>A</code> excluding the last row and the last column.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The input array from which a subarray view is created.</li></ul><p><strong>Returns</strong></p><ul><li>A view of the input array <code>A</code> that includes all elements except the last row and the last column.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/iceflow_utils.jl#L158-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.run!-Tuple{Prediction}-api" href="#Huginn.run!-Tuple{Prediction}-api"><code>Huginn.run!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run!(simulation::Prediction)</code></pre><p>In-place run of the model. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/prediction_utils.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.run₀-Tuple{Prediction}-api" href="#Huginn.run₀-Tuple{Prediction}-api"><code>Huginn.run₀</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run(simulation::Prediction)</code></pre><p>Out-of-place run of the model. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/prediction_utils.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation-api" href="#Huginn.simulate_iceflow_PDE!-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation-api"><code>Huginn.simulate_iceflow_PDE!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function simulate_iceflow_PDE!(
    simulation::SIM,
    cb::DiscreteCallback;
    du = SIA2D!) where {SIM &lt;: Simulation}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/prediction_utils.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation-api" href="#Huginn.simulate_iceflow_PDE-Union{Tuple{SIM}, Tuple{SIM, SciMLBase.DiscreteCallback}} where SIM&lt;:Simulation-api"><code>Huginn.simulate_iceflow_PDE</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function simulate_iceflow_PDE(
    simulation::SIM,
    cb::DiscreteCallback;
    du = SIA2D) where {SIM &lt;: Simulation}</code></pre><p>Make forward simulation of the iceflow PDE determined in <code>du</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/simulations/predictions/prediction_utils.jl#L156-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation-api" href="#Huginn.surface_V!-Union{Tuple{SIM}, Tuple{Matrix{&lt;:Real}, SIM}} where SIM&lt;:Simulation-api"><code>Huginn.surface_V!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_V!(H::Matrix{&lt;:Real}, simulation::SIM) where {SIM &lt;: Simulation}</code></pre><p>Compute the surface velocities of a glacier using the Shallow Ice Approximation (SIA) in 2D.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{&lt;:Real}</code>: The ice thickness matrix.</li><li><code>simulation::SIM</code>: The simulation object containing parameters and model information.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vx</code>: The x-component of the surface velocity.</li><li><code>Vy</code>: The y-component of the surface velocity.</li></ul><p><strong>Description</strong></p><p>This function updates the glacier surface altimetry and computes the surface gradients on edges using a staggered grid. It then calculates the surface velocities based on the Shallow Ice Approximation (SIA) model.</p><p><strong>Details</strong></p><ul><li><code>params</code>: The simulation parameters.</li><li><code>iceflow_model</code>: The ice flow model from the simulation.</li><li><code>glacier</code>: The glacier object from the simulation.</li><li><code>B</code>: The bedrock elevation matrix.</li><li><code>H̄</code>: The average ice thickness matrix.</li><li><code>dSdx</code>, <code>dSdy</code>: The surface gradient matrices in x and y directions.</li><li><code>∇S</code>, <code>∇Sx</code>, <code>∇Sy</code>: The gradient magnitude and its components.</li><li><code>Γꜛ</code>: The surface stress.</li><li><code>D</code>: The diffusivity matrix.</li><li><code>A</code>: The flow rate factor.</li><li><code>n</code>: The flow law exponent.</li><li><code>Δx</code>, <code>Δy</code>: The grid spacing in x and y directions.</li><li><code>ρ</code>: The ice density.</li><li><code>g</code>: The gravitational acceleration.</li></ul><p>The function computes the surface gradients, averages the ice thickness, and calculates the surface stress and diffusivity. Finally, it computes the surface velocities <code>Vx</code> and <code>Vy</code> based on the gradients and diffusivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L285-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I&lt;:Integer, R&lt;:Real, SIM&lt;:Simulation}-api" href="#Huginn.surface_V-Union{Tuple{SIM}, Tuple{R}, Tuple{I}, Tuple{Matrix{R}, SIM}} where {I&lt;:Integer, R&lt;:Real, SIM&lt;:Simulation}-api"><code>Huginn.surface_V</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_V(H::Matrix{R}, simulation::SIM; batch_id::Union{Nothing, I} = nothing) where {I &lt;: Integer, R &lt;: Real, SIM &lt;: Simulation}</code></pre><p>Compute the surface velocities of a glacier using the Shallow Ice Approximation (SIA) in 2D.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{R}</code>: Ice thickness matrix.</li><li><code>simulation::SIM</code>: Simulation object containing parameters and model information.</li><li><code>batch_id::Union{Nothing, I}</code>: Optional batch identifier for simulations using reverse differentiation. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vx</code>: Matrix of surface velocities in the x-direction.</li><li><code>Vy</code>: Matrix of surface velocities in the y-direction.</li></ul><p><strong>Details</strong></p><p>This function computes the surface velocities of a glacier by updating the glacier surface altimetry and calculating the surface gradients on the edges. It uses a staggered grid approach to compute the gradients and velocities.</p><p><strong>Notes</strong></p><ul><li>The function assumes that the <code>simulation</code> object contains the necessary parameters and model information.</li><li>The <code>batch_id</code> is used to handle simulations that require an iceflow model per glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Huginn.jl/blob/v0.9.5/src/models/iceflow/SIA2D/SIA2D_utils.jl#L363-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.MBmodel-api" href="#Muninn.MBmodel-api"><code>Muninn.MBmodel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MBmodel &lt;: AbstractModel</code></pre><p>An abstract type representing a mass balance model in the Muninn package.  This serves as a base type for all specific mass balance models, ensuring  they adhere to a common interface and can be used interchangeably within  the ODINN framework.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel-api" href="#Muninn.TImodel-api"><code>Muninn.TImodel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel &lt;: MBmodel</code></pre><p>An abstract type representing a temperature index mass balance models within the ODINN framework.  This type serves as a parent type for more specialized mass balance models, ensuring they adhere to  a common interface defined by the <code>MBmodel</code> abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#Muninn.TImodel1-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel1(params::Sleipnir.Parameters; DDF::F = 7.0/1000.0, acc_factor::F = 1.0/1000.0) where {F &lt;: AbstractFloat}</code></pre><p>Create a temperature index model with one degree-day factor (DDF) with the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Sleipnir.Parameters</code>: The simulation parameters.</li><li><code>DDF::F</code>: Degree-day factor (default is 7.0/1000.0).</li><li><code>acc_factor::F</code>: Accumulation factor (default is 1.0/1000.0).</li></ul><p><strong>Returns</strong></p><ul><li><code>TI1_model</code>: An instance of TImodel1 with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel1-api" href="#Muninn.TImodel1-api"><code>Muninn.TImodel1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel1{F &lt;: AbstractFloat}</code></pre><p>A structure representing a temperature index model with degree-day factor and accumulation factor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>DDF::F</code>: Degree-day factor, which is a coefficient used to convert temperature into melt.</li><li><code>acc_factor::F</code>: Accumulation factor, which is a coefficient used to adjust the accumulation of mass.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: A subtype of <code>AbstractFloat</code> representing the type of the factors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#Muninn.TImodel2-Union{Tuple{Sleipnir.Parameters}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Muninn.TImodel2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel2(params::Parameters; DDF_snow::F = 3.0/1000.0, DDF_ice::F = 6.0/1000.0, acc_factor::F = 1.0/1000.0) where {F &lt;: AbstractFloat}</code></pre><p>Create a temperature-index model with two degree-day factors (TImodel2) for mass balance calculations.</p><p><strong>Arguments</strong></p><ul><li><code>params::Parameters</code>: The parameters object containing simulation settings.</li><li><code>DDF_snow::F</code>: Degree-day factor for snow (default: 3.0/1000.0).</li><li><code>DDF_ice::F</code>: Degree-day factor for ice (default: 6.0/1000.0).</li><li><code>acc_factor::F</code>: Accumulation factor (default: 1.0/1000.0).</li></ul><p><strong>Returns</strong></p><ul><li><code>TI2_model</code>: An instance of the TImodel2 with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L87-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.TImodel2-api" href="#Muninn.TImodel2-api"><code>Muninn.TImodel2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TImodel2{F &lt;: AbstractFloat}</code></pre><p>A type representing a temperature-index model with parameters for snow and ice degree-day factors, and an accumulation factor.</p><p><strong>Keyword arguments</strong></p><ul><li><code>DDF_snow::F</code>: Degree-day factor for snow, which determines the melt rate of snow per degree above the melting point.</li><li><code>DDF_ice::F</code>: Degree-day factor for ice, which determines the melt rate of ice per degree above the melting point.</li><li><code>acc_factor::F</code>: Accumulation factor, which scales the accumulation of snow.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>F</code>: A subtype of <code>AbstractFloat</code>, representing the numeric type used for the model parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/MBmodel.jl#L68-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I&lt;:Integer, F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api" href="#Muninn.MB_timestep!-Union{Tuple{G}, Tuple{F}, Tuple{I}, Tuple{Sleipnir.Model, G, F, Any}} where {I&lt;:Integer, F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api"><code>Muninn.MB_timestep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MB_timestep!(model::Model, glacier::G, step::F, t; batch_id::Union{Nothing, I} = nothing) where {I &lt;: Integer, F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Simulates a mass balance timestep for a given glacier model.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The glacier model containing iceflow and mass balance information.</li><li><code>glacier::G</code>: The glacier object containing climate and DEM data.</li><li><code>step::F</code>: The timestep duration.</li><li><code>t</code>: The current time.</li><li><code>batch_id::Union{Nothing, I}</code>: Optional batch identifier for simulations using Reverse Diff. Defaults to <code>nothing</code>.</li></ul><p><strong>Description</strong></p><p>This function performs the following steps:</p><ol><li>Computes the period from the previous timestep to the current time.</li><li>Retrieves cumulative climate data for the specified period.</li><li>Downscales the climate dataset to a 2D grid based on the glacier&#39;s DEM.</li><li>Computes the mass balance for the glacier and updates the model&#39;s iceflow mass balance.</li></ol><p>If <code>batch_id</code> is provided, the function updates the mass balance for the specified batch; otherwise, it updates the mass balance for the entire model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/mass_balance_utils.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api" href="#Muninn.MB_timestep-Union{Tuple{G}, Tuple{F}, Tuple{Sleipnir.Model, G, F, F}} where {F&lt;:AbstractFloat, G&lt;:AbstractGlacier}-api"><code>Muninn.MB_timestep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MB_timestep(model::Model, glacier::G, step::F, t::F) where {F &lt;: AbstractFloat, G &lt;: AbstractGlacier}</code></pre><p>Calculate the mass balance (MB) for a glacier over a given timestep.</p><p><strong>Keyword arguments</strong></p><ul><li><code>model::Model</code>: The model containing mass balance parameters.</li><li><code>glacier::G</code>: The glacier object containing climate and DEM data.</li><li><code>step::F</code>: The timestep duration.</li><li><code>t::F</code>: The current time.</li></ul><p><strong>Returns</strong></p><ul><li><code>MB::Matrix{F}</code>: The computed mass balance matrix for the given timestep.</li></ul><p><strong>Details</strong></p><ol><li>Computes the period between the current time <code>t</code> and the previous step <code>t - step</code>.</li><li>Retrieves cumulative climate data for the specified period.</li><li>Downscales the climate data to a 2D grid based on the glacier&#39;s DEM.</li><li>Computes the mass balance using the downscaled climate data.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/mass_balance_utils.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}-api" href="#Muninn.compute_MB-Tuple{TImodel1, Climate2Dstep}-api"><code>Muninn.compute_MB</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_MB(mb_model::TImodel1, climate_2D_period::Climate2Dstep)</code></pre><p>Compute the mass balance (MB) for a given mass balance model and climate period.</p><p><strong>Arguments</strong></p><ul><li><code>mb_model::TImodel1</code>: The mass balance model containing parameters such as accumulation factor (<code>acc_factor</code>) and degree-day factor (<code>DDF</code>).</li><li><code>climate_2D_period::Climate2Dstep</code>: The climate data for a specific period, including snow accumulation (<code>snow</code>) and positive degree days (<code>PDD</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A numerical array representing the computed mass balance, calculated as the difference between the product of the accumulation factor and snow, and the product of the degree-day factor and positive degree days.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Muninn.jl/blob/v0.6.1/src/models/mass_balance/mass_balance_utils.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.AbstractData-api" href="#Sleipnir.AbstractData-api"><code>Sleipnir.AbstractData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractData</code></pre><p>Abstract type that represents data. Used to implement <code>ThicknessData</code> and <code>SurfaceVelocityData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/Data.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.AbstractGlacier-api" href="#Sleipnir.AbstractGlacier-api"><code>Sleipnir.AbstractGlacier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGlacier</code></pre><p>An abstract type representing a glacier. This serves as a base type for different glacier implementations in the <code>Sleipnir</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/Glacier2D.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.AbstractModel-api" href="#Sleipnir.AbstractModel-api"><code>Sleipnir.AbstractModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractModel</code></pre><p>An abstract type that serves as a base for all model types in ODINN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/models/Model.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.AbstractParameters-api" href="#Sleipnir.AbstractParameters-api"><code>Sleipnir.AbstractParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    AbstractParameters</code></pre><p>An abstract type that serves as a base for all parameter-related types in the ODINN ecosystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/Parameters.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Climate2D-api" href="#Sleipnir.Climate2D-api"><code>Sleipnir.Climate2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct representing a 2D climate for a glacier with various buffers and datasets.</p><pre><code class="nohighlight hljs">Climate2D{F &lt;: AbstractFloat}</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>raw_climate::RasterStack</code>: Raw climate dataset for the whole simulation.</li><li><code>climate_raw_step::RasterStack</code>: Raw climate trimmed for the current step to avoid memory allocations.</li><li><code>climate_step::Dict</code>: Climate data for the current step.</li><li><code>climate_2D_step::Climate2Dstep</code>: 2D climate data for the current step to feed to the mass balance (MB) model.</li><li><code>longterm_temps::Vector{F}</code>: Long-term temperatures for the ice rheology.</li><li><code>avg_temps::F</code>: Intermediate buffer for computing average temperatures.</li><li><code>avg_gradients::F</code>: Intermediate buffer for computing average gradients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/Climate2D.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Climate2Dstep-api" href="#Sleipnir.Climate2Dstep-api"><code>Sleipnir.Climate2Dstep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Climate2Dstep{F &lt;: AbstractFloat}</code></pre><p>A mutable struct representing a 2D climate time step with various climate-related parameters.</p><p><strong>Keyword arguments</strong></p><ul><li><code>temp::Matrix{F}</code>: Temperature matrix.</li><li><code>PDD::Matrix{F}</code>: Positive Degree Days matrix.</li><li><code>snow::Matrix{F}</code>: Snowfall matrix.</li><li><code>rain::Matrix{F}</code>: Rainfall matrix.</li><li><code>gradient::F</code>: Gradient value.</li><li><code>avg_gradient::F</code>: Average gradient value.</li><li><code>x::Vector{F}</code>: X-coordinates vector.</li><li><code>y::Vector{F}</code>: Y-coordinates vector.</li><li><code>ref_hgt::F</code>: Reference height.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/Climate2D.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api" href="#Sleipnir.Glacier1D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><code>Sleipnir.Glacier1D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>function Glacier1D(;     rgi<em>id::Union{String, Nothing} = nothing,     climate::Union{Climate1D, Nothing} = nothing,     H₀::Union{Vector{F}, Nothing} = nothing,     S::Union{Vector{F}, Nothing} = nothing,     B::Union{Vector{F}, Nothing} = nothing,     V::Union{Vector{F}, Nothing}= nothing,     A::Union{F, Nothing} = nothing,     C::Union{F, Nothing} = nothing,     n::Union{F, Nothing} = nothing,     w₀::Union{Vector{F}, Nothing} = nothing,     λ::Union{Vector{F}, Nothing} = nothing,     slope::Union{Vector{F}, Nothing} = nothing,     dist</em>border::Union{Vector{F}, Nothing} = nothing,     Coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,     Δx::Union{F, Nothing} = nothing,     Δy::Union{F, Nothing} = nothing,     nx::Union{I, Nothing} = nothing,     ny::Union{I, Nothing} = nothing     ) where {F &lt;: AbstractFloat, I &lt;: Integer}</p><p>Constructor for empty 2D Glacier object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/Glacier1D.jl#L29-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api" href="#Sleipnir.Glacier2D-Union{Tuple{}, Tuple{I}, Tuple{F}} where {F&lt;:AbstractFloat, I&lt;:Integer}-api"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructs a <code>Glacier2D</code> object with the given parameters, including default ones.</p><pre><code class="nohighlight hljs">Glacier2D(;
    rgi_id::Union{String, Nothing} = nothing,
    name::String = &quot;&quot;,
    climate::Union{Climate2D, Nothing} = nothing,
    H₀::Union{Matrix{F}, Nothing} = nothing,
    H_glathida::Union{Matrix{F}, Nothing} = nothing,
    S::Union{Matrix{F}, Nothing} = nothing,
    B::Union{Matrix{F}, Nothing} = nothing,
    V::Union{Matrix{F}, Nothing} = nothing,
    Vx::Union{Matrix{F}, Nothing} = nothing,
    Vy::Union{Matrix{F}, Nothing} = nothing,
    A::Union{F, Nothing} = nothing,
    C::Union{F, Nothing} = nothing,
    n::Union{F, Nothing} = nothing,
    slope::Union{Matrix{F}, Nothing} = nothing,
    dist_border::Union{Matrix{F}, Nothing} = nothing,
    Coords::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,
    Δx::Union{F, Nothing} = nothing,
    Δy::Union{F, Nothing} = nothing,
    nx::Union{I, Nothing} = nothing,
    ny::Union{I, Nothing} = nothing,
    cenlon::Union{F, Nothing} = nothing,
    cenlat::Union{F, Nothing} = nothing,
    params_projection::Dict{String, Float64} = Dict{String, Float64}(),
    thicknessData::Union{ThicknessData, Nothing} = nothing,
    velocityData::Union{SurfaceVelocityData, Nothing} = nothing,
) where {F &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI identifier for the glacier.</li><li><code>name::String</code>: The name of the glacier if available.</li><li><code>climate::Union{Climate2D, Nothing}</code>: The climate data associated with the glacier.</li><li><code>H₀::Union{Matrix{F}, Nothing}</code>: Initial ice thickness matrix.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness matrix from GLATHIDA.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix.</li><li><code>B::Matrix{F}</code>: Bed elevation matrix.</li><li><code>V::Union{Matrix{F}, Nothing}</code>: Ice velocity magnitude matrix.</li><li><code>Vx::Union{Matrix{F}, Nothing}</code>: Ice velocity in the x-direction matrix.</li><li><code>Vy::Union{Matrix{F}, Nothing}</code>: Ice velocity in the y-direction matrix.</li><li><code>A::Union{F, Nothing}</code>: Flow law parameter.</li><li><code>C::Union{F, Nothing}</code>: Sliding law parameter.</li><li><code>n::Union{F, Nothing}</code>: Flow law exponent.</li><li><code>slope::Union{Matrix{F}, Nothing}</code>: Slope matrix.</li><li><code>dist_border::Union{Matrix{F}, Nothing}</code>: Distance to border matrix.</li><li><code>Coords::Union{Dict{String, Vector{Float64}}, Nothing}</code>: Coordinates dictionary with keys &quot;lon&quot; and &quot;lat&quot;.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>cenlon::Union{F, Nothing}</code>: Central longitude of the glacier.</li><li><code>cenlat::Union{F, Nothing}</code>: Central latitude of the glacier.</li><li><code>params_projection::Dict{String, Float64}</code>: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.</li><li><code>thicknessData::Union{ThicknessData, Nothing}</code>: Thickness data structure that is used to store the reference values.</li><li><code>velocityData::Union{SurfaceVelocityData, Nothing}</code>: Surface velocity data structure that is used to store the reference values.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Glacier2D</code> object with the specified parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/Glacier2D.jl#L77-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Glacier2D-api" href="#Sleipnir.Glacier2D-api"><code>Sleipnir.Glacier2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct representing a 2D glacier. Notice that all fields can be empty by providing <code>nothing</code> as the default value.</p><p>/!\ WARNING /!\ <code>Glacier</code> objects should not be constructed manually, but rather through the <code>initialize_glaciers</code> function.</p><p><code>Glacier2D{F &lt;: AbstractFloat, I &lt;: Integer}</code></p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) identifier for the glacier.</li><li><code>name::String</code>: The name of the glacier if available.</li><li><code>climate::Union{Climate2D, Nothing}</code>: The climate data associated with the glacier.</li><li><code>H₀::Union{Matrix{F}, Nothing}</code>: Initial ice thickness matrix.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness matrix from the GLATHIDA dataset.</li><li><code>S::Matrix{F}</code>: Surface elevation matrix.</li><li><code>B::Matrix{F}</code>: Bedrock elevation matrix.</li><li><code>V::Union{Matrix{F}, Nothing}</code>: Ice velocity magnitude matrix.</li><li><code>Vx::Union{Matrix{F}, Nothing}</code>: Ice velocity in the x-direction matrix.</li><li><code>Vy::Union{Matrix{F}, Nothing}</code>: Ice velocity in the y-direction matrix.</li><li><code>A::Union{F, Nothing}</code>: Flow law parameter.</li><li><code>C::Union{F, Nothing}</code>: Sliding law parameter.</li><li><code>n::Union{F, Nothing}</code>: Flow law exponent.</li><li><code>slope::Union{Matrix{F}, Nothing}</code>: Surface slope matrix.</li><li><code>dist_border::Union{Matrix{F}, Nothing}</code>: Distance to the glacier border matrix.</li><li><code>Coords::Union{Dict{String, Vector{Float64}}, Nothing}</code>: Coordinates dictionary with keys as coordinate names and values as vectors of coordinates.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>cenlon::Union{F, Nothing}</code>: Longitude of the glacier center.</li><li><code>cenlat::Union{F, Nothing}</code>: Latitude of the glacier center.</li><li><code>params_projection::Dict{String, Float64}</code>: Projection parameters that allows mapping the regional grid to global WGS84 coordinates.</li><li><code>thicknessData::Union{ThicknessData, Nothing}</code>: Thickness data structure that is used to store the reference values.</li><li><code>velocityData::Union{SurfaceVelocityData, Nothing}</code>: Surface velocity data structure that is used to store the reference values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/Glacier2D.jl#L13-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.IntegratedTrajectoryMapping-api" href="#Sleipnir.IntegratedTrajectoryMapping-api"><code>Sleipnir.IntegratedTrajectoryMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntegratedTrajectoryMapping &lt;: VelocityMapping</code></pre><p>Integrated trajectory mapping. This mapping is closer to reality as it consists in integrating over time the instantaneous ice surface velocities along ice flow trajectories in a Lagrangian way. This integrated velocity is then compared to the velocity of the datacube. It has not been implemented yet but its computational cost will likely be expensive.</p><p><strong>Fields</strong></p><ul><li><code>spatialInterp::Symbol</code>: The spatial interpolation to use to map the ice surface   velocity grid to the glacier grid. For the moment only <code>:nearest</code> is supported.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityMapping.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.MeanDateVelocityMapping-api" href="#Sleipnir.MeanDateVelocityMapping-api"><code>Sleipnir.MeanDateVelocityMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeanDateVelocityMapping &lt;: VelocityMapping</code></pre><p>Mean date velocity mapping. It is the most simple mapping one can build and it consists in taking the 2D vector field of ice velocity associated to a given mean date and compare it to the instantaneous ice surface velocity obtained from the ice flow model. It is valid only for ice surface velocities estimated from short time windows since the velocity can vary within this time window.</p><p><strong>Fields</strong></p><ul><li><code>spatialInterp::Symbol</code>: The spatial interpolation to use to map the ice surface   velocity grid to the glacier grid. For the moment only <code>:nearest</code> is supported.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityMapping.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Model-api" href="#Sleipnir.Model-api"><code>Sleipnir.Model</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct that represents a model with three components: iceflow, mass balance, and machine learning.</p><pre><code class="nohighlight hljs">Model{IFM &lt;: AbstractEmptyModel, MBM &lt;: AbstractEmptyModel, MLM &lt;: AbstractEmptyModel}</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>iceflow::Union{IFM, Vector{IFM}}</code>: Represents the iceflow component, which can be a single instance of <code>IFM</code> or a vector of <code>IFM</code> instances.</li><li><code>mass_balance::Union{MBM, Vector{MBM}}</code>: Represents the mass balance component, which can be a single instance of <code>MBM</code> or a vector of <code>MBM</code> instances.</li><li><code>machine_learning::MLM</code>: Represents the machine learning component, which is an instance of <code>MLM</code>.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>IFM</code>: A subtype of <code>AbstractEmptyModel</code> representing the type of the iceflow model.</li><li><code>MBM</code>: A subtype of <code>AbstractEmptyModel</code> representing the type of the mass balance model.</li><li><code>MLM</code>: A subtype of <code>AbstractEmptyModel</code> representing the type of the machine learning model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/models/Model.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Parameters-Tuple{}-api" href="#Sleipnir.Parameters-Tuple{}-api"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    Parameters(; physical::PhysicalParameters = PhysicalParameters(), simulation::SimulationParameters = SimulationParameters())</code></pre><p>Constructs a <code>Parameters</code> object with the given physical and simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>physical::PhysicalParameters</code>: An instance of <code>PhysicalParameters</code> (default: <code>PhysicalParameters()</code>).</li><li><code>simulation::SimulationParameters</code>: An instance of <code>SimulationParameters</code> (default: <code>SimulationParameters()</code>).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Parameters</code> object initialized with the provided physical and simulation parameters.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>simulation.multiprocessing</code> is enabled, multiprocessing is configured with the specified number of workers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/Parameters.jl#L55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Parameters-api" href="#Sleipnir.Parameters-api"><code>Sleipnir.Parameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    mutable struct Parameters{PPHY &lt;: AbstractEmptyParams, PSIM &lt;: AbstractEmptyParams, PHY &lt;: AbstractEmptyParams,
                    PSOL &lt;: AbstractEmptyParams, PUDE &lt;: AbstractEmptyParams, PINV &lt;: AbstractEmptyParams}</code></pre><p>A mutable struct that holds various parameter sets for different aspects of a simulation or model.</p><p><strong>Fields</strong></p><ul><li><code>physical::PPHY</code>: Physical parameters.</li><li><code>simulation::PSIM</code>: Simulation parameters.</li><li><code>hyper::PHY</code>: Hyperparameters.</li><li><code>solver::PSOL</code>: Solver parameters.</li><li><code>UDE::PUDE</code>: Universal Differential Equation (UDE) parameters.</li><li><code>inversion::PINV</code>: Inversion parameters.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>PPHY</code>: Type of the physical parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PSIM</code>: Type of the simulation parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PHY</code>: Type of the hyperparameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PSOL</code>: Type of the solver parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PUDE</code>: Type of the UDE parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li><li><code>PINV</code>: Type of the inversion parameters, must be a subtype of <code>AbstractEmptyParams</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/Parameters.jl#L19-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#Sleipnir.PhysicalParameters-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Initialize the physical parameters of a model.</p><pre><code class="nohighlight hljs">PhysicalParameters(;
    ρ::Float64 = 900.0,
    g::Float64 = 9.81,
    ϵ::Float64 = 1e-3,
    η₀::F = 1.0, 
    maxA::Float64 = 8e-17,
    minA::Float64 = 8.5e-20,
    maxTlaw::Float64 = 1.0,
    minTlaw::Float64 = -25.0,
    noise_A_magnitude::Float64 = 5e-18
    )</code></pre><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `ρ`: Ice density
- `g`: Gravitational constant
- `ϵ`: Small number
- `η₀`:  
- `maxA`: Maximum value for `A` (Glen&#39;s coefficient)
- `minA`: Minimum value for `A` (Glen&#39;s coefficient)
- `maxTlaw`: Maximum value of Temperature used in simulations on fake law
- `minTlaw`: Minimum value of Temperature used in simulations on fake law
- `noise_A_magnitude`: Magnitude of noise added to A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/PhysicalParameters.jl#L30-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.PhysicalParameters-api" href="#Sleipnir.PhysicalParameters-api"><code>Sleipnir.PhysicalParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure representing physical parameters used in simulations.</p><pre><code class="nohighlight hljs">PhysicalParameters{F &lt;: AbstractFloat}</code></pre><p><strong>Fields</strong></p><ul><li><code>ρ::F</code>: Density of ice.</li><li><code>g::F</code>: Gravitational acceleration.</li><li><code>ϵ::F</code>: A small parameter, often used for perturbations.</li><li><code>η₀::F</code>: Initial viscosity.</li><li><code>maxA::F</code>: Maximum A.</li><li><code>minA::F</code>: Minimum A.</li><li><code>maxTlaw::F</code>: Maximum temperature according to some law.</li><li><code>minTlaw::F</code>: Minimum temperature according to some law.</li><li><code>noise_A_magnitude::F</code>: Magnitude of noise in A.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/PhysicalParameters.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Int64}-api" href="#Sleipnir.Results-Union{Tuple{I}, Tuple{IF}, Tuple{F}, Tuple{G}, Tuple{G, IF}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, IF&lt;:AbstractModel, I&lt;:Int64}-api"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Results(glacier::G, ifm::IF;
    rgi_id::String = glacier.rgi_id,
    H::Union{Nothing, Vector{Matrix{F}}} = nothing,
    H_glathida::Matrix{F} = glacier.H_glathida,
    H_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    S::Union{Nothing, Matrix{F}} = nothing,
    B::Union{Nothing, Matrix{F}} = nothing,
    V::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vx::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vy::Union{Nothing, Vector{Matrix{F}}} = nothing,
    V_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vx_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Vy_ref::Union{Nothing, Vector{Matrix{F}}} = nothing,
    Δx::F = glacier.Δx,
    Δy::F = glacier.Δy,
    lon::Union{Nothing, F} = glacier.cenlon,
    lat::Union{Nothing, F} = glacier.cenlat,
    nx::I = glacier.nx,
    ny::I = glacier.ny,
    t::Union{Vector{F}, Nothing} = nothing,
    tspan::Union{Tuple{F, F}, Nothing} = nothing,
    θ::Union{Nothing,ComponentArray{F}} = nothing,
    loss::Union{Nothing,Vector{F}} = nothing
) where {G &lt;: AbstractGlacier, F &lt;: AbstractFloat, IF &lt;: AbstractModel, I &lt;: Int}</code></pre><p>Construct a <code>Results</code> object for a glacier simulation.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::G</code>: The glacier object, subtype of <code>AbstractGlacier</code>.</li><li><code>ifm::IF</code>: The model object, subtype of <code>AbstractModel</code>.</li><li><code>rgi_id::String</code>: The RGI identifier for the glacier. Defaults to <code>glacier.rgi_id</code>.</li><li><code>H::Union{Nothing, Vector{Matrix{F}}}</code>: Ice thickness matrices. Defaults to nothing.</li><li><code>H_glathida::Matrix{F}</code>: Ice thickness from GlaThiDa. Defaults to <code>glacier.H_glathida</code>.</li><li><code>H_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference ice thickness. Defaults to nothing.</li><li><code>S::Union{Nothing, Matrix{F}}</code>: Surface elevation matrix. Defaults to a zero matrix of the same size as <code>ifm.S</code>.</li><li><code>B::Union{Nothing, Matrix{F}}</code>: Bed elevation matrix. Defaults to a zero matrix of the same size as <code>glacier.B</code>.</li><li><code>V::Union{Nothing, Vector{Matrix{F}}}</code>: Velocity magnitude matrix. Defaults to nothing.</li><li><code>Vx::Union{Nothing, Vector{Matrix{F}}}</code>: Velocity in the x-direction matrix. Defaults to nothing.</li><li><code>Vy::Union{Nothing, Vector{Matrix{F}}}</code>: Velocity in the y-direction matrix. Defaults to nothing.</li><li><code>V_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference velocity magnitude matrix. Defaults to nothing.</li><li><code>Vx_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference velocity in the x-direction matrix. Defaults to nothing.</li><li><code>Vy_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference velocity in the y-direction matrix. Defaults to nothing.</li><li><code>Δx::F</code>: Grid spacing in the x-direction. Defaults to <code>glacier.Δx</code>.</li><li><code>Δy::F</code>: Grid spacing in the y-direction. Defaults to <code>glacier.Δy</code>.</li><li><code>lon::Union{Nothing, F}</code>: Longitude of the glacier center. Defaults to <code>glacier.cenlon</code>.</li><li><code>lat::Union{Nothing, F}</code>: Latitude of the glacier center. Defaults to <code>glacier.cenlat</code>.</li><li><code>nx::I</code>: Number of grid points in the x-direction. Defaults to <code>glacier.nx</code>.</li><li><code>ny::I</code>: Number of grid points in the y-direction. Defaults to <code>glacier.ny</code>.</li><li><code>tspan::Tuple(F, F)</code>: Timespan of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Model parameters. Defaults to <code>nothing</code>.</li><li><code>loss::Union{Nothing, Vector{F}}</code>: Loss values. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Results</code>: A <code>Results</code> object containing the simulation results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/Results.jl#L64-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Results-api" href="#Sleipnir.Results-api"><code>Sleipnir.Results</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Results{F &lt;: AbstractFloat, I &lt;: Int}</code></pre><p>A mutable struct to store the results of simulations.</p><p><strong>Fields</strong></p><ul><li><code>rgi_id::String</code>: Identifier for the RGI (Randolph Glacier Inventory).</li><li><code>H::Vector{Matrix{F}}</code>: Vector of matrices representing glacier ice thickness <code>H</code> over time.</li><li><code>H_glathida::Matrix{F}</code>: Optional matrix for Glathida ice thicknesses.</li><li><code>H_ref::Union{Nothing, Vector{Matrix{F}}}</code>: Reference data for ice thickness.</li><li><code>S::Matrix{F}</code>: Glacier surface altimetry.</li><li><code>B::Matrix{F}</code>: Glacier bedrock.</li><li><code>V::Matrix{F}</code>: Glacier ice surface velocities.</li><li><code>Vx::Matrix{F}</code>: x-component of the glacier ice surface velocity <code>V</code>.</li><li><code>Vy::Matrix{F}</code>: y-component of the glacier ice surface velocity <code>V</code>.</li><li><code>V_ref::Union{Nothing, Matrix{F}}</code>: Reference data for glacier ice surface velocities <code>V</code>.</li><li><code>Vx_ref::Union{Nothing, Matrix{F}}</code>: Reference data for the x-component of the glacier ice surface velocity <code>Vx</code>.</li><li><code>Vy_ref::Union{Nothing, Matrix{F}}</code>: Reference data for the y-component of the glacier ice surface velocity <code>Vy</code>.</li><li><code>Δx::F</code>: Grid spacing in the x-direction.</li><li><code>Δy::F</code>: Grid spacing in the y-direction.</li><li><code>lon::Union{Nothing, F}</code>: Optional longitude value.</li><li><code>lat::Union{Nothing, F}</code>: Optional latitude value.</li><li><code>nx::I</code>: Number of grid points in the x-direction.</li><li><code>ny::I</code>: Number of grid points in the y-direction.</li><li><code>tspan::Vector{F}</code>: Time span of the simulation.</li><li><code>θ::Union{Nothing, ComponentArray{F}}</code>: Machine learning model parameters.</li><li><code>loss::Union{Nothing, Vector{F}}</code> Vector with evolution of loss function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/Results.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.Simulation-api" href="#Sleipnir.Simulation-api"><code>Sleipnir.Simulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Simulation</code></pre><p>An abstract type representing a generic simulation. This type is intended to be  subclassed by specific simulation types to provide a common interface and shared  functionality for all simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/Simulation.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{VM}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping}-api" href="#Sleipnir.SimulationParameters-Union{Tuple{}, Tuple{VM}, Tuple{F}, Tuple{I}} where {I&lt;:Integer, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping}-api"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructor for <code>SimulationParameters</code> type, including default values.</p><pre><code class="nohighlight hljs">SimulationParameters(;
    use_MB::Bool = true,
    use_iceflow::Bool = true,
    plots::Bool = true,
    velocities::Bool = true,
    overwrite_climate::Bool = false,
    use_glathida_data::Bool = false,
    tspan::Tuple{F, F} = (2010.0,2015.0),
    step::F = 1/12,
    multiprocessing::Bool = true,
    workers::I = 4,
    working_dir::String = &quot;&quot;,
    test_mode::Bool = false,
    rgi_paths::Dict{String, String} = Dict{String, String}(),
    ice_thickness_source::String = &quot;Farinotti19&quot;,
    mapping::VM = MeanDateVelocityMapping(),
) where {I &lt;: Integer, F &lt;: AbstractFloat, VM &lt;: VelocityMapping}</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>use_MB::Bool</code>: Whether to use mass balance (default: <code>true</code>).</li><li><code>use_iceflow::Bool</code>: Whether to use ice flow (default: <code>true</code>).</li><li><code>plots::Bool</code>: Whether to generate plots (default: <code>true</code>).</li><li><code>velocities::Bool</code>: Whether to calculate velocities (default: <code>true</code>).</li><li><code>overwrite_climate::Bool</code>: Whether to overwrite climate data (default: <code>false</code>).</li><li><code>use_glathida_data::Bool</code>: Whether to use GLATHIDA data (default: <code>false</code>).</li><li><code>float_type::DataType</code>: Data type for floating point numbers (default: <code>Float64</code>).</li><li><code>int_type::DataType</code>: Data type for integers (default: <code>Int64</code>).</li><li><code>tspan::Tuple{F, F}</code>: Time span for the simulation (default: <code>(2010.0, 2015.0)</code>).</li><li><code>step::F</code>: Time step for the simulation (default: <code>1/12</code>).</li><li><code>multiprocessing::Bool</code>: Whether to use multiprocessing (default: <code>true</code>).</li><li><code>workers::I</code>: Number of workers for multiprocessing (default: <code>4</code>).</li><li><code>working_dir::String</code>: Working directory for the simulation (default: <code>&quot;&quot;</code>).</li><li><code>test_mode::Bool</code>: Whether to run in test mode (default: <code>false</code>).</li><li><code>rgi_paths::Dict{String, String}</code>: Dictionary of RGI paths (default: <code>Dict{String, String}()</code>).</li><li><code>ice_thickness_source::String</code>: Source of ice thickness data, either <code>&quot;Millan22&quot;</code> or <code>&quot;Farinotti19&quot;</code> (default: <code>&quot;Farinotti19&quot;</code>).</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>simulation_parameters</code>: A new <code>SimulationParameters</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If <code>ice_thickness_source</code> is not <code>&quot;Millan22&quot;</code> or <code>&quot;Farinotti19&quot;</code>.</li></ul><p><strong>Notes</strong></p><ul><li>If the global variable ODINN<em>OVERWRITE</em>MULTI is set to true, multiprocessing is   disabled in any case. This is to fix the documentation generation as for the   moment Literate.jl freezes when multiprocessing is enabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/SimulationParameters.jl#L47-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.SimulationParameters-api" href="#Sleipnir.SimulationParameters-api"><code>Sleipnir.SimulationParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A structure to hold simulation parameters for a simulation in ODINN.</p><pre><code class="nohighlight hljs">struct SimulationParameters{I &lt;: Integer, F &lt;: AbstractFloat, VM &lt;: VelocityMapping} &lt;: AbstractParameters</code></pre><p><strong>Fields</strong></p><ul><li><code>use_MB::Bool</code>: Flag to indicate whether mass balance should be used.</li><li><code>use_iceflow::Bool</code>: Flag to indicate whether ice flow should be used.</li><li><code>plots::Bool</code>: Flag to indicate whether plots should be generated.</li><li><code>velocities::Bool</code>: Flag to indicate whether velocities should be calculated.</li><li><code>overwrite_climate::Bool</code>: Flag to indicate whether to overwrite climate data.</li><li><code>use_glathida_data::Bool</code>: Flag to indicate whether to use GLATHIDA data.</li><li><code>tspan::Tuple{F, F}</code>: Time span for the simulation.</li><li><code>step::F</code>: Time step for the simulation.</li><li><code>multiprocessing::Bool</code>: Flag to indicate whether multiprocessing should be used.</li><li><code>workers::I</code>: Number of workers for multiprocessing.</li><li><code>working_dir::String</code>: Directory for working files.</li><li><code>test_mode::Bool</code>: Flag to indicate whether to run in test mode.</li><li><code>rgi_paths::Dict{String, String}</code>: Dictionary of RGI paths.</li><li><code>ice_thickness_source::String</code>: Source of ice thickness data.</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/parameters/SimulationParameters.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#Sleipnir.SurfaceVelocityData-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.SurfaceVelocityData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Constructs <code>SurfaceVelocityData</code> using data from Rabatel et. al (2023) with the given parameters, including default ones.</p><p>function SurfaceVelocityData(;     x::Union{Vector{F}, Nothing} = nothing,     y::Union{Vector{F}, Nothing} = nothing,     lat::Union{Vector{F}, Nothing} = nothing,     lon::Union{Vector{F}, Nothing} = nothing,     vx::Union{Vector{Matrix{F}}, Nothing} = nothing,     vy::Union{Vector{Matrix{F}}, Nothing} = nothing,     vabs::Union{Vector{Matrix{F}}, Nothing} = nothing,     vx<em>error::Union{Vector{F}, Nothing} = nothing,     vy</em>error::Union{Vector{F}, Nothing} = nothing,     vabs<em>error::Union{Vector{F}, Nothing} = nothing,     date::Union{Vector{DateTime}, Nothing} = nothing,     date1::Union{Vector{DateTime}, Nothing} = nothing,     date2::Union{Vector{DateTime}, Nothing} = nothing,     date</em>error::Union{Vector{Day}, Vector{Millisecond}, Nothing} = nothing,     isGridGlacierAligned::Bool = false, ) where {F &lt;: AbstractFloat}</p><p>Constructor for ice surface velocity data based on Rabatel et. al (2023).</p><p>Important remarks:</p><ul><li>The error in velocity is unique per timestamp, rather than being pixel distributed.</li><li>The error in the absolute velocities <code>vabs_error</code> is overestimated.</li></ul><p>References:     - Rabatel, A., Ducasse, E., Millan, R. &amp; Mouginot, J.     Satellite-Derived Annual Glacier Surface Flow Velocity Products for the European Alps,     2015–2021.     Data 8, 66 (2023).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityData.jl#L44-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.SurfaceVelocityData-api" href="#Sleipnir.SurfaceVelocityData-api"><code>Sleipnir.SurfaceVelocityData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A mutable struct representing a surface velocity data. Notice that all fields can be empty by providing <code>nothing</code> as the default value.</p><p><code>SurfaceVelocityData{F &lt;: AbstractFloat} &lt;: AbstractData</code></p><p><strong>Fields</strong></p><ul><li><code>x::Union{Vector{F}, Nothing}</code>: Easting of observation.</li><li><code>y::Union{Vector{F}, Nothing}</code>: Northing of observation.</li><li><code>lat::Union{Vector{F}, Nothing}</code>: Latitude of observation.</li><li><code>lon::Union{Vector{F}, Nothing}</code>: Longitude of observation.</li><li><code>vx::Union{Vector{Matrix{F}}, Nothing}</code>: x component of surface velocity.</li><li><code>vy::Union{Vector{Matrix{F}}, Nothing}</code>: y component of surface velocity.</li><li><code>vabs::Union{Vector{Matrix{F}}, Nothing}</code>: Absolute ice surface velocity.</li><li><code>vx_error::Union{Vector{F}, Nothing}</code>: Error in <code>vx</code></li><li><code>vy_error::Union{Vector{F}, Nothing}</code>: Error in <code>vy</code></li><li><code>vabs_error::Union{Vector{F}, Nothing}</code>: Error in <code>vabs</code>.</li><li><code>date::Union{Vector{DateTime}, Nothing}</code>: Date of observation (mean of <code>date1</code> and <code>date2</code>)</li><li><code>date1::Union{Vector{DateTime}, Nothing}</code>: First date of adquisition.</li><li><code>date2::Union{Vector{DateTime}, Nothing}</code>: Second date of adquisition.</li><li><code>date_error::Union{Vector{Day}, Vector{Millisecond}, Nothing}</code>: Error in <code>date</code>.</li><li><code>isGridGlacierAligned::Bool</code>: Whether the data have been gridded to the glacier grid or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityData.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.ThicknessData-api" href="#Sleipnir.ThicknessData-api"><code>Sleipnir.ThicknessData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Simple time series of ice thickness data to test transient inversion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/ThicknessData.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.VelocityMapping-api" href="#Sleipnir.VelocityMapping-api"><code>Sleipnir.VelocityMapping</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VelocityMapping</code></pre><p>Abstract type representing the mapping to use in order to map the ice velocity products onto the glacier grid. It contains all needed information to build both the spatial projection, and how to interpolate the data in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityMapping.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.DummyClimate2D-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api" href="#Sleipnir.DummyClimate2D-Union{Tuple{}, Tuple{F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.DummyClimate2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DummyClimate2D(;
    longterm_temps::Vector{F} = []
) where {F &lt;: AbstractFloat}</code></pre><p>Dummy climate initialization for very specific use cases where we don&#39;t have climate data and we need to build a minimalistic climate with only a few data. For the moment it supports only the initialization of the long term temperatures. It returns a minimalistic Climate2D instance.</p><p>Arguments:</p><ul><li><code>longterm_temps::Vector{F}</code>: Long term temperatures.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/Climate2D.jl#L76-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.ReverseUTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api" href="#Sleipnir.ReverseUTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.ReverseUTMercator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseUTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0, zone::Union{Nothing, Int}=nothing, hemisphere=nothing) where {F &lt;: AbstractFloat}</code></pre><p>Transverse Mercator Projection. This function reprojects latitude/longitude into northing/easting coordinates.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `k`: scale factor of the projection
- `cenlon`: Central longitude used in the projection
- `cenlat`: Central latitude used in the projection
- `x0`: Shift in easting
- `y0`: Shift in northing
- `zone` : Zone of the projection
- `hemisphere`: Either :north or :south</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L572-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api" href="#Sleipnir.UTMercator-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat-api"><code>Sleipnir.UTMercator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UTMercator(x::F, y::F; k=0.9996, cenlon=0.0, cenlat=0.0, x0=0.0, y0=0.0, zone::Union{Nothing, Int}=nothing, hemisphere=nothing) where {F &lt;: AbstractFloat}</code></pre><p>Transverse Mercator Projection. This function reprojects northing/easting coordinates into latitude/longitude.</p><p><strong>Keyword arguments</strong></p><pre><code class="nohighlight hljs">- `k`: scale factor of the projection
- `cenlon`: Central longitude used in the projection
- `cenlat`: Central latitude used in the projection
- `x0`: Shift in easting
- `y0`: Shift in northing
- `zone` : Zone of the projection
- `hemisphere`: Either :north or :south</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L536-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.apply_t_cumul_grad!-Union{Tuple{F}, Tuple{Climate2Dstep, Matrix{F}}} where F&lt;:AbstractFloat-api" href="#Sleipnir.apply_t_cumul_grad!-Union{Tuple{F}, Tuple{Climate2Dstep, Matrix{F}}} where F&lt;:AbstractFloat-api"><code>Sleipnir.apply_t_cumul_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_t_cumul_grad!(climate_2D_step::Climate2Dstep, S::Matrix{F}) where {F &lt;: AbstractFloat}</code></pre><p>Apply temperature and precipitation gradients based on the positive degree day (PDD) and on the elevation matrix <code>S</code> to the climate data in <code>climate_2D_step</code>.</p><p><strong>Arguments</strong></p><ul><li><code>climate_2D_step::Climate2Dstep</code>: The climate data structure containing temperature, PDD, gradients, and reference height.</li><li><code>S::Matrix{F}</code>: A matrix of elevations.</li></ul><p><strong>Description</strong></p><p>This function updates the temperature and PDD fields in <code>climate_2D_step</code> by applying the respective gradients based on the difference between the elevation matrix <code>S</code> and the reference height. Negative PDD values are cropped to zero. Additionally, the function adjusts the rain and snow fractions based on the updated temperature values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L191-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}-api" href="#Sleipnir.apply_t_grad!-Tuple{Rasters.RasterStack, Rasters.Raster}-api"><code>Sleipnir.apply_t_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_t_grad!(climate::RasterStack, dem::Raster)</code></pre><p>Apply temperature gradients to the climate data based on the digital elevation model (DEM).</p><p><strong>Arguments</strong></p><ul><li><code>climate::RasterStack</code>: A <code>RasterStack</code> object containing climate data, including temperature and gradient information.</li><li><code>dem::Raster</code>: A <code>Raster</code> object representing the digital elevation model (DEM) data.</li></ul><p><strong>Description</strong></p><p>This function adjusts the temperature data in the <code>climate</code> object by applying the temperature gradients. The adjustment is based on the difference between the mean elevation from the DEM data and a reference height specified in the metadata of the <code>climate</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L214-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM&lt;:Simulation, I&lt;:Integer}-api" href="#Sleipnir.create_results-Union{Tuple{I}, Tuple{SIM}, Tuple{SIM, I, Any}, Tuple{SIM, I, Any, Any}} where {SIM&lt;:Simulation, I&lt;:Integer}-api"><code>Sleipnir.create_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_results(
    simulation::SIM,
    glacier_idx::I,
    solution,
    loss=nothing;
    light=false,
    batch_id::Union{Nothing, I}=nothing,
    processVelocity::Union{Nothing, Function}=nothing
) where {SIM &lt;: Simulation, I &lt;: Integer}</code></pre><p>Create a <code>Results</code> object from a given simulation and solution.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::SIM</code>: The simulation object of type <code>Simulation</code>.</li><li><code>glacier_idx::I</code>: The index of the glacier within the simulation.</li><li><code>solution</code>: The solution object containing all the steps including intermediate ones.</li><li><code>loss=nothing</code>: The loss value, default is <code>nothing</code>.</li><li><code>light=false</code>: A boolean flag to indicate if only the first and last steps of the solution should be used.</li><li><code>batch_id::Union{Nothing, I}=nothing</code>: The batch ID, default is <code>nothing</code>.</li><li><code>processVelocity::Union{Nothing, Function}=nothing</code>: Post processing function to map the ice thickness to the surface velocity. It is called before creating the results. It takes as inputs simulation, ice thickness (matrix) and the batch ID and returns 3 variables Vx, Vy, V which are all matrix. Defaults is nothing which means no post processing is applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>results</code>: A <code>Results</code> object containing the processed simulation data.</li></ul><p><strong>Details</strong></p><p>The function processes the solution to select the last value for each time step. It then constructs a <code>Results</code> object containing various attributes from the simulation and the iceflow model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_utils.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}-api" href="#Sleipnir.downscale_2D_climate!-Tuple{Glacier2D}-api"><code>Sleipnir.downscale_2D_climate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">downscale_2D_climate!(glacier::Glacier2D)</code></pre><p>Update the 2D climate structure for a given glacier by downscaling climate data.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::Glacier2D</code>: The glacier object containing the climate data to be downscaled.</li></ul><p><strong>Description</strong></p><p>This function updates the 2D climate structure of the given glacier by:</p><ol><li>Updating the temperature, PDD (Positive Degree Days), snow, and rain fields in the 2D climate step with the corresponding values from the climate step.</li><li>Updating the gradients and average gradients in the 2D climate step.</li><li>Applying temperature gradients and computing the snow/rain fraction for the selected period by reprojecting the current <code>S</code> with the <code>RasterStack</code> structure.</li></ol><p><strong>Notes</strong></p><ul><li>The function modifies the <code>glacier</code> object in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L231-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.downscale_2D_climate-Tuple{Dict, Glacier2D}-api" href="#Sleipnir.downscale_2D_climate-Tuple{Dict, Glacier2D}-api"><code>Sleipnir.downscale_2D_climate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">downscale_2D_climate(climate_step::Dict, glacier::Glacier2D) -&gt; Climate2Dstep</code></pre><p>Downscales climate data to a 2D grid based on the provided glacier information.</p><p><strong>Arguments</strong></p><ul><li><code>climate_step::Dict</code>: A dictionary containing climate data for a specific time step. Expected keys are:<ul><li><code>&quot;avg_temp&quot;</code>: Average temperature.</li><li><code>&quot;temp&quot;</code>: Temperature.</li><li><code>&quot;prcp&quot;</code>: Precipitation.</li><li><code>&quot;gradient&quot;</code>: Temperature gradient.</li><li><code>&quot;avg_gradient&quot;</code>: Average temperature gradient.</li><li><code>&quot;ref_hgt&quot;</code>: Reference height.</li></ul></li><li><code>glacier::Glacier2D</code>: A <code>Glacier2D</code> object containing glacier data. Expected fields are:<ul><li><code>S</code>: Surface elevation data.</li><li><code>Coords</code>: A dictionary with keys <code>&quot;lon&quot;</code> and <code>&quot;lat&quot;</code> for longitude and latitude coordinates.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Climate2Dstep</code>: A <code>Climate2Dstep</code> object containing the downscaled climate data with fields:<ul><li><code>temp</code>: 2D array of temperature.</li><li><code>PDD</code>: 2D array of positive degree days.</li><li><code>snow</code>: 2D array of snow precipitation.</li><li><code>rain</code>: 2D array of rain precipitation.</li><li><code>gradient</code>: Temperature gradient.</li><li><code>avg_gradient</code>: Average temperature gradient.</li><li><code>x</code>: Longitude coordinates.</li><li><code>y</code>: Latitude coordinates.</li><li><code>ref_hgt</code>: Reference height.</li></ul></li></ul><p><strong>Description</strong></p><p>This function creates dummy 2D arrays based on the glacier surface elevation data and applies the climate step data to these arrays. It then constructs a <code>Climate2Dstep</code> object with the downscaled climate data and applies temperature gradients to compute the snow/rain fraction for the selected period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L263-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.downscale_2D_climate-Tuple{Glacier2D}-api" href="#Sleipnir.downscale_2D_climate-Tuple{Glacier2D}-api"><code>Sleipnir.downscale_2D_climate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">downscale_2D_climate(glacier::Glacier2D)</code></pre><p>Downscales the climate data for a given 2D glacier.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::Glacier2D</code>: The glacier object containing the climate data to be downscaled.</li></ul><p><strong>Returns</strong></p><ul><li><code>climate_2D_step</code>: The downscaled 2D climate data for the glacier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L320-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.fillNaN!-api" href="#Sleipnir.fillNaN!-api"><code>Sleipnir.fillNaN!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fillNaN!(A::AbstractArray, fill::Number=zero(eltype(A)))</code></pre><p>Replace all <code>NaN</code> values in the array <code>A</code> with the specified <code>fill</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The array in which <code>NaN</code> values will be replaced.</li><li><code>fill::Number</code>: The value to replace <code>NaN</code> with. Defaults to <code>zero(eltype(A))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L455-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.fillNaN-api" href="#Sleipnir.fillNaN-api"><code>Sleipnir.fillNaN</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fillNaN(A::AbstractArray, fill::Number=zero(eltype(A)))</code></pre><p>Replace all NaN values in the array <code>A</code> with the specified <code>fill</code> value.  If no <code>fill</code> value is provided, it defaults to the zero value of the element type of <code>A</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The input array that may contain NaN values.</li><li><code>fill::Number</code>: The value to replace NaNs with. Defaults to <code>zero(eltype(A))</code>.</li></ul><p><strong>Returns</strong></p><ul><li>An array of the same type and shape as <code>A</code>, with all NaN values replaced by <code>fill</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L470-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.fillZeros!-api" href="#Sleipnir.fillZeros!-api"><code>Sleipnir.fillZeros!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fillZeros!(A::AbstractArray, fill::Number=NaN)</code></pre><p>Replace all zero elements in the array <code>A</code> with the specified <code>fill</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The array in which to replace zero elements.</li><li><code>fill::Number</code>: The value to replace zero elements with. Defaults to <code>NaN</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L487-L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.fillZeros-api" href="#Sleipnir.fillZeros-api"><code>Sleipnir.fillZeros</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fillZeros(A::AbstractArray, fill::Number=NaN) -&gt; AbstractArray</code></pre><p>Replace all zero elements in the array <code>A</code> with the specified <code>fill</code> value.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: The input array in which zero elements are to be replaced.</li><li><code>fill::Number</code>: The value to replace zero elements with. Defaults to <code>NaN</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray</code>: A new array with zero elements replaced by the <code>fill</code> value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L502-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.filter_missing_glaciers!-Tuple{Vector{Glacier2D}, Sleipnir.Parameters}-api" href="#Sleipnir.filter_missing_glaciers!-Tuple{Vector{Glacier2D}, Sleipnir.Parameters}-api"><code>Sleipnir.filter_missing_glaciers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_missing_glaciers!(glaciers::Vector{Glacier2D}, params::Parameters)</code></pre><p>Filters out glaciers from the provided <code>glaciers</code> vector that are marked as missing in the OGGM task log (provided by Gungnir) or in a previously saved file.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{Glacier2D}</code>: A vector of <code>Glacier2D</code> objects to be filtered.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li></ul><p><strong>Returns</strong></p><ul><li><code>missing_glaciers::Vector{String}</code>: A vector of glacier IDs that were filtered out.</li></ul><p><strong>Details</strong></p><p>The function reads a task log CSV file from the working directory specified in <code>params</code>. It then determines which glaciers are missing based on the task log and additional conditions specified in <code>params</code>. If a previously saved file of missing glaciers exists, it loads and merges the missing glaciers from that file. Finally, it removes the missing glaciers from the <code>glaciers</code> vector and saves the updated list of missing glaciers to a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L355-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.filter_missing_glaciers!-Tuple{Vector{String}, Sleipnir.Parameters}-api" href="#Sleipnir.filter_missing_glaciers!-Tuple{Vector{String}, Sleipnir.Parameters}-api"><code>Sleipnir.filter_missing_glaciers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_missing_glaciers!(rgi_ids::Vector{String}, params::Parameters)</code></pre><p>Filter out glaciers that cannot be processed from the given list of RGI IDs.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_ids::Vector{String}</code>: A vector of RGI IDs representing glaciers.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li></ul><p><strong>Description</strong></p><p>This function filters out glaciers from the provided <code>rgi_ids</code> list based on two criteria:</p><ol><li>Glaciers that are marked as level 2 in the RGI statistics CSV file.</li><li>Glaciers listed in the <code>missing_glaciers.jld2</code> file located in the <code>params.simulation.working_dir</code> directory.</li></ol><p><strong>Notes</strong></p><ul><li>The RGI statistics CSV file is downloaded from a remote server.</li><li>If the <code>missing_glaciers.jld2</code> file is not available, a warning is logged and the function skips this filtering step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L410-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.generate_raw_climate_files-Tuple{String, SimulationParameters}-api" href="#Sleipnir.generate_raw_climate_files-Tuple{String, SimulationParameters}-api"><code>Sleipnir.generate_raw_climate_files</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_raw_climate_files(rgi_id::String, simparams::SimulationParameters)</code></pre><p>Generate raw climate files for a given RGI (Randolph Glacier Inventory) ID and simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI ID for which to generate raw climate files.</li><li><code>simparams::SimulationParameters</code>: The simulation parameters containing the time span and RGI paths.</li></ul><p><strong>Description</strong></p><p>This function generates raw climate files for a specified RGI ID if they do not already exist. It retrieves raw climate data, ensures the desired period is covered, crops the data to the desired time period, and saves the raw climate data to disk.</p><p><strong>Details</strong></p><ol><li>Constructs the path to the RGI directory using the provided <code>rgi_id</code> and <code>simparams</code>.</li><li>Checks if the raw climate file for the specified time span already exists.</li><li>If the file does not exist:<ul><li>Retrieves the raw climate data.</li><li>Ensures the desired period is covered by the climate data.</li><li>Crops the climate data to the desired time period.</li><li>Saves the cropped climate data to disk.</li><li>Triggers garbage collection to free up memory.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L46-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_cumulative_climate!-api" href="#Sleipnir.get_cumulative_climate!-api"><code>Sleipnir.get_cumulative_climate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cumulative_climate!(climate, period; gradient_bounds=[-0.009, -0.003], default_grad=-0.0065)</code></pre><p>Calculate and update the cumulative climate data for a given period.</p><p><strong>Keyword arguments</strong></p><ul><li><code>climate::Climate</code>: The climate object containing raw climate data.</li><li><code>period::Period</code>: The period for which to calculate the cumulative climate data.</li><li><code>gradient_bounds::Vector{Float64}</code>: Optional. The bounds within which to clamp the gradient values. Default is <code>[-0.009, -0.003]</code>.</li><li><code>default_grad::Float64</code>: Optional. The default gradient value to use. Default is <code>-0.0065</code>.</li></ul><p><strong>Updates</strong></p><ul><li><code>climate.climate_raw_step</code>: The raw climate data for the given period.</li><li><code>climate.avg_temps</code>: The average temperature for the given period.</li><li><code>climate.avg_gradients</code>: The average gradient for the given period.</li><li><code>climate.climate_step[&quot;prcp&quot;]</code>: The cumulative precipitation for the given period.</li><li><code>climate.climate_step[&quot;temp&quot;]</code>: The cumulative temperature for the given period.</li><li><code>climate.climate_step[&quot;gradient&quot;]</code>: The cumulative gradient for the given period.</li><li><code>climate.climate_step[&quot;avg_temp&quot;]</code>: The average temperature for the given period.</li><li><code>climate.climate_step[&quot;avg_gradient&quot;]</code>: The average gradient for the given period.</li><li><code>climate.climate_step[&quot;ref_hgt&quot;]</code>: The reference height from the metadata of the raw climate data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L95-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_cumulative_climate-api" href="#Sleipnir.get_cumulative_climate-api"><code>Sleipnir.get_cumulative_climate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cumulative_climate(climate; gradient_bounds=[-0.009, -0.003], default_grad=-0.0065)</code></pre><p>Calculate cumulative climate statistics from the given climate data.</p><p><strong>Keyword arguments</strong></p><ul><li><code>climate::Climate</code>: A climate object containing temperature, precipitation, and gradient data.</li><li><code>gradient_bounds::Vector{Float64}</code>: A two-element vector specifying the lower and upper bounds for the gradient values. Defaults to <code>[-0.009, -0.003]</code>.</li><li><code>default_grad::Float64</code>: The default gradient value to use. Defaults to <code>-0.0065</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>climate_sum::Dict{String, Any}</code>: A dictionary containing the following keys:<ul><li><code>&quot;temp&quot;</code>: The sum of positive degree days (PDDs) from the temperature data.</li><li><code>&quot;prcp&quot;</code>: The sum of precipitation data.</li><li><code>&quot;gradient&quot;</code>: The sum of gradient data, clipped within the specified bounds.</li><li><code>&quot;avg_temp&quot;</code>: The average temperature.</li><li><code>&quot;avg_gradient&quot;</code>: The average gradient.</li><li><code>&quot;ref_hgt&quot;</code>: The reference height from the climate metadata.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The temperature data is modified to only include positive degree-day values (PDDs).</li><li>The gradient data is clipped within the specified bounds to ensure plausible values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L132-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_glathida!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters}} where G&lt;:Glacier2D-api" href="#Sleipnir.get_glathida!-Union{Tuple{G}, Tuple{Vector{G}, Sleipnir.Parameters}} where G&lt;:Glacier2D-api"><code>Sleipnir.get_glathida!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_glathida!(glaciers::Vector{G}, params::Parameters; force=false) where {G &lt;: Glacier2D}</code></pre><p>Retrieve and process glacier thickness data for a vector of <code>Glacier2D</code> objects.</p><p><strong>Arguments</strong></p><ul><li><code>glaciers::Vector{Glacier2D}</code>: A vector of <code>Glacier2D</code> objects for which the glacier thickness data is to be retrieved.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li><li><code>force::Bool=false</code>: A boolean flag indicating whether to force the retrieval of glacier thickness data.</li></ul><p><strong>Returns</strong></p><ul><li><code>gtd_grids::Vector</code>: A vector of glacier thickness data grids.</li><li><code>glaciers::Vector{Glacier2D}</code>: The updated vector of <code>Glacier2D</code> objects after removing glaciers with no data.</li></ul><p><strong>Description</strong></p><p>This function retrieves glacier thickness data for each glacier in the input vector using parallel processing. It updates a list of missing glaciers if any glacier has all data points equal to zero. The function then removes glaciers with no data from both the <code>gtd_grids</code> and <code>glaciers</code> vectors and returns the updated vectors.</p><p><strong>Notes</strong></p><ul><li>The function uses <code>pmap</code> for parallel processing of glaciers.</li><li>The list of missing glaciers is stored in a JLD2 file located at <code>params.simulation.working_dir/data/missing_glaciers.jld2</code>.</li><li>Glaciers with no data are identified and removed based on the condition that all data points in their thickness grid are zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L269-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_glathida_glacier-Tuple{Glacier2D, Sleipnir.Parameters, Any}-api" href="#Sleipnir.get_glathida_glacier-Tuple{Glacier2D, Sleipnir.Parameters, Any}-api"><code>Sleipnir.get_glathida_glacier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_glathida_glacier(glacier::Glacier2D, params::Parameters, force)</code></pre><p>Retrieve or generate the glathida glacier grid for a given glacier.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::Glacier2D</code>: The glacier object for which the glathida grid is to be retrieved or generated.</li><li><code>params::Parameters</code>: The parameters object containing simulation settings.</li><li><code>force</code>: A boolean flag indicating whether to force regeneration of the glathida grid even if it already exists.</li></ul><p><strong>Returns</strong></p><ul><li><code>gtd_grid</code>: A 2D array representing the glathida glacier grid.</li></ul><p><strong>Description</strong></p><p>This function checks if the glathida glacier grid file (<code>glathida.h5</code>) exists in the specified path. If the file exists and <code>force</code> is <code>false</code>, it reads the grid from the file. Otherwise, it reads the glacier thickness data from a CSV file (<code>glathida_data.csv</code>), computes the average thickness for each grid cell, and saves the resulting grid to an HDF5 file (<code>glathida.h5</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L312-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters, Rasters.RasterStack}-api" href="#Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters, Rasters.RasterStack}-api"><code>Sleipnir.get_longterm_temps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_longterm_temps(rgi_id::String, params::Parameters, climate::RasterStack) -&gt; Array{Float64}</code></pre><p>Calculate the long-term average temperatures for a given glacier.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) identifier for the glacier.</li><li><code>params::Parameters</code>: A struct containing simulation parameters, including paths to RGI data.</li><li><code>climate::RasterStack</code>: A <code>RasterStack</code> object containing climate data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64}</code>: An array of long-term average temperatures.</li></ul><p><strong>Description</strong></p><p>This function retrieves the gridded data for the specified glacier using its RGI identifier. It then applies a temperature gradient to the climate data based on the glacier&#39;s topography. Finally, it calculates the long-term average temperatures by grouping the temperature data by year and computing the mean for each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L426-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters}-api" href="#Sleipnir.get_longterm_temps-Tuple{String, Sleipnir.Parameters}-api"><code>Sleipnir.get_longterm_temps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_longterm_temps(rgi_id::String, params::Parameters)</code></pre><p>Calculate the long-term average temperatures for a given glacier.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) identifier for the glacier.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters, including paths to necessary data files.</li></ul><p><strong>Returns</strong></p><ul><li><code>longterm_temps</code>: A vector of long-term average temperatures for the glacier.</li></ul><p><strong>Description</strong></p><p>This function reads the gridded data and raw climate data for the specified glacier, applies a temperature gradient correction based on the glacier&#39;s topography, and then calculates the long-term average temperatures by grouping the temperature data by year.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L398-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_raw_climate_data-Tuple{String}-api" href="#Sleipnir.get_raw_climate_data-Tuple{String}-api"><code>Sleipnir.get_raw_climate_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_raw_climate_data(rgi_path::String) -&gt; RasterStack</code></pre><p>Load raw climate data from a specified path.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_path::String</code>: The file path to the directory containing the climate data file.</li></ul><p><strong>Returns</strong></p><ul><li><code>RasterStack</code>: A <code>RasterStack</code> object containing the climate data from the specified file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L171-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.get_result_id_from_rgi-Union{Tuple{SIM}, Tuple{I}, Tuple{I, SIM}} where {I&lt;:Integer, SIM&lt;:Simulation}-api" href="#Sleipnir.get_result_id_from_rgi-Union{Tuple{SIM}, Tuple{I}, Tuple{I, SIM}} where {I&lt;:Integer, SIM&lt;:Simulation}-api"><code>Sleipnir.get_result_id_from_rgi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_result_id_from_rgi(glacier_id::I, simulation::SIM) where {I &lt;: Integer, SIM &lt;: Simulation}</code></pre><p>Extract results of specific simulation from the <code>Simulation</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>glacier_id::I</code>: Numerical ID of glacier used to generate simulation.</li><li><code>simulation::SIM</code>`: The simulation object containing the parameters and results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_utils.jl#L151-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.grid-Union{Tuple{FileArray}, Tuple{VM}, Tuple{F}, Tuple{G}, Tuple{G, Vector{F}, Vector{F}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Array{Union{Missing, F}, 3}, FileArray}, VM}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping, FileArray&lt;:Rasters.FileArray}-api" href="#Sleipnir.grid-Union{Tuple{FileArray}, Tuple{VM}, Tuple{F}, Tuple{G}, Tuple{G, Vector{F}, Vector{F}, Union{Array{Union{Missing, F}, 3}, FileArray}, Union{Array{Union{Missing, F}, 3}, FileArray}, VM}} where {G&lt;:AbstractGlacier, F&lt;:AbstractFloat, VM&lt;:Sleipnir.VelocityMapping, FileArray&lt;:Rasters.FileArray}-api"><code>Sleipnir.grid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid(
    glacier::G,
    latitudes::Vector{F},
    longitudes::Vector{F},
    vx::Union{FileArray, Array{Union{Missing, F}, 3}},
    vy::Union{FileArray, Array{Union{Missing, F}, 3}},
    mapping::VM
) where {
    G &lt;: AbstractGlacier,
    F &lt;: AbstractFloat,
    VM &lt;: VelocityMapping,
    FileArray &lt;: Rasters.FileArray
}</code></pre><p>Grid velocity data onto the glacier grid following the prescribed mapping. This function maps the 3 dimensional surface velocities (x, y and t) to the glacier grid. The provided surface velocities can be a <code>Rasters.FileArray</code> which happens when the <code>RasterStack</code> is instantiated in lazy mode. In this situation, only the smallest cube that contains all the needed data to construct the mapping is read from disk. The returned velocity variables have shape <code>(nTimes, nx, ny)</code> where <code>nTimes</code> is the number of time steps and <code>(nx, ny)</code> is the size of the glacier grid.</p><p>Arguments:</p><ul><li><code>glacier::G</code>: Glacier instance which determines the glacier on which the   velocities are projected onto.</li><li><code>latitudes::Vector{F}</code>: Vector of latitude values of the original surface   velocity grid.</li><li><code>longitudes::Vector{F}</code>: Vector of longitude values of the original surface   velocity grid.</li><li><code>vx::Union{FileArray, Array{Union{Missing, F}, 3}}</code>: X component of the original   surface velocities. It can be either a <code>Rasters.FileArray</code> if the datacube is   read in lazy mode, or a plain 3 dimensional array.</li><li><code>vy::Union{FileArray, Array{Union{Missing, F}, 3}}</code>: Y component of the original   surface velocities. It can be either a <code>Rasters.FileArray</code> if the datacube is   read in lazy mode, or a plain 3 dimensional array.</li><li><code>mapping::VM</code>: Mapping to use.</li></ul><p>Returns:</p><ul><li><code>xG</code>: A vector that gives the x coordinates of the glacier grid.</li><li><code>yG</code>: A vector that gives the y coordinates of the glacier grid.</li><li><code>vxG</code>: A 3 dimensional array of the x component of the velocity gridded onto the   glacier grid.</li><li><code>vyG</code>: A 3 dimensional array of the y component of the velocity gridded onto the   glacier grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityData_utils.jl#L157-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}-api" href="#Sleipnir.initialize_glacier-Tuple{String, Sleipnir.Parameters}-api"><code>Sleipnir.initialize_glacier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_glacier(rgi_id::String, parameters::Parameters; smoothing=false)</code></pre><p>Initialize a glacier with the given RGI ID and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI (Randolph Glacier Inventory) ID of the glacier.</li><li><code>parameters::Parameters</code>: A struct containing various parameters required for initialization.</li><li><code>smoothing::Bool</code>: Optional. If <code>true</code>, apply smoothing to the initial topography. Default is <code>false</code>.</li><li><code>velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}</code>: A dictionary that provides for each RGI ID either the path to the datacube or the <code>RasterStack</code> with velocity data.</li></ul><p><strong>Returns</strong></p><ul><li><code>glacier</code>: An initialized glacier object containing the initial topography and climate data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L107-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}-api" href="#Sleipnir.initialize_glacier_climate!-Tuple{AbstractGlacier, Sleipnir.Parameters}-api"><code>Sleipnir.initialize_glacier_climate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_glacier_climate!(glacier::AbstractGlacier, params::Parameters)</code></pre><p>Initialize the climate data for a given glacier.</p><p><strong>Arguments</strong></p><ul><li><code>glacier::AbstractGlacier</code>: The glacier object to initialize the climate data for.</li><li><code>params::Parameters</code>: The parameters containing simulation settings and paths.</li></ul><p><strong>Description</strong></p><p>This function initializes the climate data for a glacier by:</p><ol><li>Creating a dummy period based on the simulation time span and step.</li><li>Loading the raw climate data from a NetCDF file.</li><li>Calculating the cumulative climate data for the dummy period.</li><li>Downscaling the cumulative climate data to a 2D grid.</li><li>Retrieving long-term temperature data for the glacier.</li><li>Storing the climate data in the glacier object, including raw climate data, cumulative climate data, downscaled 2D climate data, long-term temperatures, average temperatures, and average gradients.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L10-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}-api" href="#Sleipnir.initialize_glacier_data-Tuple{String, Sleipnir.Parameters}-api"><code>Sleipnir.initialize_glacier_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_glacier_data(rgi_id::String, params::Parameters; smoothing=false, test=false)</code></pre><p>Initialize glacier data for a given RGI ID and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_id::String</code>: The RGI ID of the glacier.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li><li><code>smoothing::Bool=false</code>: Optional; whether to apply smoothing to the initial ice thickness. Default is <code>false</code>.</li><li><code>test::Bool=false</code>: Optional; test flag. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>glacier::Glacier2D</code>: A <code>Glacier2D</code> object initialized with the glacier data.</li></ul><p><strong>Description</strong></p><p>This function loads and initializes the glacier data for a given RGI ID. It retrieves the initial ice thickness conditions based on the specified source in the parameters, applies optional smoothing, and initializes the glacier&#39;s topographical and velocity data. The function also handles Mercator projection for the glacier coordinates and filters glacier borders in high elevations to avoid overflow problems.</p><p><strong>Notes</strong></p><ul><li>The function reverses the matrices for ice thickness, bedrock, and other data to match the required orientation.</li><li>If the Mercator projection includes latitudes larger than 80°, a warning is issued.</li><li>If the glacier data is missing, the function updates a list of missing glaciers and issues a warning.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L150-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}-api" href="#Sleipnir.initialize_glaciers-Tuple{Vector{String}, Sleipnir.Parameters}-api"><code>Sleipnir.initialize_glaciers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_glaciers(
    rgi_ids::Vector{String},
    params::Parameters;
    velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}=Dict(),
)</code></pre><p>Initialize glaciers based on provided RGI IDs and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rgi_ids::Vector{String}</code>: A vector of RGI IDs representing the glaciers to be initialized.</li><li><code>params::Parameters</code>: A <code>Parameters</code> object containing simulation parameters.</li><li><code>test::Bool</code>: An optional boolean flag indicating whether to run in test mode. Default is <code>false</code>.</li><li><code>velocityDatacubes::Union{Dict{String, String}, Dict{String, RasterStack}}</code>: A dictionary that provides for each RGI ID either the path to the datacube or the <code>RasterStack</code> with velocity data.</li></ul><p><strong>Returns</strong></p><ul><li><code>glaciers::Vector{Glacier2D}</code>: A vector of initialized <code>Glacier2D</code> objects.</li></ul><p><strong>Description</strong></p><p>This function performs the following steps:</p><ol><li>Generates a file for missing glaciers if it does not already exist.</li><li>Filters out missing glaciers from the provided RGI IDs.</li><li>Generates raw climate data for the glaciers if necessary.</li><li>Initializes the glaciers using the provided RGI IDs and parameters.</li><li>If <code>use_glathida_data</code> is enabled in the simulation parameters, assigns GlaThiDa data to the glaciers.</li></ol><p><strong>Errors</strong></p><ul><li>Throws an error if none of the provided RGI IDs have GlaThiDa data.</li></ul><p><strong>Warnings</strong></p><ul><li>Issues a warning if not all glaciers have GlaThiDa data available.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># We declare a list of glaciers to be initialized with their RGI IDs
rgi_ids = [&quot;RGI60-11.03638&quot;, &quot;RGI60-11.01450&quot;, &quot;RGI60-11.02346&quot;, &quot;RGI60-08.00203&quot;]
# We initialize those glaciers based on the RGI IDs and the parameters we previously specified
glaciers = initialize_glaciers(rgi_ids, params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L8-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.initialize_surfacevelocitydata-Union{Tuple{Union{String, Rasters.RasterStack}}, Tuple{VM}, Tuple{G}} where {G&lt;:AbstractGlacier, VM&lt;:Sleipnir.VelocityMapping}-api" href="#Sleipnir.initialize_surfacevelocitydata-Union{Tuple{Union{String, Rasters.RasterStack}}, Tuple{VM}, Tuple{G}} where {G&lt;:AbstractGlacier, VM&lt;:Sleipnir.VelocityMapping}-api"><code>Sleipnir.initialize_surfacevelocitydata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_surfacevelocitydata(
    raster::Union{String, RasterStack};
    glacier::Union{G, Nothing}=nothing,
    mapping::VM=MeanDateVelocityMapping(),
    compute_vabs_error::Bool=true
) where {G &lt;: AbstractGlacier, VM &lt;: VelocityMapping}</code></pre><p>Initialize SurfaceVelocityData from Rabatel et. al (2023).</p><p>Arguments:</p><ul><li><code>raster::Union{String, RasterStack}</code>: RasterStack or path of the netCDF file with surface velocity data.</li><li><code>glacier::Union{G, Nothing}</code>: Glacier associated to the surface velocity datacube.   When provided, the surface velocity data are gridded on the glacier grid using   the <code>mapping</code>.</li><li><code>mapping::VM</code>: Mapping to use in order to grid the data from the coordinates of   the velocity product datacube to the glacier grid.</li><li><code>compute_vabs_error::Bool</code>: Whether to compute the absolute error uncertainty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityData_utils.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.is_in_glacier-Union{Tuple{F}, Tuple{I}, Tuple{Matrix{F}, I}} where {I&lt;:Integer, F&lt;:AbstractFloat}-api" href="#Sleipnir.is_in_glacier-Union{Tuple{F}, Tuple{I}, Tuple{Matrix{F}, I}} where {I&lt;:Integer, F&lt;:AbstractFloat}-api"><code>Sleipnir.is_in_glacier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_in_glacier(A::Matrix{F}, distance::I) where {I &lt;: Integer, F &lt;: AbstractFloat}</code></pre><p>Return a matrix with booleans indicating if a given pixel is at distance at least <code>distance</code> in the set of non zero values of the matrix. This usually allows discarding the border pixels of a glacier.</p><p>Arguments:</p><ul><li><code>A::Matrix{F}</code>: Matrix from which to compute the matrix of booleans.</li><li><code>distance::I</code>: Distance to the border, computed as the number of pixels we need   to move to find a pixel with value zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L631-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.max_or_empty-Tuple{Array}-api" href="#Sleipnir.max_or_empty-Tuple{Array}-api"><code>Sleipnir.max_or_empty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_or_empty(A::Array)</code></pre><p>Return maximum value for non-empty arrays. This is just required to compute the error in the absolute velocity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityData_utils.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.parse_proj-Tuple{String}-api" href="#Sleipnir.parse_proj-Tuple{String}-api"><code>Sleipnir.parse_proj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parse_proj(proj::String)</code></pre><p>Parses the string containing the information of the projection to filter for important information &quot;+proj=tmerc +lat<em>0=0 +lon</em>0=6.985 +k=0.9996 +x<em>0=0 +y</em>0=0 +datum=WGS84 +units=m +no_defs&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L518-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.partial_year-Tuple{Any}-api" href="#Sleipnir.partial_year-Tuple{Any}-api"><code>Sleipnir.partial_year</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_year(float::Float64) -&gt; Float64</code></pre><p>Calculate the partial year value based on the given floating-point number.</p><p><strong>Arguments</strong></p><ul><li><code>float::Float64</code>: A floating-point number representing the fraction of the year.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The calculated partial year value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L385-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.partial_year-Tuple{Type{&lt;:Dates.Period}, Any}-api" href="#Sleipnir.partial_year-Tuple{Type{&lt;:Dates.Period}, Any}-api"><code>Sleipnir.partial_year</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_year(period::Type{&lt;:Period}, float)</code></pre><p>Calculate a partial year date based on a floating-point year value.</p><p><strong>Arguments</strong></p><ul><li><code>period::Type{&lt;:Period}</code>: The type of period to use (e.g., <code>Month</code>, <code>Day</code>).</li><li><code>float::Float64</code>: The floating-point year value.</li></ul><p><strong>Returns</strong></p><ul><li><code>Date</code>: The calculated date corresponding to the partial year.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L365-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_bias-Tuple{Any, Any}-api" href="#Sleipnir.plot_bias-Tuple{Any, Any}-api"><code>Sleipnir.plot_bias</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_bias(
    results,
    variables;
    treshold = [0, 0],
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
)</code></pre><p>Plot the bias of the glacier integrated volume over the specified time span.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variables to be plotted.</li><li><code>title_mapping::Dict{Symbol, String}</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan::Tuple{Float64, Float64}</code>: A tuple representing the start and end time for the simulation.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier integrated volume bias.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_utils.jl#L449-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier-Tuple{Results, String, Vector{Symbol}}-api" href="#Sleipnir.plot_glacier-Tuple{Results, String, Vector{Symbol}}-api"><code>Sleipnir.plot_glacier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier(results::Results, plot_type::String, variables::Vector{Symbol}; kwargs...) -&gt; Figure</code></pre><p>Generate various types of plots for glacier data.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>plot_type::String</code>: Type of plot to generate. Options are:<ul><li>&quot;heatmaps&quot;: Heatmaps for glacier variables like <code>:H</code>, <code>:H₀</code>, <code>:S</code>, <code>:B</code>, <code>:V</code>, <code>:Vx</code>, <code>:Vy</code>, <code>:V_ref</code>.</li><li>&quot;evolution difference&quot;: Temporal difference metrics (between start and end) for a variable, with optional metrics like &quot;hist&quot; (histogram) and &quot;difference&quot;.</li><li>&quot;evolution statistics&quot;: Temporal statistical metrics for a variable, with optional metrics like &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;.</li><li>&quot;integrated volume&quot;: Temporal evolution of the integrated ice volume for a variable.</li><li>&quot;bias&quot;: Scatter plot to visualize the bias between two variables.</li></ul></li><li><code>variables::Vector{Symbol}</code>: Variables to be plotted, e.g., <code>:H</code>.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics</code>: Metrics to visualize, e.g., <code>[&quot;average&quot;]</code> for statistics, <code>[&quot;difference&quot;]</code> for difference.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size for heatmaps.</li><li><code>threshold::Vector{F}</code>: Threshold values for filtering data in bias plots.</li><li><code>figsize::Tuple{Int64, Int64}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Figure</code> object containing the desired visualization.</li></ul><p><strong>Notes</strong></p><ul><li>Ensure the <code>variables</code> and <code>kwargs</code> match the requirements of the specified <code>plot_type</code>.</li><li>The function routes requests to specific plotting functions based on <code>plot_type</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_utils.jl#L524-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Results, Vector{Symbol}, Any}} where F&lt;:AbstractFloat-api" href="#Sleipnir.plot_glacier_difference_evolution-Union{Tuple{F}, Tuple{Results, Vector{Symbol}, Any}} where F&lt;:AbstractFloat-api"><code>Sleipnir.plot_glacier_difference_evolution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier_difference_evolution(
    results::Results,
    variables::Vector{Symbol},
    title_mapping;
    tspan::Tuple{F,F}=results.tspan,
    metrics::Vector{String}=&quot;difference&quot;,
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
) where {F&lt;:AbstractFloat}</code></pre><p>Plot the evolution of the difference in a glacier variable over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The simulation results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variable to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan::Tuple{F,F}</code>: A tuple representing the start and end time for the simulation.</li><li><code>metrics::Vector{String}</code>: Metrics to visualize, e.g., <code>[&quot;difference&quot;]</code>.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier difference evolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_utils.jl#L148-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier_heatmaps-Tuple{Results, Vector{Symbol}, Dict}-api" href="#Sleipnir.plot_glacier_heatmaps-Tuple{Results, Vector{Symbol}, Dict}-api"><code>Sleipnir.plot_glacier_heatmaps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier_heatmaps(
    results::Results,
    variables::Vector{Symbol},
    title_mapping::Dict;
    scale_text_size::Union{Nothing,Float64}=nothing,
    timeIdx::Union{Nothing,Int64}=nothing
) -&gt; Figure</code></pre><p>Plot heatmaps for glacier variables.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping::Dict</code>: A dictionary mapping variable names to their titles and colormaps.</li><li><code>scale_text_size::Union{Nothing,Float64}</code>: Optional argument to scale the text size.</li><li><code>timeIdx::Union{Nothing,Int64}</code>:: Optional argument to select the index at which   data should be plotted when dealing with vector of matrix. Default is nothing   which selects the last element available.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier heatmaps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_utils.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}-api" href="#Sleipnir.plot_glacier_integrated_volume-Tuple{Any, Any, Any}-api"><code>Sleipnir.plot_glacier_integrated_volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier_integrated_volume(
    results,
    variables,
    title_mapping;
    tspan,
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
)</code></pre><p>Plot the integrated volume of a glacier variable over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: The variable to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier integrated volume.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_utils.jl#L381-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier_statistics_evolution-Tuple{Results, Vector{Symbol}, Any}-api" href="#Sleipnir.plot_glacier_statistics_evolution-Tuple{Results, Vector{Symbol}, Any}-api"><code>Sleipnir.plot_glacier_statistics_evolution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier_statistics_evolution(
    results::Results,
    variables::Vector{Symbol},
    title_mapping;
    metrics=&quot;median&quot;,
    tspan,
    threshold=0.5,
    figsize::Union{Nothing, Tuple{Int64, Int64}}=nothing,
)</code></pre><p>Plot the evolution of statistics for multiple glacier variables over time.</p><p><strong>Arguments</strong></p><ul><li><code>results::Results</code>: The simulation results object containing the data to be plotted.</li><li><code>variables::Vector{Symbol}</code>: A list of variables to be plotted.</li><li><code>title_mapping</code>: A dictionary mapping variable names to their titles.</li><li><code>metrics</code>: Metrics to visualize, e.g., &quot;average&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, and &quot;std&quot;. Default is &quot;median&quot;.</li><li><code>tspan</code>: A tuple representing the start and end time for the simulation.</li><li><code>threshold</code>: A threshold value to filter the data. Default is 0.5.</li><li><code>figsize::Union{Nothing, Tuple{Int64, Int64}}</code>: Size of the figure.</li></ul><p><strong>Returns</strong></p><ul><li>A plot of the glacier statistics evolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_utils.jl#L282-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.plot_glacier_vid-Tuple{String, Vector{Matrix{Float64}}, Glacier2D, SimulationParameters, String}-api" href="#Sleipnir.plot_glacier_vid-Tuple{String, Vector{Matrix{Float64}}, Glacier2D, SimulationParameters, String}-api"><code>Sleipnir.plot_glacier_vid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_glacier_vid(
    plot_type::String,
    H::Vector{Matrix{Float64}},
    glacier::Glacier2D,
    simuparams::SimulationParameters,
    pathVideo::String;
    framerate::Int=24,
    baseTitle::String=&quot;&quot;
)</code></pre><p>Generate various types of videos for glacier data. For now only the evolution of the glacier ice thickness is supported. More types of visualizations will be added in the future. </p><p><strong>Arguments</strong></p><ul><li><code>plot_type</code>: Type of plot to generate. Options are:<ul><li>&quot;thickness&quot;: Heatmap of the glacier thickness.</li></ul></li><li><code>H</code>: A vector of matrices containing the ice thickness over time. This should be   replaced by a Results instance in the future once Results no longer depends on   an iceflow model.</li><li><code>glacier</code>: A glacier instance.</li><li><code>simuparams</code>: The simulation parameters.</li><li><code>pathVideo</code>: Path of the mp4 file to generate.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>framerate</code>: The framerate to use for the video generation.</li><li><code>baseTitle</code>: The prefix to use in the title of the frames. In each frame it is   concatenated with the value of the year in the form &quot; (t=XXXX)&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_plotting_video_utils.jl#L40-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.ratio_max-Tuple{Any, Any}-api" href="#Sleipnir.ratio_max-Tuple{Any, Any}-api"><code>Sleipnir.ratio_max</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ratio_max(v, vabs)</code></pre><p>Compute the maximum ratio between v and vabs at points where the value of vabs is not a NaN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/data/SurfaceVelocityData_utils.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Results{F, I}, 1}, SIM}} where {F&lt;:AbstractFloat, I&lt;:Int64, SIM&lt;:Simulation}-api" href="#Sleipnir.save_results_file!-Union{Tuple{SIM}, Tuple{I}, Tuple{F}, Tuple{Array{Results{F, I}, 1}, SIM}} where {F&lt;:AbstractFloat, I&lt;:Int64, SIM&lt;:Simulation}-api"><code>Sleipnir.save_results_file!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_results_file!(results_list::Vector{Results{F, I}}, simulation::SIM; path::Union{String,Nothing}=nothing) where {F &lt;: AbstractFloat, I &lt;: Int, SIM &lt;: Simulation}</code></pre><p>Save the results of a simulation to a file.</p><p><strong>Arguments</strong></p><ul><li><code>results_list::Vector{Results{F, I}}</code>: A vector containing the results of the simulation.</li><li><code>simulation::SIM</code>: The simulation object containing the parameters and results.</li><li><code>path::Union{String,Nothing}</code>: Optional. The path where the results file will be saved. If not provided, a default path will be used.</li></ul><p><strong>Description</strong></p><p>This function saves the results of a simulation to a file in JLD2 format. If the <code>path</code> argument is not provided, the function will create a default path based on the current project directory. The results are saved in a file named <code>prediction_&lt;nglaciers&gt;glaciers_&lt;tspan&gt;.jld2</code>, where <code>&lt;nglaciers&gt;</code> is the number of glaciers in the simulation and <code>&lt;tspan&gt;</code> is the simulation time span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/results/results_utils.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.smooth!-Tuple{Any}-api" href="#Sleipnir.smooth!-Tuple{Any}-api"><code>Sleipnir.smooth!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth!(A)</code></pre><p>Smooths the interior of a 2D array <code>A</code> using a simple averaging method. The function modifies the array <code>A</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>: A 2D array to be smoothed.</li></ul><p><strong>Details</strong></p><p>The function updates the interior elements of <code>A</code> (excluding the boundary elements) by adding a weighted average of the second differences along both dimensions. The boundary elements are then set to the values of their nearest interior neighbors to maintain the boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/glacier/glacier2D_utils.jl#L609-L619">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.stop_condition_tstops-NTuple{4, Any}-api" href="#Sleipnir.stop_condition_tstops-NTuple{4, Any}-api"><code>Sleipnir.stop_condition_tstops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stop_condition_tstops(u, t, integrator, tstops)</code></pre><p>Check if the current time <code>t</code> is in the list of stop times <code>tstops</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: The current state of the system (not used in this function).</li><li><code>t</code>: The current time.</li><li><code>integrator</code>: The integrator object (not used in this function).</li><li><code>tstops</code>: A collection of times at which the integration should stop.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if <code>t</code> is in <code>tstops</code>, otherwise <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/simulations/simulation_utils.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Sleipnir.trim_period-Tuple{Any, Any}-api" href="#Sleipnir.trim_period-Tuple{Any, Any}-api"><code>Sleipnir.trim_period</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trim_period(period, climate)</code></pre><p>Adjusts the given <code>period</code> to fit within the bounds of the <code>climate</code> data, ensuring it aligns with hydrological years.</p><p><strong>Arguments</strong></p><ul><li><code>period::UnitRange{Date}</code>: The initial date range to be trimmed.</li><li><code>climate::AbstractArray</code>: The climate data array, which should have a time dimension <code>Ti</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>UnitRange{Date}</code>: The adjusted date range that fits within the climate data&#39;s time bounds.</li></ul><p><strong>Details</strong></p><ul><li>If the start of the climate data is later than the start of the period, the period is adjusted to start from October 1st of the year of the climate data&#39;s start.</li><li>If the end of the climate data is earlier than the end of the period, the period is adjusted to end on September 30th of the year of the climate data&#39;s end.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ODINN-SciML/Sleipnir.jl/blob/v0.9.4/src/glaciers/climate/climate2D_utils.jl#L336-L351">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../funcs_types/">« Types and functions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Monday 12 May 2025 22:43">Monday 12 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
